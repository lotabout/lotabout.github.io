<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。&lt;/p&gt;
&lt;p&gt;表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。我们就来逐一说明。&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>手把手教你构建 C 语言编译器（8）- 表达式 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/C/" rel="tag">C</a><a class="post-tag-noise-link" href="/tags/compiler/" rel="tag">compiler</a></div><div class="post-time">2016-01-04</div></div></div><div class="container post-header"><h1>手把手教你构建 C 语言编译器（8）- 表达式</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.</span> <span class="toc-text">运算符的优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">一元运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof"><span class="toc-number">2.2.</span> <span class="toc-text">sizeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">变量与函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.</span> <span class="toc-text">强制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%96%E5%80%BC"><span class="toc-number">2.5.</span> <span class="toc-text">指针取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%9D%80%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.</span> <span class="toc-text">取址操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%8F%96%E5%8F%8D"><span class="toc-number">2.7.</span> <span class="toc-text">逻辑取反</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D"><span class="toc-number">2.8.</span> <span class="toc-text">按位取反</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E8%B4%9F%E5%8F%B7"><span class="toc-number">2.9.</span> <span class="toc-text">正负号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F"><span class="toc-number">2.10.</span> <span class="toc-text">自增自减</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">二元运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">三目运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">数学运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F-v2"><span class="toc-number">3.5.</span> <span class="toc-text">自增自减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.</span> <span class="toc-text">数组取值操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。</p>
<p>表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。我们就来逐一说明。</p>
<span id="more"></span>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h2 id="运算符的优先级"><a class="header-anchor" href="#运算符的优先级"></a>运算符的优先级</h2>
<p>运算符的优先级决定了表达式的运算顺序，如在普通的四则运算中，乘法 <code>*</code> 优先级高于加法 <code>+</code>，这就意味着表达式 <code>2 + 3 * 4</code> 的实际运行顺序是 <code>2 + (3 * 4)</code> 而不是
<code>(2 + 3) * 4</code>。</p>
<p>C 语言定义了各种表达式的优先级，可以参考 <a href="http://en.cppreference.com/w/c/language/operator_precedence">C 语言运算符优先级</a>。</p>
<p>传统的编程书籍会用“逆波兰式”实现四则运算来讲解优先级问题。实际上，优先级关心的就是哪个运算符先计算，哪个运算符后计算（毕竟叫做“优先级”嘛）。而这就意味着我们需要决定先为哪个运算符生成目标代码（汇编），因为汇编代码是顺序排列的，我们必须先计算优先级高的运算符。</p>
<p>那么如何确定运算符的优先级呢？答曰：栈（递归调用的实质也是栈的处理）。</p>
<p>举一个例子：<code>2 + 3 - 4 * 5</code>，它的运算顺序是这样的：</p>
<ol>
<li>将 <code>2</code> 入栈</li>
<li>遇到运算符 <code>+</code>，入栈，此时我们期待的是<code>+</code>的另一个参数</li>
<li>遇到数字 <code>3</code>，原则上我们需要立即计算 <code>2+3</code>的值，但我们不确定数字 <code>3</code> 是否属于优先级更高的运算符，所以先将它入栈。</li>
<li>遇到运算符 <code>-</code>，它的优先级和 <code>+</code> 相同，此时判断参数 <code>3</code> 属于这前的 <code>+</code>。将运算符 <code>+</code> 出栈，并将之前的 <code>2</code> 和 <code>3</code> 出栈，计算 <code>2+3</code> 的结果，得到 <code>5</code> 入栈。同时将运算符 <code>-</code> 入栈。</li>
<li>遇到数字<code>4</code>，同样不能确定是否能立即计算，入栈</li>
<li>遇到运算符 <code>*</code> 优先级大于 <code>-</code>，入栈</li>
<li>遇到数字<code>5</code>，依旧不能确定是否立即计算，入栈</li>
<li>表达式结束，运算符出栈，为 <code>*</code>，将参数出栈，计算 <code>4*5</code> 得到结果 <code>20</code> 入栈。</li>
<li>运算符出栈，为 <code>-</code>，将参数出栈，计算 <code>5-20</code>，得到 <code>-15</code> 入栈。</li>
<li>此时运算符栈为空，因此得到结果 <code>-15</code>。</li>
</ol>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// after step 1, 2</span><br><span class="line">|      |</span><br><span class="line">+------+</span><br><span class="line">| 3    |   |      |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 2    |   | +    |</span><br><span class="line">+------+   +------+</span><br><span class="line"></span><br><span class="line">// after step 4</span><br><span class="line">|      |   |      |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 5    |   | -    |</span><br><span class="line">+------+   +------+</span><br><span class="line"></span><br><span class="line">// after step 7</span><br><span class="line">|      |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 4    |   | *    |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 5    |   | -    |</span><br><span class="line">+------+   +------+</span><br></pre></td></tr></table></figure></div>
<p>综上，在计算一个运算符‘x’之前，必须先查看它的右方，找出并计算所有优先级大于‘x’的运算符，之后再计算运算符‘x’。</p>
<p>最后注意的是优先通常只与多元运算符相关，单元运算符往往没有这个问题（因为只有一个参数）。也可以认为“优先级”的实质就是两个运算符在抢参数。</p>
<h2 id="一元运算符"><a class="header-anchor" href="#一元运算符"></a>一元运算符</h2>
<p>上节中说到了运算符的优先级，也提到了优先级一般只与多元运算符有关，这也意味着一元运算符的优先级总是高于多元运算符。因为我们需要先对它们进行解析。</p>
<p>当然，这部分也将同时解析参数本身（如变量、数字、字符串等等）。</p>
<p>关于表达式的解析，与语法分析相关的部分就是上文所说的优先级问题了，而剩下的较难较烦的部分是与目标代码的生成有关的。因此对于需要讲解的运算符，我们主要从它的目标代码入手。</p>
<h3 id="常量"><a class="header-anchor" href="#常量"></a>常量</h3>
<p>首先是数字，用 <code>IMM</code> 指令将它加载到 <code>AX</code> 中即可：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (token == Num) &#123;</span><br><span class="line">    match(Num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit code</span></span><br><span class="line">    *++text = IMM;</span><br><span class="line">    *++text = token_val;</span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>接着是字符串常量。它比较特殊的一点是 C 语言的字符串常量支持如下风格：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p = <span class="string">&quot;first line&quot;</span></span><br><span class="line">    <span class="string">&quot;second line&quot;</span>;</span><br></pre></td></tr></table></figure></div>
<p>即跨行的字符串拼接，它相当于：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p = <span class="string">&quot;first linesecond line&quot;</span>;</span><br></pre></td></tr></table></figure></div>
<p>所以解析的时候要注意这一点：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// emit code</span></span><br><span class="line">    *++text = IMM;</span><br><span class="line">    *++text = token_val;</span><br><span class="line"></span><br><span class="line">    match(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    <span class="comment">// store the rest strings</span></span><br><span class="line">    <span class="keyword">while</span> (token == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">        match(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// append the end of string character &#x27;\0&#x27;, all the data are default</span></span><br><span class="line">    <span class="comment">// to 0, so just move data one position forward.</span></span><br><span class="line">    data = (<span class="type">char</span> *)(((<span class="type">int</span>)data + <span class="keyword">sizeof</span>(<span class="type">int</span>)) &amp; (-<span class="keyword">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">    expr_type = PTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="sizeof"><a class="header-anchor" href="#sizeof"></a>sizeof</h3>
<p><code>sizeof</code> 是一个一元运算符，我们需要知道后面参数的类型，类型的解析在前面的文章中我们已经很熟悉了。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Sizeof) &#123;</span><br><span class="line">    <span class="comment">// sizeof is actually an unary operator</span></span><br><span class="line">    <span class="comment">// now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are</span></span><br><span class="line">    <span class="comment">// supported.</span></span><br><span class="line">    match(Sizeof);</span><br><span class="line">    match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    expr_type = INT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == Int) &#123;</span><br><span class="line">        match(Int);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) &#123;</span><br><span class="line">        match(Char);</span><br><span class="line">        expr_type = CHAR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (token == Mul) &#123;</span><br><span class="line">        match(Mul);</span><br><span class="line">        expr_type = expr_type + PTR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit code</span></span><br><span class="line">    *++text = IMM;</span><br><span class="line">    *++text = (expr_type == CHAR) ? <span class="keyword">sizeof</span>(<span class="type">char</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意的是只支持 <code>sizeof(int)</code>，<code>sizeof(char)</code> 及 <code>sizeof(pointer type...)</code>。并且它的结果是 <code>int</code> 型。</p>
<h3 id="变量与函数调用"><a class="header-anchor" href="#变量与函数调用"></a>变量与函数调用</h3>
<p>由于取变量的值与函数的调用都是以 <code>Id</code> 标记开头的，因此将它们放在一起处理。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Id) &#123;</span><br><span class="line">    <span class="comment">// there are several type when occurs to Id</span></span><br><span class="line">    <span class="comment">// but this is unit, so it can only be</span></span><br><span class="line">    <span class="comment">// 1. function call</span></span><br><span class="line">    <span class="comment">// 2. Enum variable</span></span><br><span class="line">    <span class="comment">// 3. global/local variable</span></span><br><span class="line">    match(Id);</span><br><span class="line"></span><br><span class="line">    id = current_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// function call</span></span><br><span class="line">        match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        <span class="comment">// pass in arguments</span></span><br><span class="line">        tmp = <span class="number">0</span>; <span class="comment">// number of arguments</span></span><br><span class="line">        <span class="keyword">while</span> (token != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            expression(Assign);</span><br><span class="line">            *++text = PUSH;</span><br><span class="line">            tmp ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②</span></span><br><span class="line">        <span class="comment">// emit code</span></span><br><span class="line">        <span class="keyword">if</span> (id[Class] == Sys) &#123;</span><br><span class="line">            <span class="comment">// system functions</span></span><br><span class="line">            *++text = id[Value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id[Class] == Fun) &#123;</span><br><span class="line">            <span class="comment">// function call</span></span><br><span class="line">            *++text = CALL;</span><br><span class="line">            *++text = id[Value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad function call\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③</span></span><br><span class="line">        <span class="comment">// clean the stack for arguments</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            *++text = ADJ;</span><br><span class="line">            *++text = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        expr_type = id[Type];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id[Class] == Num) &#123;</span><br><span class="line">        <span class="comment">// ④</span></span><br><span class="line">        <span class="comment">// enum variable</span></span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = id[Value];</span><br><span class="line">        expr_type = INT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⑤</span></span><br><span class="line">        <span class="comment">// variable</span></span><br><span class="line">        <span class="keyword">if</span> (id[Class] == Loc) &#123;</span><br><span class="line">            *++text = LEA;</span><br><span class="line">            *++text = index_of_bp - id[Value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id[Class] == Glo) &#123;</span><br><span class="line">            *++text = IMM;</span><br><span class="line">            *++text = id[Value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: undefined variable\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//⑥</span></span><br><span class="line">        <span class="comment">// emit code, default behaviour is to load the value of the</span></span><br><span class="line">        <span class="comment">// address which is stored in `ax`</span></span><br><span class="line">        expr_type = id[Type];</span><br><span class="line">        *++text = (expr_type == Char) ? LC : LI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>①中注意我们是顺序将参数入栈，这和第三章：虚拟机中讲解的指令是对应的。与之不同，标准 C 是逆序将参数入栈的。</p>
<p>②中判断函数的类型，同样在第三章：“虚拟机”中我们介绍过内置函数的支持，如
<code>printf</code>, <code>read</code>, <code>malloc</code> 等等。内置函数有对应的汇编指令，而普通的函数则编译成 <code>CALL &lt;addr&gt;</code> 的形式。</p>
<p>③用于清除入栈的参数。因为我们不在乎出栈的值，所以直接修改栈指针的大小即可。</p>
<p>④：当该标识符是全局定义的枚举类型时，直接将对应的值用 <code>IMM</code> 指令存入 <code>AX</code> 即可。</p>
<p>⑤则是用于加载变量的值，如果是局部变量则采用与 <code>bp</code> 指针相对位置的形式（参见第
7章函数定义）。而如果是全局变量则用 <code>IMM</code> 加载变量的地址。</p>
<p>⑥：无论是全局还是局部变量，最终都根据它们的类型用 <code>LC</code> 或 <code>LI</code> 指令加载对应的值。</p>
<p>关于变量，你可能有疑问，如果遇到标识符就用 <code>LC/LI</code> 载入相应的值，那诸如
<code>a[10]</code> 之类的表达式要如何实现呢？后面我们会看到，根据标识符后的运算符，我们可能会修改或删除现有的 <code>LC/LI</code> 指令。</p>
<h3 id="强制转换"><a class="header-anchor" href="#强制转换"></a>强制转换</h3>
<p>虽然我们前面没有提到，但我们一直用 <code>expr_type</code> 来保存一个表达式的类型，强制转换的作用是获取转换的类型，并直接修改 <code>expr_type</code> 的值。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// cast or parenthesis</span></span><br><span class="line">    match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token == Int || token == Char) &#123;</span><br><span class="line">        tmp = (token == Char) ? CHAR : INT; <span class="comment">// cast type</span></span><br><span class="line">        match(token);</span><br><span class="line">        <span class="keyword">while</span> (token == Mul) &#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            tmp = tmp + PTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        expression(Inc); <span class="comment">// cast has precedence as Inc(++)</span></span><br><span class="line"></span><br><span class="line">        expr_type  = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// normal parenthesis</span></span><br><span class="line">        expression(Assign);</span><br><span class="line">        match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="指针取值"><a class="header-anchor" href="#指针取值"></a>指针取值</h3>
<p>诸如 <code>*a</code> 的指针取值，关键是判断 <code>a</code> 的类型，而就像上节中提到的，当一个表达式解析结束时，它的类型保存在变量 <code>expr_type</code> 中。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Mul) &#123;</span><br><span class="line">    <span class="comment">// dereference *&lt;addr&gt;</span></span><br><span class="line">    match(Mul);</span><br><span class="line">    expression(Inc); <span class="comment">// dereference has the same precedence as Inc(++)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expr_type &gt;= PTR) &#123;</span><br><span class="line">        expr_type = expr_type - PTR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: bad dereference\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *++text = (expr_type == CHAR) ? LC : LI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="取址操作"><a class="header-anchor" href="#取址操作"></a>取址操作</h3>
<p>这里我们就能看到“变量与函数调用”一节中所说的修改或删除 <code>LC/LI</code> 指令了。前文中我们说到，对于变量，我们会先加载它的地址，并根据它们类型使用 <code>LC/LI</code> 指令加载实际内容，例如对变量 <code>a</code>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMM &lt;addr&gt;</span><br><span class="line">LI</span><br></pre></td></tr></table></figure></div>
<p>那么对变量 <code>a</code> 取址，其实只要不执行 <code>LC/LI</code> 即可。因此我们删除相应的指令。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == And) &#123;</span><br><span class="line">    <span class="comment">// get the address of</span></span><br><span class="line">    match(And);</span><br><span class="line">    expression(Inc); <span class="comment">// get the address of</span></span><br><span class="line">    <span class="keyword">if</span> (*text == LC || *text == LI) &#123;</span><br><span class="line">        text --;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: bad address of\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expr_type = expr_type + PTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="逻辑取反"><a class="header-anchor" href="#逻辑取反"></a>逻辑取反</h3>
<p>我们没有直接的逻辑取反指令，因此我们判断它是否与数字 0 相等。而数字 0 代表了逻辑 “False”。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// not</span></span><br><span class="line">    match(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    expression(Inc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit code, use &lt;expr&gt; == 0</span></span><br><span class="line">    *++text = PUSH;</span><br><span class="line">    *++text = IMM;</span><br><span class="line">    *++text = <span class="number">0</span>;</span><br><span class="line">    *++text = EQ;</span><br><span class="line"></span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="按位取反"><a class="header-anchor" href="#按位取反"></a>按位取反</h3>
<p>同样我们没有相应的指令，所以我们用异或来实现，即 <code>~a = a ^ 0xFFFF</code>。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;~&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// bitwise not</span></span><br><span class="line">    match(<span class="string">&#x27;~&#x27;</span>);</span><br><span class="line">    expression(Inc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit code, use &lt;expr&gt; XOR -1</span></span><br><span class="line">    *++text = PUSH;</span><br><span class="line">    *++text = IMM;</span><br><span class="line">    *++text = <span class="number">-1</span>;</span><br><span class="line">    *++text = XOR;</span><br><span class="line"></span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="正负号"><a class="header-anchor" href="#正负号"></a>正负号</h3>
<p>注意这里并不是四则运算中的加减法，而是单个数字的取正取负操作。同样，我们没有取负的操作，用 <code>0 - x</code> 来实现 <code>-x</code>。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Add) &#123;</span><br><span class="line">    <span class="comment">// +var, do nothing</span></span><br><span class="line">    match(Add);</span><br><span class="line">    expression(Inc);</span><br><span class="line"></span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Sub) &#123;</span><br><span class="line">    <span class="comment">// -var</span></span><br><span class="line">    match(Sub);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == Num) &#123;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = -token_val;</span><br><span class="line">        match(Num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = <span class="number">-1</span>;</span><br><span class="line">        *++text = PUSH;</span><br><span class="line">        expression(Inc);</span><br><span class="line">        *++text = MUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="自增自减"><a class="header-anchor" href="#自增自减"></a>自增自减</h3>
<p>注意的是自增自减操作的优先级是和它的位置有关的。如 <code>++p</code> 的优先级高于 <code>p++</code>，这里我们解析的就是类似 <code>++p</code> 的操作。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Inc || token == Dec) &#123;</span><br><span class="line">    tmp = token;</span><br><span class="line">    match(token);</span><br><span class="line">    expression(Inc);</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (*text == LC) &#123;</span><br><span class="line">        *text = PUSH;  <span class="comment">// to duplicate the address</span></span><br><span class="line">        *++text = LC;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*text == LI) &#123;</span><br><span class="line">        *text = PUSH;</span><br><span class="line">        *++text = LI;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: bad lvalue of pre-increment\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = PUSH;</span><br><span class="line">    *++text = IMM;</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    *++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="type">int</span>) : <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    *++text = (tmp == Inc) ? ADD : SUB;</span><br><span class="line">    *++text = (expr_type == CHAR) ? SC : SI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对应的汇编代码也比较直观，只是在实现 <code>++p</code>时，我们要使用变量 <code>p</code> 的地址两次，所以我们需要先 <code>PUSH</code> （①）。</p>
<p>②则是因为自增自减操作还需要处理是指针的情形。</p>
<h2 id="二元运算符"><a class="header-anchor" href="#二元运算符"></a>二元运算符</h2>
<p>这里，我们需要处理多运算符的优先级问题，就如前文的“优先级”一节提到的，我们需要不断地向右扫描，直到遇到优先级 <strong>小于</strong> 当前优先级的运算符。</p>
<p>回想起我们之前定义过的各个标记，它们是以优先级从低到高排列的，即 <code>Assign</code> 的优先级最低，而 <code>Brak</code>（<code>[</code>） 的优先级最高。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">  Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>所以，当我们调用 <code>expression(level)</code> 进行解析的时候，我们其实通过了参数
<code>level</code> 指定了当前的优先级。在前文的一元运算符处理中也用到了这一点。</p>
<p>所以，此时的二元运算符的解析的框架为：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (token &gt;= level) &#123;</span><br><span class="line">    <span class="comment">// parse token for binary operator and postfix operator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>解决了优先级的问题，让我们继续讲解如何把运算符编译成汇编代码吧。</p>
<h3 id="赋值操作"><a class="header-anchor" href="#赋值操作"></a>赋值操作</h3>
<p>赋值操作是优先级最低的运算符。考虑诸如 <code>a = (expession)</code> 的表达式，在解析 <code>=</code>
之前，我们已经为变量 <code>a</code> 生成了如下的汇编代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMM &lt;addr&gt;</span><br><span class="line">LC/LI</span><br></pre></td></tr></table></figure></div>
<p>当解析完<code>=</code>右边的表达式后，相应的值会存放在 <code>ax</code> 中，此时，为了实际将这个值保存起来，我们需要类似下面的汇编代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMM &lt;addr&gt;</span><br><span class="line">PUSH</span><br><span class="line">SC/SI</span><br></pre></td></tr></table></figure></div>
<p>明白了这点，也就能理解下面的源代码了：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tmp = expr_type;</span><br><span class="line"><span class="keyword">if</span> (token == Assign) &#123;</span><br><span class="line">    <span class="comment">// var = expr;</span></span><br><span class="line">    match(Assign);</span><br><span class="line">    <span class="keyword">if</span> (*text == LC || *text == LI) &#123;</span><br><span class="line">        *text = PUSH; <span class="comment">// save the lvalue&#x27;s pointer</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: bad lvalue in assignment\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    expression(Assign);</span><br><span class="line"></span><br><span class="line">    expr_type = tmp;</span><br><span class="line">    *++text = (expr_type == CHAR) ? SC : SI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="三目运算符"><a class="header-anchor" href="#三目运算符"></a>三目运算符</h3>
<p>这是 C 语言中唯一的一个三元运算符： <code>? :</code>，它相当于一个小型的 If 语句，所以生成的代码也类似于 If 语句，这里就不多作解释。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Cond) &#123;</span><br><span class="line">    <span class="comment">// expr ? a : b;</span></span><br><span class="line">    match(Cond);</span><br><span class="line">    *++text = JZ;</span><br><span class="line">    addr = ++text;</span><br><span class="line">    expression(Assign);</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">        match(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: missing colon in conditional\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *addr = (<span class="type">int</span>)(text + <span class="number">3</span>);</span><br><span class="line">    *++text = JMP;</span><br><span class="line">    addr = ++text;</span><br><span class="line">    expression(Cond);</span><br><span class="line">    *addr = (<span class="type">int</span>)(text + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符"></a>逻辑运算符</h3>
<p>这包括 <code>||</code> 和 <code>&amp;&amp;</code>。它们对应的汇编代码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expr1&gt; || &lt;expr2&gt;     &lt;expr1&gt; &amp;&amp; &lt;expr2&gt;</span><br><span class="line"></span><br><span class="line">  ...&lt;expr1&gt;...          ...&lt;expr1&gt;...</span><br><span class="line">  JNZ b                  JZ b</span><br><span class="line">  ...&lt;expr2&gt;...          ...&lt;expr2&gt;...</span><br><span class="line">b:                     b:</span><br></pre></td></tr></table></figure></div>
<p>所以源码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Lor) &#123;</span><br><span class="line">    <span class="comment">// logic or</span></span><br><span class="line">    match(Lor);</span><br><span class="line">    *++text = JNZ;</span><br><span class="line">    addr = ++text;</span><br><span class="line">    expression(Lan);</span><br><span class="line">    *addr = (<span class="type">int</span>)(text + <span class="number">1</span>);</span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Lan) &#123;</span><br><span class="line">    <span class="comment">// logic and</span></span><br><span class="line">    match(Lan);</span><br><span class="line">    *++text = JZ;</span><br><span class="line">    addr = ++text;</span><br><span class="line">    expression(Or);</span><br><span class="line">    *addr = (<span class="type">int</span>)(text + <span class="number">1</span>);</span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="数学运算符"><a class="header-anchor" href="#数学运算符"></a>数学运算符</h3>
<p>它们包括 <code>|</code>, <code>^</code>, <code>&amp;</code>, <code>==</code>, <code>!=</code> <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>, <code>%</code>。它们的实现都很类似，我们以异或 <code>^</code> 为例：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expr1&gt; ^ &lt;expr2&gt;</span><br><span class="line"></span><br><span class="line">...&lt;expr1&gt;...          &lt;- now the result is on ax</span><br><span class="line">PUSH</span><br><span class="line">...&lt;expr2&gt;...          &lt;- now the value of &lt;expr2&gt; is on ax</span><br><span class="line">XOR</span><br></pre></td></tr></table></figure></div>
<p>所以它对应的代码为：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Xor) &#123;</span><br><span class="line">    <span class="comment">// bitwise xor</span></span><br><span class="line">    match(Xor);</span><br><span class="line">    *++text = PUSH;</span><br><span class="line">    expression(And);</span><br><span class="line">    *++text = XOR;</span><br><span class="line">    expr_type = INT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其它的我们便不再详述。但这当中还有一个问题，就是指针的加减。在 C 语言中，指针加上数值等于将指针移位，且根据不同的类型移动的位移不同。如 <code>a + 1</code>，如果 <code>a</code>
是 <code>char *</code> 型，则移动一字节，而如果 <code>a</code> 是 <code>int *</code> 型，则移动 4 个字节（32位系统）。</p>
<p>另外，在作指针减法时，如果是两个指针相减（相同类型），则结果是两个指针间隔的元素个数。因此要有特殊的处理。</p>
<p>下面以加法为例，对应的汇编代码为：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expr1&gt; + &lt;expr2&gt;</span><br><span class="line"></span><br><span class="line">normal         pointer</span><br><span class="line"></span><br><span class="line">&lt;expr1&gt;        &lt;expr1&gt;</span><br><span class="line">PUSH           PUSH</span><br><span class="line">&lt;expr2&gt;        &lt;expr2&gt;     |</span><br><span class="line">ADD            PUSH        | &lt;expr2&gt; * &lt;unit&gt;</span><br><span class="line">               IMM &lt;unit&gt;  |</span><br><span class="line">               MUL         |</span><br><span class="line">               ADD</span><br></pre></td></tr></table></figure></div>
<p>即当 <code>&lt;expr1&gt;</code> 是指针时，要根据它的类型放大 <code>&lt;expr2&gt;</code> 的值，因此对应的源码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Add) &#123;</span><br><span class="line">    <span class="comment">// add</span></span><br><span class="line">    match(Add);</span><br><span class="line">    *++text = PUSH;</span><br><span class="line">    expression(Mul);</span><br><span class="line"></span><br><span class="line">    expr_type = tmp;</span><br><span class="line">    <span class="keyword">if</span> (expr_type &gt; PTR) &#123;</span><br><span class="line">        <span class="comment">// pointer type, and not `char *`</span></span><br><span class="line">        *++text = PUSH;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        *++text = MUL;</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = ADD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>相应的减法的代码就不贴了，可以自己实现看看，也可以看文末给出的链接。</p>
<h3 id="自增自减-v2"><a class="header-anchor" href="#自增自减-v2"></a>自增自减</h3>
<p>这次是后缀形式的，即 <code>p++</code> 或 <code>p--</code>。与前缀形式不同的是，在执行自增自减后，
<code>ax</code>上需要保留原来的值。所以我们首先执行类似前缀自增自减的操作，再将 <code>ax</code> 中的值执行减/增的操作。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀形式 生成汇编代码</span></span><br><span class="line">*++text = PUSH;</span><br><span class="line">*++text = IMM;</span><br><span class="line">*++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="type">int</span>) : <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">*++text = (tmp == Inc) ? ADD : SUB;</span><br><span class="line">*++text = (expr_type == CHAR) ? SC : SI;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀形式 生成汇编代码</span></span><br><span class="line">*++text = PUSH;</span><br><span class="line">*++text = IMM;</span><br><span class="line">*++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="type">int</span>) : <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">*++text = (token == Inc) ? ADD : SUB;</span><br><span class="line">*++text = (expr_type == CHAR) ? SC : SI;</span><br><span class="line">*++text = PUSH;                                             <span class="comment">//</span></span><br><span class="line">*++text = IMM;                                              <span class="comment">// 执行相反的增/减操作</span></span><br><span class="line">*++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="type">int</span>) : <span class="keyword">sizeof</span>(<span class="type">char</span>);   <span class="comment">//</span></span><br><span class="line">*++text = (token == Inc) ? SUB : ADD;                       <span class="comment">//</span></span><br></pre></td></tr></table></figure></div>
<h3 id="数组取值操作"><a class="header-anchor" href="#数组取值操作"></a>数组取值操作</h3>
<p>在学习 C 语言的时候你可能已经知道了，诸如 <code>a[10]</code> 的操作等价于 <code>*(a + 10)</code>。因此我们要做的就是生成类似的汇编代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Brak) &#123;</span><br><span class="line">    <span class="comment">// array access var[xx]</span></span><br><span class="line">    match(Brak);</span><br><span class="line">    *++text = PUSH;</span><br><span class="line">    expression(Assign);</span><br><span class="line">    match(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; PTR) &#123;</span><br><span class="line">        <span class="comment">// pointer, `not char *`</span></span><br><span class="line">        *++text = PUSH;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        *++text = MUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; PTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: pointer type expected\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    expr_type = tmp - PTR;</span><br><span class="line">    *++text = ADD;</span><br><span class="line">    *++text = (expr_type == CHAR) ? LC : LI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="代码"><a class="header-anchor" href="#代码"></a>代码</h2>
<p>除了上述对表达式的解析外，我们还需要初始化虚拟机的栈，我们可以正确调用
<code>main</code> 函数，且当 <code>main</code> 函数结束时退出进程。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *tmp;</span><br><span class="line"><span class="comment">// setup stack</span></span><br><span class="line">sp = (<span class="type">int</span> *)((<span class="type">int</span>)<span class="built_in">stack</span> + poolsize);</span><br><span class="line">*--sp = EXIT; <span class="comment">// call exit if main returns</span></span><br><span class="line">*--sp = PUSH; tmp = sp;</span><br><span class="line">*--sp = argc;</span><br><span class="line">*--sp = (<span class="type">int</span>)argv;</span><br><span class="line">*--sp = (<span class="type">int</span>)tmp;</span><br></pre></td></tr></table></figure></div>
<p>当然，最后要注意的一点是：所有的变量定义必须放在语句之前。</p>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-6">Github</a> 上下载，也可以直接 clone</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b step-6 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure></div>
<p>通过 <code>gcc -o xc-tutor xc-tutor.c</code> 进行编译。并执行 <code>./xc-tutor hello.c</code> 查看结果。</p>
<p>正如我们保证的那样，我们的代码是自举的，能自己编译自己，所以你可以执行
<code>./xc-tutor xc-tutor.c hello.c</code>。可以看到和之前有同样的输出。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>本章我们进行了最后的解析，解析表达式。本章有两个难点：</p>
<ol>
<li>如何通过递归调用 <code>expression</code> 来实现运算符的优先级。</li>
<li>如何为每个运算符生成对应的汇编代码。</li>
</ol>
<p>尽管代码看起来比较简单（虽然多），但其中用到的原理还是需要仔细推敲的。</p>
<p>最后，恭喜你！通过一步步的学习，自己实现了一个C语言的编译器（好吧，是解释器）。</p>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>