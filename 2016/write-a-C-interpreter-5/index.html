<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义部分。&lt;/p&gt;
&lt;p&gt;由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>手把手教你构建 C 语言编译器（5）- 变量定义 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/C/" rel="tag">C</a><a class="post-tag-noise-link" href="/tags/compiler/" rel="tag">compiler</a></div><div class="post-time">2016-01-03</div></div></div><div class="container post-header"><h1>手把手教你构建 C 语言编译器（5）- 变量定义</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ebnf-%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.</span> <span class="toc-text">EBNF 表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">解析变量的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#program"><span class="toc-number">2.1.</span> <span class="toc-text">program()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#global-declaration"><span class="toc-number">2.2.</span> <span class="toc-text">global_declaration()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum-declaration"><span class="toc-number">2.3.</span> <span class="toc-text">enum_declaration()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">2.4.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义部分。</p>
<p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。</p>
<span id="more"></span>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h2 id="ebnf-表示"><a class="header-anchor" href="#ebnf-表示"></a>EBNF 表示</h2>
<p>EBNF 是对前一章提到的 BNF 的扩展，它的语法更容易理解，实现起来也更直观。但真正看起来还是很烦，如果不想看可以跳过。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">program ::= &#123;global_declaration&#125;+</span><br><span class="line"></span><br><span class="line">global_declaration ::= enum_decl | variable_decl | function_decl</span><br><span class="line"></span><br><span class="line">enum_decl ::= &#x27;enum&#x27; [id] &#x27;&#123;&#x27; id [&#x27;=&#x27; &#x27;num&#x27;] &#123;&#x27;,&#x27; id [&#x27;=&#x27; &#x27;num&#x27;] &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">variable_decl ::= type &#123;&#x27;*&#x27;&#125; id &#123; &#x27;,&#x27; &#123;&#x27;*&#x27;&#125; id &#125; &#x27;;&#x27;</span><br><span class="line"></span><br><span class="line">function_decl ::= type &#123;&#x27;*&#x27;&#125; id &#x27;(&#x27; parameter_decl &#x27;)&#x27; &#x27;&#123;&#x27; body_decl &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">parameter_decl ::= type &#123;&#x27;*&#x27;&#125; id &#123;&#x27;,&#x27; type &#123;&#x27;*&#x27;&#125; id&#125;</span><br><span class="line"></span><br><span class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</span><br><span class="line"></span><br><span class="line">statement ::= non_empty_statement | empty_statement</span><br><span class="line"></span><br><span class="line">non_empty_statement ::= if_statement | while_statement | &#x27;&#123;&#x27; statement &#x27;&#125;&#x27;</span><br><span class="line">                     | &#x27;return&#x27; expression | expression &#x27;;&#x27;</span><br><span class="line"></span><br><span class="line">if_statement ::= &#x27;if&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statement [&#x27;else&#x27; non_empty_statement]</span><br><span class="line"></span><br><span class="line">while_statement ::= &#x27;while&#x27; &#x27;(&#x27; expression &#x27;)&#x27; non_empty_statement</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>expression</code> 相关的内容我们放到后面解释，主要原因是我们的语言不支持跨函数递归，而为了实现自举，实际上我们也不能使用递归（亏我们说了一章的递归下降）。</p>
<p>P.S. 我是先写程序再总结上面的文法，所以实际上它们间的对应关系并不是特别明显。</p>
<h2 id="解析变量的定义"><a class="header-anchor" href="#解析变量的定义"></a>解析变量的定义</h2>
<p>本章要讲解的就是上节文法中的 <code>enum_decl</code> 和 <code>variable_decl</code> 部分。</p>
<h3 id="program"><a class="header-anchor" href="#program"></a>program()</h3>
<p>首先是之前定义过的 <code>program</code> 函数，将它改成：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// get next token</span></span><br><span class="line">    next();</span><br><span class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        global_declaration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我知道 <code>global_declaration</code> 函数还没有出现过，但没有关系，采用自顶向下的编写方法就是要不断地实现我们需要的内容。下面是 <code>global_declaration</code> 函数的内容：</p>
<h3 id="global-declaration"><a class="header-anchor" href="#global-declaration"></a>global_declaration()</h3>
<p>即全局的定义语句，包括变量定义，类型定义（只支持枚举）及函数定义。代码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> basetype;    <span class="comment">// the type of a declaration, make it global for convenience</span></span><br><span class="line"><span class="type">int</span> expr_type;   <span class="comment">// the type of an expression</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">global_declaration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// global_declaration ::= enum_decl | variable_decl | function_decl</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// enum_decl ::= &#x27;enum&#x27; [id] &#x27;&#123;&#x27; id [&#x27;=&#x27; &#x27;num&#x27;] &#123;&#x27;,&#x27; id [&#x27;=&#x27; &#x27;num&#x27;&#125; &#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// variable_decl ::= type &#123;&#x27;*&#x27;&#125; id &#123; &#x27;,&#x27; &#123;&#x27;*&#x27;&#125; id &#125; &#x27;;&#x27;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// function_decl ::= type &#123;&#x27;*&#x27;&#125; id &#x27;(&#x27; parameter_decl &#x27;)&#x27; &#x27;&#123;&#x27; body_decl &#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// tmp, actual type for variable</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// tmp</span></span><br><span class="line"></span><br><span class="line">    basetype = INT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse enum, this should be treated alone.</span></span><br><span class="line">    <span class="keyword">if</span> (token == Enum) &#123;</span><br><span class="line">        <span class="comment">// enum [id] &#123; a = 10, b = 20, ... &#125;</span></span><br><span class="line">        match(Enum);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            match(Id); <span class="comment">// skip the [id] part</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// parse the assign part</span></span><br><span class="line">            match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            enum_declaration();</span><br><span class="line">            match(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse type information</span></span><br><span class="line">    <span class="keyword">if</span> (token == Int) &#123;</span><br><span class="line">        match(Int);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) &#123;</span><br><span class="line">        match(Char);</span><br><span class="line">        basetype = CHAR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse the comma seperated variable declaration.</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="string">&#x27;;&#x27;</span> &amp;&amp; token != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">        type = basetype;</span><br><span class="line">        <span class="comment">// parse pointer type, note that there may exist `int ****x;`</span></span><br><span class="line">        <span class="keyword">while</span> (token == Mul) &#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token != Id) &#123;</span><br><span class="line">            <span class="comment">// invalid declaration</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_id[Class]) &#123;</span><br><span class="line">            <span class="comment">// identifier exists</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: duplicate global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(Id);</span><br><span class="line">        current_id[Type] = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            current_id[Class] = Fun;</span><br><span class="line">            current_id[Value] = (<span class="type">int</span>)(text + <span class="number">1</span>); <span class="comment">// the memory address of function</span></span><br><span class="line">            function_declaration();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// variable declaration</span></span><br><span class="line">            current_id[Class] = Glo; <span class="comment">// global variable</span></span><br><span class="line">            current_id[Value] = (<span class="type">int</span>)data; <span class="comment">// assign memory address</span></span><br><span class="line">            data = data + <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>看了上面的代码，能大概理解吗？这里我们讲解其中的一些细节。</p>
<p><strong>向前看标记</strong> ：其中的 <code>if (token == xxx)</code> 语句就是用来向前查看标记以确定使用哪一个产生式，例如只要遇到 <code>enum</code> 我们就知道是需要解析枚举类型。而如果只解析到类型，如 <code>int identifier</code> 时我们并不能确定 <code>identifier</code> 是一个普通的变量还是一个函数，所以还需要继续查看后续的标记，如果遇到 <code>(</code> 则可以断定是函数了，反之则是变量。</p>
<p><strong>变量类型的表示</strong> ：我们的编译器支持指针类型，那意味着也支持指针的指针，如
<code>int **data;</code>。那么我们如何表示指针类型呢？前文中我们定义了支持的类型：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types of variable/function</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> CHAR, INT, PTR &#125;;</span><br></pre></td></tr></table></figure></div>
<p>所以一个类型首先有基本类型，如 <code>CHAR</code> 或 <code>INT</code>，当它是一个指向基本类型的指针时，如 <code>int *data</code>，我们就将它的类型加上 <code>PTR</code> 即代码中的：<code>type = type + PTR;</code>。同理，如果是指针的指针，则再加上 <code>PTR</code>。</p>
<h3 id="enum-declaration"><a class="header-anchor" href="#enum-declaration"></a>enum_declaration()</h3>
<p>用于解析枚举类型的定义。主要的逻辑用于解析用逗号（<code>,</code>）分隔的变量，值得注意的是在编译器中如何保存枚举变量的信息。</p>
<p>即我们将该变量的类别设置成了 <code>Num</code>，这样它就成了全局的常量了，而注意到上节中，正常的全局变量的类别则是 <code>Glo</code>，类别信息在后面章节中解析 <code>expression</code> 会使用到。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enum_declaration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// parse enum [id] &#123; a = 1, b = 3, ...&#125;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token != Id) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad enum identifier %d\n&quot;</span>, line, token);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">        <span class="keyword">if</span> (token == Assign) &#123;</span><br><span class="line">            <span class="comment">// like &#123;a=10&#125;</span></span><br><span class="line">            next();</span><br><span class="line">            <span class="keyword">if</span> (token != Num) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: bad enum initializer\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i = token_val;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current_id[Class] = Num;</span><br><span class="line">        current_id[Type] = INT;</span><br><span class="line">        current_id[Value] = i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="其它"><a class="header-anchor" href="#其它"></a>其它</h3>
<p>其中的 <code>function_declaration</code> 函数我们将放到下一章中讲解。<code>match</code> 函数是一个辅助函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span> tk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token == tk) &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: expected token: %d\n&quot;</span>, line, tk);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>它将 <code>next</code> 函数包装起来，如果不是预期的标记则报错并退出。</p>
<h2 id="代码"><a class="header-anchor" href="#代码"></a>代码</h2>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-3">Github</a> 上下载，也可以直接 clone</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b step-3 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure></div>
<p>本章的代码还无法正常运行，因为还有许多功能没有实现，但如果有兴趣的话，可以自己先试着去实现它。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>本章的内容应该不难，除了开头的 EBNF 表达式可能相对不好理解一些，但如果你查看了
EBNF 的具体表示方法后就不难理解了。</p>
<p>剩下的内容就是按部就班地将 EBNF 的产生式转换成函数的过程，如果你理解了上一章中的内容，相信这部分也不难理解。</p>
<p>下一章中我们将介绍如何解析函数的定义，敬请期待。</p>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>