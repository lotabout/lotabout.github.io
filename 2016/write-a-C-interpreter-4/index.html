<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>手把手教你构建 C 语言编译器（4）- 递归下降 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/C/" rel="tag">C</a><a class="post-tag-noise-link" href="/tags/compiler/" rel="tag">compiler</a></div><div class="post-time">2016-01-02</div></div></div><div class="container post-header"><h1>手把手教你构建 C 语言编译器（4）- 递归下降</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D"><span class="toc-number">1.</span> <span class="toc-text">什么是递归下降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E7%AC%A6%E4%B8%8E%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">终结符与非终结符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D"><span class="toc-number">3.</span> <span class="toc-text">四则运算的递归下降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D"><span class="toc-number">4.</span> <span class="toc-text">为什么选择递归下降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">5.</span> <span class="toc-text">左递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">四则运算的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。</p>
<span id="more"></span>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h2 id="什么是递归下降"><a class="header-anchor" href="#什么是递归下降"></a>什么是递归下降</h2>
<p>传统上，编写语法分析器有两种方法，一种是自顶向下，一种是自底向上。自顶向下是从起始非终结符开始，不断地对非终结符进行分解，直到匹配输入的终结符；自底向上是不断地将终结符进行合并，直到合并成起始的非终结符。</p>
<p>其中的自顶向下方法就是我们所说的递归下降。</p>
<h2 id="终结符与非终结符"><a class="header-anchor" href="#终结符与非终结符"></a>终结符与非终结符</h2>
<p>没有学过编译原理的话可能并不知道什么是“终结符”，“非终结符”。这里我简单介绍一下。首先是 <a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">BNF</a> 范式，就是一种用来描述语法的语言，例如，四则运算的规则可以表示如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;</span><br><span class="line">         | &lt;expr&gt; - &lt;term&gt;</span><br><span class="line">         | &lt;term&gt;</span><br><span class="line"></span><br><span class="line">&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;</span><br><span class="line">         | &lt;term&gt; / &lt;factor&gt;</span><br><span class="line">         | &lt;factor&gt;</span><br><span class="line"></span><br><span class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</span><br><span class="line">           | Num</span><br></pre></td></tr></table></figure></div>
<p>用尖括号 <code>&lt;&gt;</code> 括起来的就称作 <strong>非终结符</strong> ，因为它们可以用 <code>::=</code> 右侧的式子代替。<code>|</code> 表示选择，如 <code>&lt;expr&gt;</code> 可以是 <code>&lt;expr&gt; + &lt;term&gt;</code>、<code>&lt;expr&gt; - &lt;term&gt;</code>或
<code>&lt;term&gt;</code> 中的一种。而没有出现在<code>::=</code>左边的就称作 <strong>终结符</strong> ，一般终结符对应于词法分析器输出的标记。</p>
<h2 id="四则运算的递归下降"><a class="header-anchor" href="#四则运算的递归下降"></a>四则运算的递归下降</h2>
<p>例如，我们对 <code>3 * (4 + 2)</code> 进行语法分析。我们假设词法分析器已经正确地将其中的数字识别成了标记 <code>Num</code>。</p>
<p>递归下降是从起始的非终结符开始（顶），本例中是 <code>&lt;expr&gt;</code>，实际中可以自己指定，不指定的话一般认为是第一个出现的非终结符。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. &lt;expr&gt; =&gt; &lt;expr&gt;</span><br><span class="line">2.           =&gt; &lt;term&gt;        * &lt;factor&gt;</span><br><span class="line">3.              =&gt; &lt;factor&gt;     |</span><br><span class="line">4.                 =&gt; Num (3)   |</span><br><span class="line">5.                              =&gt; ( &lt;expr&gt; )</span><br><span class="line">6.                                   =&gt; &lt;expr&gt;           + &lt;term&gt;</span><br><span class="line">7.                                      =&gt; &lt;term&gt;          |</span><br><span class="line">8.                                         =&gt; &lt;factor&gt;     |</span><br><span class="line">9.                                            =&gt; Num (4)   |</span><br><span class="line">10.                                                        =&gt; &lt;factor&gt;</span><br><span class="line">11.                                                           =&gt; Num (2)</span><br></pre></td></tr></table></figure></div>
<p>可以看到，整个解析的过程是在不断对非终结符进行替换（向下），直到遇见了终结符（底）。而我们可以从解析的过程中看出，一些非终结符如<code>&lt;expr&gt;</code>被递归地使用了。</p>
<h2 id="为什么选择递归下降"><a class="header-anchor" href="#为什么选择递归下降"></a>为什么选择递归下降</h2>
<p>从上小节对四则运算的递归下降解析可以看出，整个解析的过程和语法的 BNF 表示是十分接近的，更为重要的是，我们可以很容易地直接将 BNF 表示转换成实际的代码。方法是为每个产生式（即 <code>非终结符 ::= ...</code>）生成一个同名的函数。</p>
<p>这里会有一个疑问，就是上例中，当一个终结符有多个选择时，如何确定具体选择哪一个？如为什么用 <code>&lt;expr&gt; ::= &lt;term&gt; * &lt;factor&gt;</code> 而不是 <code>&lt;expr&gt; ::= &lt;term&gt; / &lt;factor&gt;</code>
？这就用到了上一章中提到的“向前看 k 个标记”的概念了。我们向前看一个标记，发现是 <code>*</code>，而这个标记足够让我们确定用哪个表达式了。</p>
<p>另外，递归下下降方法对 BNF 方法本身有一定的要求，否则会有一些问题，如经典的“左递归”问题。</p>
<h2 id="左递归"><a class="header-anchor" href="#左递归"></a>左递归</h2>
<p>原则上我们是不讲这么深入，但我们上面的四则运算的文法就是左递归的，而左递归的语法是没法直接使用递归下降的方法实现的。因此我们要消除左递归，消除后的文法如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;term&gt; &lt;expr_tail&gt;</span><br><span class="line">&lt;expr_tail&gt; ::= + &lt;term&gt; &lt;expr_tail&gt;</span><br><span class="line">              | - &lt;term&gt; &lt;expr_tail&gt;</span><br><span class="line">              | &lt;empty&gt;</span><br><span class="line"></span><br><span class="line">&lt;term&gt; ::= &lt;factor&gt; &lt;term_tail&gt;</span><br><span class="line">&lt;term_tail&gt; ::= * &lt;factor&gt; &lt;term_tail&gt;</span><br><span class="line">              | / &lt;factor&gt; &lt;term_tail&gt;</span><br><span class="line">              | &lt;empty&gt;</span><br><span class="line"></span><br><span class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</span><br><span class="line">           | Num</span><br></pre></td></tr></table></figure></div>
<p>消除左递归的相关方法，这里不再多说，请自行查阅相关的资料。</p>
<h2 id="四则运算的实现"><a class="header-anchor" href="#四则运算的实现"></a>四则运算的实现</h2>
<p>本节中我们专注语法分析器部分的实现，具体实现很容易，我们直接贴上代码，就是上述的消除左递归后的文法直接转换而来的：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expr</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">factor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        value = expr();</span><br><span class="line">        match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = token_val;</span><br><span class="line">        match(Num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">term_tail</span><span class="params">(<span class="type">int</span> lvalue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        match(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue * factor();</span><br><span class="line">        <span class="keyword">return</span> term_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        match(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue / factor();</span><br><span class="line">        <span class="keyword">return</span> term_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lvalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">term</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lvalue = factor();</span><br><span class="line">    <span class="keyword">return</span> term_tail(lvalue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">expr_tail</span><span class="params">(<span class="type">int</span> lvalue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        match(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue + term();</span><br><span class="line">        <span class="keyword">return</span> expr_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        match(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue - term();</span><br><span class="line">        <span class="keyword">return</span> expr_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lvalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> lvalue = term();</span><br><span class="line">    <span class="keyword">return</span> expr_tail(lvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，有了BNF方法后，采用递归向下的方法来实现编译器是很直观的。</p>
<p>我们把词法分析器的代码一并贴上：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>Num&#125;;</span><br><span class="line"><span class="type">int</span> token;</span><br><span class="line"><span class="type">int</span> token_val;</span><br><span class="line"><span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// skip white space</span></span><br><span class="line">    <span class="keyword">while</span> (*src == <span class="string">&#x27; &#x27;</span> || *src == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">        src ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token = *src++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; token &lt;= <span class="string">&#x27;9&#x27;</span> ) &#123;</span><br><span class="line">        token_val = token - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        token = Num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*src &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *src &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            token_val = token_val*<span class="number">10</span> + *src - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            src ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span> tk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token != tk) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;expected token: %d(%c), got: %d(%c)\n&quot;</span>, tk, tk, token, token);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>最后是<code>main</code>函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> linecap = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> linelen;</span><br><span class="line">    <span class="keyword">while</span> ((linelen = getline(&amp;line, &amp;linecap, <span class="built_in">stdin</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        src = line;</span><br><span class="line">        next();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, expr());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>本章中我们介绍了递归下降的方法，并用它来实现了四则运算的语法分析器。</p>
<p>花这么大精力讲解递归下降方法，是因为几乎所有手工编写的语法分析器都或多或少地有它的影子。换句话说，掌握了递归下降的方法，就可以应付大多数的语法分析器编写。</p>
<p>同时我们也用实例看到了理论（BNF 语法，左递归的消除）是如何帮助我们的工程实现的。尽管理论不是必需的，但如果能掌握它，对于提高我们的水平还是很有帮助的。</p>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>