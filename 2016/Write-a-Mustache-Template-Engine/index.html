<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="前几天在伯乐在线上看到 &lt;a href=&quot;http://web.jobbole.com/84906/&quot;&gt;介绍 mustache.js 的文章&lt;/a&gt;。&lt;a href=&quot;http://mustache.github.io/&quot;&gt;Mustache&lt;/a&gt; 是一种模板语言，语法简单，功能强大，已经有各个语言下的实现。那么我们今天就用
python 来一步步实现它吧！"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>写一个 Mustache 模板引擎 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/mustache/" rel="tag">mustache</a><a class="post-tag-noise-link" href="/tags/template-engine/" rel="tag">template engine</a></div><div class="post-time">2016-01-23</div></div></div><div class="container post-header"><h1>写一个 Mustache 模板引擎</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mustache-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">Mustache 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">模板引擎的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">辅助函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9F%A5%E6%89%BE"><span class="toc-number">4.1.</span> <span class="toc-text">上下文查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%8B%AC%E8%A1%8C%E5%88%A4%E5%AE%9A"><span class="toc-number">4.2.</span> <span class="toc-text">单独行判定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">语法树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">辅助渲染函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">6.3.</span> <span class="toc-text">子节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.4.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section"><span class="toc-number">6.5.</span> <span class="toc-text">Section</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inverted"><span class="toc-number">6.6.</span> <span class="toc-text">Inverted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">6.7.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial"><span class="toc-number">6.8.</span> <span class="toc-text">Partial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%8F%E7%BB%93"><span class="toc-number">6.9.</span> <span class="toc-text">虚拟机小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">词法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%9A%94%E7%AC%A6%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">8.1.</span> <span class="toc-text">分隔符的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-v2"><span class="toc-number">8.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-v2"><span class="toc-number">8.3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial-v2"><span class="toc-number">8.4.</span> <span class="toc-text">Partial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-inverted"><span class="toc-number">8.5.</span> <span class="toc-text">Section &amp; Inverted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E6%A0%87%E7%AD%BE"><span class="toc-number">8.6.</span> <span class="toc-text">结束标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93"><span class="toc-number">8.7.</span> <span class="toc-text">语法分析小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">9.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><p>前几天在伯乐在线上看到 <a href="http://web.jobbole.com/84906/">介绍 mustache.js 的文章</a>。<a href="http://mustache.github.io/">Mustache</a> 是一种模板语言，语法简单，功能强大，已经有各个语言下的实现。那么我们今天就用
python 来一步步实现它吧！</p>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<blockquote><p>What I cannot create I do not understand.</p>
<footer><strong>Richard Feynman</strong></footer></blockquote>
<p>要理解一个事物最有效的方式就是动手创造一个，而真正动手创造的时候，你会发现，事情并没有相像中的困难。</p>
<p>首先要说说什么是编译器，它就像是一个翻译，将一种语言 X 翻译成另一种语言 Y。通常语言 X 对人类更加友好，而语言 Y 则是我们不想直接使用的。以 C 语言编译器为例，它的输出是汇编语言，汇编语言太琐碎了，通常我们不想直接用它来写程序。而相对而言，C 语言就容易理解、容易编写。</p>
<p>但是翻译后的语言 Y 也需要实际去执行，在 C 语言的例子中，它是直接由硬件去执行的，以此得到我们需要的结果。另一些情形下，我们需要做一台“虚拟机”来执行。例如
Java 的编译器将 Java 代码转换成 Java 字节码，硬件（CPU）本身并不认识字节码，所以 Java 提供了 Java 虚拟机来实际执行它。</p>
<blockquote>
<p>模板引擎 = 编译器 + 虚拟机</p>
</blockquote>
<p>本质上，模板引擎的工作就是将模板转换成一个内部的结构，可以是抽象语法树（AST），也可以是 python 代码，等等。同时还需要是一个虚拟机，能够理解这种内部结构，给出我们需要的结果。</p>
<p>好吧，那么模板引擎够复杂啊！不仅要写个编译器，还要写个虚拟机！放弃啦，不干啦！莫慌，容我慢慢道来～</p>
<h2 id="mustache-简介"><a class="header-anchor" href="#mustache-简介"></a>Mustache 简介</h2>
<p><a href="https://mustache.github.io/mustache.5.html">Mustache</a> 自称为 logic-less，与一般模板不同，它不包含 <code>if</code>, <code>for</code> 这样的逻辑标签，而统一用 {{#prop}} 之类的标签解决。下面是一个 Mustache 模板：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello &#123;&#123;name&#125;&#125;</span><br><span class="line">You have just won &#123;&#123;value&#125;&#125; dollars!</span><br><span class="line">&#123;&#123;#in_ca&#125;&#125;</span><br><span class="line">Well, &#123;&#123;taxed_value&#125;&#125; dollars, after taxes.</span><br><span class="line">&#123;&#123;/in_ca&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>对于如下的数据，JSON 格式的数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Chris&quot;,</span><br><span class="line">  &quot;value&quot;: 10000,</span><br><span class="line">  &quot;taxed_value&quot;: 10000 - (10000 * 0.4),</span><br><span class="line">  &quot;in_ca&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将输出如下的文本：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello Chris</span><br><span class="line">You have just won 10000 dollars!</span><br><span class="line">Well, 6000.0 dollars, after taxes.</span><br></pre></td></tr></table></figure></div>
<p>所以这里稍微总结一下 Mustache 的标签：</p>
<ul>
<li>
{{ name }}: 获取数据中的 `name` 替换当前文本
</li>
<li>
{{# name }} ... {{/name}}: 获取数据中的 `name` 字段并依据数据的类型，执行如下操作：
<ul>
<li>若 <code>name</code> 为假，跳过当前块，即相当于 <code>if</code> 操作</li>
<li>若 <code>name</code> 为真，则将 <code>name</code> 的值加入上下文并解析块中的文本</li>
<li>若 <code>name</code> 是数组且个数大于 0，则逐个迭代其中的数据，相当于 <code>for</code></li>
</ul>
</li>
</ul>
<p>逻辑简单，易于理解。下面就让我们来实现它吧！</p>
<h2 id="模板引擎的结构"><a class="header-anchor" href="#模板引擎的结构"></a>模板引擎的结构</h2>
<p>如前文所述，我们实现的模板引擎需要包括一个编译器，以及一个虚拟机，我们选择抽象语法树作为中间表示。下图是一个图示：</p>
<img src="/2016/Write-a-Mustache-Template-Engine/template-engine-structure.png" class="" title="Template Engine Structure">
<p>学过编译原理的话，你可能知道编译器包括了词法分析器、语法分析器及目标代码的生成。但是我们不会单独实现它们，而是一起实现原因有两个：</p>
<ol>
<li>模板引擎的语法通常要简单一些，Mustache 的语法比其它引擎比起来更是如此。</li>
<li>Mustache 支持动态修改分隔符，因此词法的分析和语法的分析必需同时进行。</li>
</ol>
<p>下面开始 Coding 吧！</p>
<h2 id="辅助函数"><a class="header-anchor" href="#辅助函数"></a>辅助函数</h2>
<h3 id="上下文查找"><a class="header-anchor" href="#上下文查找"></a>上下文查找</h3>
<p>首先，Mustache 有所谓上下文栈（context stack）的概念，每进入一个</p>
{{#name}}...{{/name}} 块，就增加一层栈，下面是一个图示：
<img src="/2016/Write-a-Mustache-Template-Engine/context-stack.png" class="" title="Context Stack">
<p>这个概念和 Javscript 中的原型链是一样的。只是 Python 中并没有相关的支持，因此我们实现自己的查找函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lookup</span>(<span class="params">var_name, contexts=(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="keyword">for</span> context <span class="keyword">in</span> <span class="built_in">reversed</span>(contexts):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> var_name <span class="keyword">in</span> context:</span><br><span class="line">                <span class="keyword">return</span> context[var_name]</span><br><span class="line">        <span class="keyword">except</span> TypeError <span class="keyword">as</span> te:</span><br><span class="line">            <span class="comment"># we may put variable on the context, skip it</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>
<p>如上，每个上下文（context）可以是一个字典，也可以是数据元素（像字符串，数字等等），而上下文栈则是一个数组，<code>contexts[0]</code> 代表栈底，<code>context[-1]</code> 代表栈顶。其余的逻辑就很明直观了。</p>
<h3 id="单独行判定"><a class="header-anchor" href="#单独行判定"></a>单独行判定</h3>
<p>Mustache 中有“单独行”（standalone）的概念，即如果一个标签所在的行，除了该标签外只有空白字符，则称为单独行。判断函数如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spaces_not_newline = <span class="string">&#x27; \t\r\b\f&#x27;</span></span><br><span class="line">re_space = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[&#x27;</span> + spaces_not_newline + <span class="string">r&#x27;]*(\n|$)&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_standalone</span>(<span class="params">text, start, end</span>):</span><br><span class="line">    left = <span class="literal">False</span></span><br><span class="line">    start -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &gt;= <span class="number">0</span> <span class="keyword">and</span> text[start] <span class="keyword">in</span> spaces_not_newline:</span><br><span class="line">        start -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start &lt; <span class="number">0</span> <span class="keyword">or</span> text[start] == <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    right = re_space.<span class="keyword">match</span>(text, end)</span><br><span class="line">    <span class="keyword">return</span> (start+<span class="number">1</span>, right.end()) <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>
<p>其中，<code>(start, end)</code> 是当前标签的开始和结束位置。我们分别向前和向后匹配空白字符。向前是一个个字符地判断，向后则偷懒用了正则表达式。右是单独行则返回单独行的位置：<code>(start+1, right.end())</code>。</p>
<img src="/2016/Write-a-Mustache-Template-Engine/standalone.png" class="" title="Standalone Line">
<h2 id="语法树"><a class="header-anchor" href="#语法树"></a>语法树</h2>
<p>我们从语法树讲起，因为这是编译器的输出，先弄清输出的结构，我们能更好地理解编译器的工作原理。</p>
<p>首先介绍树的节点的类型。因为语法树和 Mustache 的语法对应，所以节点的类型和
Mustache 支持的语法类型对应：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;The node of a parse tree&quot;&quot;&quot;</span></span><br><span class="line">    LITERAL   = <span class="number">0</span></span><br><span class="line">    VARIABLE  = <span class="number">1</span></span><br><span class="line">    SECTION   = <span class="number">2</span></span><br><span class="line">    INVERTED  = <span class="number">3</span></span><br><span class="line">    COMMENT   = <span class="number">4</span></span><br><span class="line">    PARTIAL   = <span class="number">5</span></span><br><span class="line">    ROOT      = <span class="number">6</span></span><br></pre></td></tr></table></figure></div>
<p>这 6 种类型中除了 <code>ROOT</code>，其余都对应了 Mustache 的一种类型，对应关系如下：</p>
<ul>
<li><code>LITERAL</code>：纯文本，即最终按原样输出的部分</li>
<li><code>VARIABLE</code>：变量字段，即 {{ name }} 类型</li>
<li><code>SECTION</code>：对应 {{#name}} ... {{/name}}</li>
<li><code>INVERTED</code>：对应 {{^name}} ... {{/name}}</li>
<li><code>COMMENT</code>：注释字段 {{! name }}</li>
<li><code>PARTIAL</code>：对应 {{> name}}</li>
</ul>
<p>而最后的 <code>ROOT</code> 则代表整棵语法树的根节点。</p>
<img src="/2016/Write-a-Mustache-Template-Engine/AST.png" class="" title="AST">
<p>了解了节点的类型，我们还需要知道每个节点需要保存什么样的信息，例如对于
<code>Section</code> 类型的节点，我们需要保存它对应的子节点，另外为了支持 <code>lambda</code> 类型的数据，我们还需要保存 <code>section</code> 段包含的文本。最终需要的字段如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">type</span>=LITERAL, value=<span class="literal">None</span>, text=<span class="string">&#x27;&#x27;</span>, children=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="variable language_">self</span>.name = name</span><br><span class="line">    <span class="variable language_">self</span>.<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">    <span class="variable language_">self</span>.value = value</span><br><span class="line">    <span class="variable language_">self</span>.text = text</span><br><span class="line">    <span class="variable language_">self</span>.children = children</span><br><span class="line">    <span class="variable language_">self</span>.escape = <span class="literal">False</span></span><br><span class="line">    <span class="variable language_">self</span>.delimiter = <span class="literal">None</span> <span class="comment"># used for section</span></span><br><span class="line">    <span class="variable language_">self</span>.indent = <span class="number">0</span> <span class="comment"># used for partial</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>name</code> ：保存该节点的名字，例如 {{ header }} 是变量类型，<code>name</code> 字段保存的就是 <code>header</code> 这个名字。</li>
<li><code>type</code>：保存前文介绍的节点的类型</li>
<li><code>value</code>：保存该节点的值，不同类型的节点保存的内容也不同，例如 <code>LITERAL</code> 类型保存的是字符串本身，而 <code>VARIABLE</code> 保存的是变量的名称，和 <code>name</code> 雷同。</li>
<li><code>text</code> ：只对 <code>SECTION</code> 和 <code>INVERTED</code> 有用，即保存包含的文本</li>
<li><code>children</code>：<code>SECTION</code>、<code>INVERTED</code>及<code>ROOT</code>类型使用，保存子节点</li>
<li><code>escape</code>：输出是否要转义，例如 {{name}} 是默认转义的，而{{{name}}}默认不转义</li>
<li><code>delimiter</code>：与 <code>lambda</code> 的支持有关。Mustache 要求，若 <code>SECTION</code> 的变量是一个函数，则先调用该函数，返回时的文本用当前的分隔符解释，但在编译期间这些文本是不可获取的，因此需要事先存储。</li>
<li><code>indent</code> 是 <code>PARTIAL</code> 类型使用，后面会提到。</li>
</ul>
<p>可以看到，语法树的类型、结构和 Mustache 的语法息息相关，因此，要理解它的最好方式就是看 <a href="https://github.com/mustache/spec">Mustache 的标准</a>。 一开始写这个引擎时并不知道需要这么多的字段，在阅读标准时，随着对 Mustache 语法的理解而慢慢添加的。</p>
<h2 id="虚拟机"><a class="header-anchor" href="#虚拟机"></a>虚拟机</h2>
<p>所谓的虚拟机就是对编译器输出（我们的例子中是语法树）的解析，即给定语法树和数据，我们能正确地输出文本。首先我们为 Token 类定义一个调度函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>():</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">render</span>(<span class="params">self, contexts, partials=&#123;&#125;</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(contexts, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)): <span class="comment"># ①</span></span><br><span class="line">            contexts = [contexts]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ②</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="variable language_">self</span>.LITERAL:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._render_literal(contexts, partials)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="variable language_">self</span>.VARIABLE:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._render_variable(contexts, partials)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="variable language_">self</span>.SECTION:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._render_section(contexts, partials)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="variable language_">self</span>.INVERTED:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._render_inverted(contexts, partials)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="variable language_">self</span>.COMMENT:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._render_comments(contexts, partials)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="variable language_">self</span>.PARTIAL:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._render_partials(contexts, partials)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="variable language_">self</span>.ROOT:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._render_children(contexts, partials)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Invalid Token Type&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>①：我们要求上下文栈（context stack）是一个列表（或称数组），为了方便用户，我们允许它是其它类型的。</p>
<p>②的逻辑很简单，就是根据当前节点的类型执行不同的函数用来渲染（render）文本。</p>
<p>另外每个“渲染函数”都有两个参数，即上下文栈<code>contexts</code> 和 <code>partials</code>。
<code>partials</code>是一个字典类型。它的作用是当我们在模板中遇见如 {{> part}} 的标签中，就从 <code>partials</code> 中查找 <code>part</code>，并用得到的文本替换当前的标签。具体的使用方法可以参考 <a href="http://mustache.github.io/mustache.5.html#Partials">Mustache 文档</a></p>
<h3 id="辅助渲染函数"><a class="header-anchor" href="#辅助渲染函数"></a>辅助渲染函数</h3>
<p>它们是其它“子渲染函数”会用到的一些函数，首先是转义函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> html <span class="keyword">import</span> escape <span class="keyword">as</span> html_escape</span><br><span class="line">EMPTYSTRING = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>():</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_escape</span>(<span class="params">self, text</span>):</span><br><span class="line">        ret = EMPTYSTRING <span class="keyword">if</span> <span class="keyword">not</span> text <span class="keyword">else</span> <span class="built_in">str</span>(text)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.escape:</span><br><span class="line">            <span class="keyword">return</span> html_escape(ret)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></div>
<p>作用是如果当前节点需要转义，则调用 <code>html_escape</code> 进行转义，例如将文本 <code>&lt;b&gt;</code>
转义成 <code>&amp;lt;b&amp;gt;</code>。</p>
<p>另一个函数是查找（lookup），在给定的上下文栈中查找对应的变量。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>():</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_lookup</span>(<span class="params">self, dot_name, contexts</span>):</span><br><span class="line">        <span class="keyword">if</span> dot_name == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            value = contexts[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            names = dot_name.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            value = lookup(names[<span class="number">0</span>], contexts)</span><br><span class="line">            <span class="comment"># support &#123;&#123;a.b.c.d.e&#125;&#125; like lookup</span></span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    value = value[name]</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="comment"># not found</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></div>
<p>这里有两点特殊的地方：</p>
<ol>
<li>若变量名为 <code>.</code>，则返回当前上下文栈中栈顶的变量。这是 Mustache 的特殊语法。</li>
<li>支持诸如以 <code>.</code> 号为分隔符的层级访问，如 {{a.b.c}} 代表首先查找变量 <code>a</code>，在 <code>a</code> 的值中查找变量 <code>b</code>，以此类推。</li>
</ol>
<h3 id="字面量"><a class="header-anchor" href="#字面量"></a>字面量</h3>
<p>即 <code>LITERAL</code> 类型的节点，在渲染时直接输出节点保存的字符串即可：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_render_literal</span>(<span class="params">self, contexts, partials</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.value</span><br></pre></td></tr></table></figure></div>
<h3 id="子节点"><a class="header-anchor" href="#子节点"></a>子节点</h3>
<p>子节点的渲染其实很简单，因为语法树是树状的结构，所以只要递归调用子节点的渲染函数就可以了，代码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_render_children</span>(<span class="params">self, contexts, partials</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> <span class="variable language_">self</span>.children:</span><br><span class="line">        ret.append(child.render(contexts, partials))</span><br><span class="line">    <span class="keyword">return</span> EMPTYSTRING.join(ret)</span><br></pre></td></tr></table></figure></div>
<h3 id="变量"><a class="header-anchor" href="#变量"></a>变量</h3>
<p>即遇到诸如 {{name}}、{{{name}}} 或 {{&name}} 等的标签时，从上下文栈中查找相应的值即可：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_render_variable</span>(<span class="params">self, contexts, partials</span>):</span><br><span class="line">    value = <span class="variable language_">self</span>._lookup(<span class="variable language_">self</span>.value, contexts)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lambda</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>(value):</span><br><span class="line">        value = render(<span class="built_in">str</span>(value()), contexts, partials)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._escape(value)</span><br></pre></td></tr></table></figure></div>
<p>这里的唯一不同是对 <code>lambda</code> 的支持，如果变量的值是一个可执行的函数，则需要先执行它，将返回的结果作为新的文本，重新渲染。这里的 <code>render</code> 函数后面会介绍。</p>
<p>例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contexts = [&#123; &#x27;lambda&#x27;: lambda : &#x27;&#123;&#123;value&#125;&#125;&#x27;, &#x27;value&#x27;: &#x27;world&#x27; &#125;]</span><br><span class="line"></span><br><span class="line">&#x27;hello &#123;&#123;lambda&#125;&#125;&#x27; =&gt; &#x27;hello &#123;&#123;value&#125;&#125;&#x27; =&gt; &#x27;hello world&#x27;</span><br></pre></td></tr></table></figure></div>
<h3 id="section"><a class="header-anchor" href="#section"></a>Section</h3>
<p>Section 的渲染是最为复杂的一个，因为我们需要根据查找后的数据的类型做不同的处理。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_render_section</span>(<span class="params">self, contexts, partials</span>):</span><br><span class="line">    val = <span class="variable language_">self</span>._lookup(<span class="variable language_">self</span>.value, contexts)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val:</span><br><span class="line">        <span class="comment"># false value</span></span><br><span class="line">        <span class="keyword">return</span> EMPTYSTRING</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(val, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(val) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># empty lists</span></span><br><span class="line">            <span class="keyword">return</span> EMPTYSTRING</span><br><span class="line"></span><br><span class="line">        <span class="comment"># non-empty lists</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> val: <span class="comment">#①</span></span><br><span class="line">            contexts.append(item)</span><br><span class="line">            ret.append(<span class="variable language_">self</span>._render_children(contexts, partials))</span><br><span class="line">            contexts.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._escape(<span class="string">&#x27;&#x27;</span>.join(ret))</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">callable</span>(val): <span class="comment">#②</span></span><br><span class="line">        <span class="comment"># lambdas</span></span><br><span class="line">        new_template = val(<span class="variable language_">self</span>.text)</span><br><span class="line">        value = render(new_template, contexts, partials, <span class="variable language_">self</span>.delimiter)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># context ③</span></span><br><span class="line">        contexts.append(val)</span><br><span class="line">        value = <span class="variable language_">self</span>._render_children(contexts, partials)</span><br><span class="line">        contexts.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._escape(value)</span><br></pre></td></tr></table></figure></div>
<p>①：当数据的类型是列表时，我们逐个迭代，将元素入栈并渲染它的子节点。</p>
<p>②：当数据的类型是函数时，与处理变量时不同，Mustache 要求我们将 Section 中包含的文本作为参数，调用该函数，再对该函数返回的结果作为新的模板进行渲染。且要求使用当前的分隔符。</p>
<p>③：正常情况下，我们需要渲染 Section 包含的子节点。注意 <code>self.text</code> 与
<code>self.children</code> 的区别，前者是文本字符串，后者是编译后的语法树节点。</p>
<h3 id="inverted"><a class="header-anchor" href="#inverted"></a>Inverted</h3>
<p>Inverted Section 起到的作用是 <code>if not</code>，即只有当数据为假时才渲染它的子节点。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_render_inverted</span>(<span class="params">self, contexts, partials</span>):</span><br><span class="line">    val = <span class="variable language_">self</span>._lookup(<span class="variable language_">self</span>.value, contexts)</span><br><span class="line">    <span class="keyword">if</span> val:</span><br><span class="line">        <span class="keyword">return</span> EMPTYSTRING</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._render_children(contexts, partials)</span><br></pre></td></tr></table></figure></div>
<h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3>
<p>直接跳过该子节点即可：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_render_comments</span>(<span class="params">self, contexts, partials</span>):</span><br><span class="line">    <span class="keyword">return</span> EMPTYSTRING</span><br></pre></td></tr></table></figure></div>
<h3 id="partial"><a class="header-anchor" href="#partial"></a>Partial</h3>
<p>Partial 的作用相当于预先存储的模板。与其它模板语言的 <code>include</code> 类似，但还可以递归调用。例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">partials: &#123;&#x27;strong&#x27;: &#x27;&lt;strong&gt;&#123;&#123;name&#125;&#125;&lt;/strong&gt;&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&#x27;hello &#123;&#123;&gt; strong&#125;&#125;&#x27; =&gt; &#x27;hello &lt;strong&gt;&#123;&#123;name&#125;&#125;&lt;/strong&gt;&#x27;</span><br></pre></td></tr></table></figure></div>
<p>代码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_insert_indent = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(^|\n)(?=.|\n)&#x27;</span>, re.DOTALL) <span class="comment">#①</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>():</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_render_partials</span>(<span class="params">self, contexts, partials</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            partial = partials[<span class="variable language_">self</span>.value]</span><br><span class="line">        <span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._escape(EMPTYSTRING)</span><br><span class="line"></span><br><span class="line">        partial = re_insert_indent.sub(<span class="string">r&#x27;\1&#x27;</span> + <span class="string">&#x27; &#x27;</span>*<span class="variable language_">self</span>.indent, partial) <span class="comment">#②</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render(partial, contexts, partials, <span class="variable language_">self</span>.delimiter)</span><br></pre></td></tr></table></figure></div>
<p>这里唯一值得一提的就是缩进问题②。Mustache 规定，如果一个 partial 标签是一个“单独行”，则需要将该标签的缩进添加到数据的所有行，然后再进行渲染。例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">partials: &#123;&#x27;content&#x27;: &#x27;&lt;li&gt;\n &#123;&#123;name&#125;&#125;\n&lt;/li&gt;\n&#x27;&#125;</span><br><span class="line"></span><br><span class="line">|                           |&lt;ul&gt;</span><br><span class="line">|&lt;ul&gt;                       |    &lt;li&gt;</span><br><span class="line">|    &#123;&#123;&gt; content&#125;&#125;   =&gt;     |     &#123;&#123;name&#125;&#125;</span><br><span class="line">|&lt;/ul&gt;                      |    &lt;/li&gt;</span><br><span class="line">|                           |&lt;/ul&gt;</span><br></pre></td></tr></table></figure></div>
<p>因此我们用正则表达式对 partial 的数据进行处理。①中的正则表达式，<code>(^|\n)</code> 用于匹配文本的开始，或换行符之后。而由于我们不匹配最后一个换行符，所以我们用了
<code>(?=.|\n)</code>。它要求，以任意字符结尾，而由于 <code>.</code> 并不匹配换行符 <code>\n</code>，因此用了或操作(<code>|</code>)。</p>
<h3 id="虚拟机小结"><a class="header-anchor" href="#虚拟机小结"></a>虚拟机小结</h3>
<p>综上，我们就完成了执行语法树的虚拟机。是不是还挺简单的。的确，一旦决定好了数据结构，其它的实现似乎也只是按部就班。</p>
<p>最后额外指出一个问题，那就是编译器与解释器的问题。传统上，解释器是指一句一句读取源代码并执行；而编译器是读取全部源码并编译，生成目标代码后一次性去执行。</p>
<p>在我们的模板引擎中，语法树是属于编译得到的结果，因为模板是固定的，因此能得到一个固定的语法树，语法树可以重复执行，这也有利于提高效率。但由于 Mustache 支持
partial 及 lambda，这些机制使得用户能动态地为模板添加新的内容，所以固定的语法树是不够的，因此我们在渲染时用到了全局 <code>render</code> 函数。它的作用就相当于解释器，让我们能动态地渲染模板（本质上依旧是编译成语法树再执行）。</p>
<p>有了这个虚拟机（带执行功能的语法树），我们就能正常渲染模板了，那么接下来就是如何把模板编译成语法树了。</p>
<h2 id="词法分析"><a class="header-anchor" href="#词法分析"></a>词法分析</h2>
<p>Mustache 的词法较为简单，并且要求能动态改变分隔符，所以我们用正则表达式来一个个匹配。</p>
<p>Mustache 标签由左右分隔符包围，默认的左右分隔符分别是 <code>&#123; &#123;</code>（忽略中间的空格） 和 <code>&#125;&#125;</code>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DEFAULT_DELIMITERS = (<span class="string">&#x27;&#123;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>而标签的模式是：左分隔符 + 类型字符 + 标签名 + （可选字符）+ 右分隔符，例如：</p>
{{# name}} 和 {{{name}}}。其中 `#` 就代表类型，{{{name}}} 中的`}` 就是可选的字符。
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_tag = re.<span class="built_in">compile</span>(open_tag + <span class="string">r&#x27;([#^&gt;&amp;&#123;/!=]?)\s*(.*?)\s*([&#125;=]?)&#x27;</span> + close_tag, re.DOTALL)</span><br></pre></td></tr></table></figure></div>
<p>例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [6]: re_tag = re.compile(r&#x27;&#123;&#123;([#^&gt;&amp;&#123;/!=]?)\s*(.*?)\s*([&#125;=]?)&#125;&#125;&#x27;, re.DOTALL)</span><br><span class="line"></span><br><span class="line">In [7]: re_tag.search(&#x27;before &#123;&#123;# name &#125;&#125; after&#x27;).groups()</span><br><span class="line">Out[7]: (&#x27;#&#x27;, &#x27;name&#x27;, &#x27;&#x27;)</span><br></pre></td></tr></table></figure></div>
<p>这样通过这个正则表达式就能得到我们需要的类型和标签名信息了。</p>
<p>只是，由于 Mustache 支持修改分隔符，而正则表达式的 compile 过程也是挺花时间的，因此我们要做一些缓存的操作来提高效率。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_delimiters = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delimiters_to_re</span>(<span class="params">delimiters</span>):</span><br><span class="line">    <span class="comment"># caching</span></span><br><span class="line">    delimiters = <span class="built_in">tuple</span>(delimiters)</span><br><span class="line">    <span class="keyword">if</span> delimiters <span class="keyword">in</span> re_delimiters:</span><br><span class="line">        re_tag = re_delimiters[delimiters]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        open_tag, close_tag = delimiters</span><br><span class="line"></span><br><span class="line">        <span class="comment"># escape ①</span></span><br><span class="line">        open_tag = <span class="string">&#x27;&#x27;</span>.join([c <span class="keyword">if</span> c.isalnum() <span class="keyword">else</span> <span class="string">&#x27;\\&#x27;</span> + c <span class="keyword">for</span> c <span class="keyword">in</span> open_tag])</span><br><span class="line">        close_tag = <span class="string">&#x27;&#x27;</span>.join([c <span class="keyword">if</span> c.isalnum() <span class="keyword">else</span> <span class="string">&#x27;\\&#x27;</span> + c <span class="keyword">for</span> c <span class="keyword">in</span> close_tag])</span><br><span class="line"></span><br><span class="line">        re_tag = re.<span class="built_in">compile</span>(open_tag + <span class="string">r&#x27;([#^&gt;&amp;&#123;/!=]?)\s*(.*?)\s*([&#125;=]?)&#x27;</span> + close_tag, re.DOTALL)</span><br><span class="line">        re_delimiters[delimiters] = re_tag</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re_tag</span><br></pre></td></tr></table></figure></div>
<p>①：这是比较神奇的一步，主要是有一些字符的组合在正则表达式里是有特殊含义的，为了避免它们影响了正则表达式，我们将除了字母和数字的字符进行转义，如 <code>'[' =&gt; '\['</code>。</p>
<h2 id="语法分析"><a class="header-anchor" href="#语法分析"></a>语法分析</h2>
<p>现在的任务是把模板转换成语法树，首先来看看整个转换的框架：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compiled</span>(<span class="params">template, delimiters=DEFAULT_DELIMITERS</span>):</span><br><span class="line">    re_tag = delimiters_to_re(delimiters)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># variable to save states ①</span></span><br><span class="line">    tokens = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    sections = []</span><br><span class="line">    tokens_stack = []</span><br><span class="line"></span><br><span class="line">    m = re_tag.search(template, index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        token = <span class="literal">None</span></span><br><span class="line">        last_literal = <span class="literal">None</span></span><br><span class="line">        strip_space = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m.start() &gt; index: <span class="comment">#②</span></span><br><span class="line">            last_literal = Token(<span class="string">&#x27;str&#x27;</span>, Token.LITERAL, template[index:m.start()])</span><br><span class="line">            tokens.append(last_literal)</span><br><span class="line"></span><br><span class="line">        prefix, name, suffix = m.groups()</span><br><span class="line">        <span class="comment"># &gt;&gt;&gt; <span class="doctag">TODO:</span> convert information to AST</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment">#③</span></span><br><span class="line">            tokens.append(token)</span><br><span class="line"></span><br><span class="line">        index = m.end()</span><br><span class="line">        <span class="keyword">if</span> strip_space: <span class="comment">#④</span></span><br><span class="line">            pos = is_standalone(template, m.start(), m.end())</span><br><span class="line">            <span class="keyword">if</span> pos:</span><br><span class="line">                index = pos[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> last_literal: last_literal.value = last_literal.value.rstrip(spaces_not_newline)</span><br><span class="line"></span><br><span class="line">        m = re_tag.search(template, index)</span><br><span class="line"></span><br><span class="line">    tokens.append(Token(<span class="string">&#x27;str&#x27;</span>, Token.LITERAL, template[index:]))</span><br><span class="line">    <span class="keyword">return</span> Token(<span class="string">&#x27;root&#x27;</span>, Token.ROOT, children=tokens)</span><br></pre></td></tr></table></figure></div>
<p>可以看到，整个步骤是由一个 while 循环构成，循环不断寻找下一个 Mustache 标签。这意味着我的解析是线性的，但我们的目标是生成树状结构，这怎么办呢？答案是①中，我们维护了两个栈，一个是 <code>sections</code>，另一个是 <code>tokens_stack</code>。至于怎么使用，下文会提到。</p>
<p>②：由于每次 while 循环时，我们跳过了中间那些不是标签的字面最，所以我们要将它们进行添加。这里将该节点保存在 <code>last_literal</code> 中是为了处理“单独行的情形”，详情见下文。</p>
<p>③：正常情况下，在循环末我们会将生成的节点（token）添加到 <code>tokens</code> 中，而有些情况下我们希望跳过这个逻辑，此时将 token 设置成 <code>None</code>。</p>
<p>④：<code>strip_space</code> 代表该标签需要考虑“单独行”的情形，此时做出相应的处理，一方面将上一个字面量节点的末尾空格消除，另一方面将 index 后移至换行符。</p>
<h3 id="分隔符的修改"><a class="header-anchor" href="#分隔符的修改"></a>分隔符的修改</h3>
<p>唯一要注意的是 Mustache 规定分隔符的修改是需要考虑“单独行”的情形的。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> prefix == <span class="string">&#x27;=&#x27;</span> <span class="keyword">and</span> suffix == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">    <span class="comment"># &#123;&#123;=| |=&#125;&#125; to change delimiters</span></span><br><span class="line">    delimiters = re.split(<span class="string">r&#x27;\s+&#x27;</span>, name)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(delimiters) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">&#x27;Invalid new delimiter definition: &#x27;</span> + m.group())</span><br><span class="line">    re_tag = delimiters_to_re(delimiters)</span><br><span class="line">    strip_space = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>
<h3 id="变量-v2"><a class="header-anchor" href="#变量-v2"></a>变量</h3>
<p>在解析变量时要考虑该变量是否需要转义，并做对应的设置。另外，末尾的可选字符
(suffix) 只能是 <code>&#125;</code> 或 <code>=</code>，分别都判断过了，所以此外的情形都是语法错误。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> prefix == <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">and</span> suffix == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">    <span class="comment"># &#123;&#123;&#123; variable &#125;&#125;&#125;</span></span><br><span class="line">    token = Token(name, Token.VARIABLE, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> prefix == <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> suffix == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    <span class="comment"># &#123;&#123; name &#125;&#125;</span></span><br><span class="line">    token = Token(name, Token.VARIABLE, name)</span><br><span class="line">    token.escape = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> suffix != <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> suffix != <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> SyntaxError(<span class="string">&#x27;Invalid token: &#x27;</span> + m.group())</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> prefix == <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">    <span class="comment"># &#123;&#123;&amp; escaped variable &#125;&#125;</span></span><br><span class="line">    token = Token(name, Token.VARIABLE, name)</span><br></pre></td></tr></table></figure></div>
<h3 id="注释-v2"><a class="header-anchor" href="#注释-v2"></a>注释</h3>
<p>注释是需要考虑“单独行”的。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> prefix == <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">    <span class="comment"># &#123;&#123;! comment &#125;&#125;</span></span><br><span class="line">    token = Token(name, Token.COMMENT)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sections) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># considered as standalone only outside sections</span></span><br><span class="line">        strip_space = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>
<h3 id="partial-v2"><a class="header-anchor" href="#partial-v2"></a>Partial</h3>
<p>一如既往，需要考虑“单独行”，不同的是还需要保存单独行的缩进。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> prefix == <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">    <span class="comment"># &#123;&#123;&gt; partial&#125;&#125;</span></span><br><span class="line">    token = Token(name, Token.PARTIAL, name)</span><br><span class="line">    strip_space = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    pos = is_standalone(template, m.start(), m.end())</span><br><span class="line">    <span class="keyword">if</span> pos:</span><br><span class="line">        token.indent = <span class="built_in">len</span>(template[pos[<span class="number">0</span>]:m.start()])</span><br></pre></td></tr></table></figure></div>
<h3 id="section-inverted"><a class="header-anchor" href="#section-inverted"></a>Section &amp; Inverted</h3>
<p>这是唯一需要使用到栈的两个标签，原理是选通过入栈记录这是 Section 或 Inverted
的开始标签，遇到结束标签时再出栈即可。</p>
<p>由于事先将 tokens 保存起来，因此遇到结束标签时，tokens 中保存的就是当前标签的所有子节点。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> prefix == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> prefix == <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">    <span class="comment"># &#123;&#123;# section &#125;&#125; or # &#123;&#123;^ inverted &#125;&#125;</span></span><br><span class="line">    token = Token(name, Token.SECTION <span class="keyword">if</span> prefix == <span class="string">&#x27;#&#x27;</span> <span class="keyword">else</span> Token.INVERTED, name)</span><br><span class="line">    token.delimiter = delimiters</span><br><span class="line">    tokens.append(token)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># save the tokens onto stack</span></span><br><span class="line">    token = <span class="literal">None</span></span><br><span class="line">    tokens_stack.append(tokens)</span><br><span class="line">    tokens = []</span><br><span class="line"></span><br><span class="line">    sections.append((name, prefix, m.end()))</span><br><span class="line">    strip_space = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>
<h3 id="结束标签"><a class="header-anchor" href="#结束标签"></a>结束标签</h3>
<p>当遇到结束标签时，我们需要进行对应的出栈操作。无它。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> prefix == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">    tag_name, sec_type, text_end = sections.pop()</span><br><span class="line">    <span class="keyword">if</span> tag_name != name:</span><br><span class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">&quot;unclosed tag: &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; Got:&quot;</span> + m.group())</span><br><span class="line"></span><br><span class="line">    children = tokens</span><br><span class="line">    tokens = tokens_stack.pop()</span><br><span class="line"></span><br><span class="line">    tokens[-<span class="number">1</span>].text = template[text_end:m.start()]</span><br><span class="line">    tokens[-<span class="number">1</span>].children = children</span><br><span class="line">    strip_space = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> SyntaxError(<span class="string">&#x27;Unknown tag: &#x27;</span> + m.group())</span><br></pre></td></tr></table></figure></div>
<h3 id="语法分析小结"><a class="header-anchor" href="#语法分析小结"></a>语法分析小结</h3>
<p>同样，语法分析的内容也是按部就班，也许最难的地方就在于构思这个 while 循环。所以要传下教：思考问题的时候要先把握整体的内容，即要自上而下地思考，实际编码的时候可以从两边同时进行。</p>
<h2 id="最后"><a class="header-anchor" href="#最后"></a>最后</h2>
<p>最后我们再实现 <code>render</code> 函数，用来实际执行模板的渲染。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyntaxError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">render</span>(<span class="params">template, contexts, partials=&#123;&#125;, delimiters=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(contexts, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">        contexts = [contexts]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(partials, <span class="built_in">dict</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;partials should be dict, but got &#x27;</span> + <span class="built_in">type</span>(partials))</span><br><span class="line"></span><br><span class="line">    delimiters = DEFAULT_DELIMITERS <span class="keyword">if</span> delimiters <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> delimiters</span><br><span class="line">    parent_token = compiled(template, delimiters)</span><br><span class="line">    <span class="keyword">return</span> parent_token.render(contexts, partials)</span><br></pre></td></tr></table></figure></div>
<p>这是一个使用我们模板引擎的例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; render(&#x27;Hellow &#123;&#123;name&#125;&#125;!&#x27;, &#123;&#x27;name&#x27;: &#x27;World&#x27;&#125;)</span><br><span class="line">&#x27;Hellow World!&#x27;</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>综上，我们完成了一个完整的 mustache 模板引擎，完整的代码可以在 <a href="https://github.com/lotabout/pymustache/blob/master/pymustache/mustache.py">Github: pymustache</a> 上下载。</p>
<p>实际测试了一下，我们的实现比 <a href="https://github.com/defunkt/pystache">pystache</a>
还更快，代码也更简单，去掉注释估计也就 300 行左右。</p>
<p>无论如何吧，我就想打个鸡血：如果真正去做了，有些事情并没有看起来那么难。如果本文能对你有所启发，那就是对我最大的鼓励。</p>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>