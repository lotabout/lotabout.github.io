<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="在学习 Rust 的过程中，错误处理是一个必需要迈过的坎。主要原因是所有的标准库都以统一的方式处理错误，我们就来谈一谈 Rust 中是如何处理错误的吧。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>简谈 Rust 中的错误处理 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/error-handling/" rel="tag">error-handling</a><a class="post-tag-noise-link" href="/tags/rust/" rel="tag">rust</a></div><div class="post-time">2017-01-07</div></div></div><div class="container post-header"><h1>简谈 Rust 中的错误处理</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">返回错误与异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#option"><span class="toc-number">2.</span> <span class="toc-text">Option</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#result-option-%E5%8A%A0%E5%BC%BA%E7%89%88"><span class="toc-number">3.</span> <span class="toc-text">Result: Option 加强版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92"><span class="toc-number">4.</span> <span class="toc-text">错误传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-%E5%AE%8F"><span class="toc-number">5.</span> <span class="toc-text">try! 宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-trait"><span class="toc-number">6.</span> <span class="toc-text">Error Trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#from-trait"><span class="toc-number">7.</span> <span class="toc-text">From trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">统一自定义错误类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">如何处理错误？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-number">11.</span> <span class="toc-text">Reference</span></a></li></ol></details></div><div class="container post-content"><p>在学习 Rust 的过程中，错误处理是一个必需要迈过的坎。主要原因是所有的标准库都以统一的方式处理错误，我们就来谈一谈 Rust 中是如何处理错误的吧。</p>
<p><a href="https://doc.rust-lang.org/book/error-handling.html">Rust Book</a> 对 rust 中的错误处理有详细的讲解，本文对其中一些选择背后的原因进行了思考和总结。强烈建议先看原文。</p>
<h2 id="返回错误与异常处理"><a class="header-anchor" href="#返回错误与异常处理"></a>返回错误与异常处理</h2>
<p>名正则言顺，我们先说说什么是“错误”，什么是“异常”：</p>
<ul>
<li><strong>错误</strong>：运行时发生的不寻常的、 <strong>超出预期</strong> 的行为，这些问题只能通过修改程序来解决。例如内存不足。</li>
<li><strong>异常</strong> ：运行时发生的不规则的、 <strong>意料之内</strong> 的行为。例如尝试读取“读保护”的文件。</li>
</ul>
<p>可以看到，“错误”与“异常”的区别是“意料之内”还是“之外”。因此，本文中所说的“错误”其实都指的是异常（这也是 Java 中既存在异常 Exception 又存在 Error 的原因）。</p>
<p>在 C 语言中，错误处理的机制是十分简陋的，例如 Linux 的系统调用如果出错，会将错误记录在一个全局变量 <code>errno</code> 中，<code>errno</code> 是一个整型值，操作系统事先约定好不同值代表不同含义。</p>
<p>到了 C++/Java/Python 语言则采用了异常处理机制，当函数错误时，可以抛出预定义或自定义的异常，语言本身提供了捕获这个异常/错误的语法（即 <code>try ... catch ...</code>）</p>
<p>异常处理相比于返回错误的好处是分离了接收和处理错误的代码。如果只用 C 语言的方式，则函数的返回值需要有一部分用于表示错误。例如 <code>read</code> 函数 在出错时返回
<code>-1</code>；正确时返回 <code>0</code> 或以上，而函数的调用者必须自己区分正确也错误的情形。还有一些更坏的情况，例如一个除法函数，它返回的任何值理论上都可能是“正确值”。那么当发生除 0 错误时，它应该返回什么值来表示错误呢？</p>
<p>在写作本文时，我也倍受困扰，“返回错误”的方式明明一无是处，为什么 Rust 还要选择这种方式呢？ <a href="https://news.ycombinator.com/item?id=9545647">这篇文章</a> 中提出的观点是：Rust 是一门相对底层的语言，因此在某些情况下，异常处理所需要的额外性能开销是不可接受的。或许这就是 Rust 不包含异常的原因吧。</p>
<h2 id="option"><a class="header-anchor" href="#option"></a>Option</h2>
<p>首先要注意到 Rust 中是没有 <code>null</code> 的概念的，我们无法像其它语言（如 C++/java）一样创建一个变量，并赋值为 <code>null</code> 来代表变量当前没有内容。在 Rust 中，做不到！</p>
<p>于是 Rust 自定义了一个结构体来表示可能为空的情形，这应该是向 Haskell 的
<code>Maybe</code> 借鉴的吧。结构体长这样：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样，当你想表示 <code>null</code> 时就可以用 <code>None</code> 代替。而其它的赋值则可以用
<code>Some(...)</code> 完成。带来的问题是：如何访问 <code>Some(...)</code> 里的内容呢？Rust 的答案是
pattern matching:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> opt &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;&#125;&quot;</span>, value),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got None&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而由于 <code>match</code> 会保证我们列出了所有可能的 <code>pattern</code>，即不允许只处理 <code>Some</code> 而不处理 <code>None</code>，因此保证了程序员必定处理了值为 <code>null</code> 的情形。就说机不机智。</p>
<p>不过事实是程序员都懒啊，如果我明确知道不可能出现为 <code>null</code> 的情况，还需要写一堆的 <code>match</code>，着实闹心，于是 rust 又为我们开了小灶，提供了 <code>unwrap</code> 函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="type">Option</span>::<span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="type">Option</span>::<span class="literal">None</span> =&gt;</span><br><span class="line">              <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意这里的 <code>panic!</code>，它的作用是输出错误的信息并退出程序（严格地说并不一定退出程序，rust 1.9 添加了
<a href="https://blog.rust-lang.org/2016/05/26/Rust-1.9.html">catch_unwind</a> 支持）。所以可以通过调用 <code>option.unwrap()</code> 来获取 <code>option</code> 中包裹的值。言下之意就是：你说不可能出现 <code>null</code> 是吧，我且相信你，但如果出了问题我就不管了。</p>
<p>当然，使用 <code>Option</code> 的过程中还有其它一些问题，例如，程序员知道可能出现 <code>None</code>
的情况，当出现时使用一个默认的值。这种情况 rust 提供了函数
<code>unwrap_or(default)</code> 来方便书写。再例如两个函数都返回 <code>Option</code>，我们想将一个函数的输出作为另一个函数的输入，此时可以使用 <code>and_then</code> 来减少手写 <code>match</code> 的次数。</p>
<p>还有一些其它的情况可以参考 <a href="https://doc.rust-lang.org/book/error-handling.html#composing-optiont-values">官方文档</a></p>
<h2 id="result-option-加强版"><a class="header-anchor" href="#result-option-加强版"></a>Result: Option 加强版</h2>
<p><code>Option</code> 可以用来表示 <code>null</code> 的情形，这解决了前文提到的一个问题，如果除法函数发生了除 0 操作，返回什么值来表示发生错误了？有了 <code>Option</code> 我们可以返回
<code>None</code>。</p>
<p>但如果可能发生多个错误呢？这时，<code>Option</code> 可以认为只能表示发生一个错误的情形。于是 Rust 提出了另一个结构，用于包裹真正的结果：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其实就是表示了两种可能，如果没有错误，则返回 <code>Ok(..)</code>，反之返回 <code>Err(..)</code>。而由于 <code>Err</code> 可以带参数，所以即使发生了多个错误也能正常表示。甚至，我们可以将
<code>Option</code> 定义为：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Option</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, ()&gt;;</span><br></pre></td></tr></table></figure></div>
<p>它和上节中的 <code>Option</code> 在作用上是等价的。另一方面，我们也看到，其实
rust 处理错误就是返回不同的结构体，某些表示正确，某些表示错误，我们甚至可以抛开这些结构，直接用 <code>tuple</code> 来表示：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T, E&gt; = (T, E);</span><br></pre></td></tr></table></figure></div>
<p>这样的话，是不是和 Go 语言又很相似了呢？所以这里要强调的是，返回错误的重点在于“返回”，也就是说，错误也是“正常值”的一种。</p>
<p>我们马上又要回到了 <code>Option</code> 的老路了，但这之前，我们发现 <code>Err(E)</code> 中，<code>E</code> 可以是任意类型，也就是说我们可以将错误指定为任意类型。我们先指定为 <code>i32</code> 来模仿 C
中的 <code>errno</code> ：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read</span>(...) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>, <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> size &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而如果调用者对发生的错误感兴趣，则可以继续用 pattern matching 来解构：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">read</span>(...) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(size) =&gt; ...</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="number">1</span>) =&gt; ... file not found ...</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="number">2</span>) =&gt; ... is directory ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当然，像 <code>Option</code> 一样，如果程序员对发生的错误不感兴趣，rust 也提供了 <code>unwrap</code>
方法来避免手写 <code>match</code>。</p>
<p>要注意的是，无论是 <code>Option</code> 还是 <code>Result</code>，它们更像是一种约定，而不是机制。假设你是 API 的提供者，你当然也可以按你自己喜欢的方式返回错误。而关于 <code>Option</code>
和 <code>Result</code>，重要的是标准库的所有函数都遵守这样的约定，也因此对它们的支持相比你自定义的类型要丰富，这也是我们最好遵守这种约定的主要原因。</p>
<h2 id="错误传递"><a class="header-anchor" href="#错误传递"></a>错误传递</h2>
<p>上面说了半天，其实依旧没有提及如何表示“错误”本身。无论是 <code>Option</code> 还是
<code>Result</code> 其实都只是“包裹”错误的容器罢了。那么什么才是“错误”呢？</p>
<p>上节其实提到了，在 <code>Result</code> 中，“错误”其实可以是任意类型。但下文我们会提到，
rust 定义了一个 trait: <code>Error</code>。而之所以需要这个定义，是因为我们在错误传递上遇到了问题。</p>
<p>想像一下，当你调用某个函数时，你不在乎它们会产生什么错误，无论错误是什么，你只想把它们往外丢，就像异常处理里的 <code>throw</code> 一样。考虑 <a href="https://doc.rust-lang.org/book/error-handling.html#the-limits-of-combinators">下面例子</a> ，</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 3</span></span><br><span class="line">    <span class="number">2</span> * n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doubled</span> = <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, doubled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>第一个遇到的问题就是：调用的函数会返回不同类型的错误，如果我们要抛出错误，要将它们定义成什么类型？眉头一皱，计上心头。定义成 <code>String</code> 不就行了？于是我们将代码改写成：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(file_path) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="keyword">match</span> contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; n,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，我们手工地将各种错误通过 <code>err.to_string()</code> 转成 <code>String</code> 类型并返回。回想一下我们的初衷，就是在 <code>file_double</code> 中我们不想处理调用子函数时产生的任何错误，我们认为应该让调用者处理，可由于返回值要统一，因此我们把它转换成
<code>String</code> 类型后再返回。</p>
<p>第二个问题是：我们手写了许多的 <code>match</code> 语句来解构返回值，浪费时间，降低代码的可读性，这个问题可以通过写一个宏来解决。</p>
<h2 id="try-宏"><a class="header-anchor" href="#try-宏"></a>try! 宏</h2>
<p>为了解决上节的第二个问题，我们定义了一个宏，命名为 <code>try!</code>，如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>有了它，上节的代码就可以写成：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="built_in">try!</span>(File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">try!</span>(file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="built_in">try!</span>(contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中的 <code>.map_err(|e| e.to_string())</code> 做的是将 <code>err</code> 转成 <code>String</code> 类型。可以看到，代码一下简短了许多。然而我们写了许多 <code>.map_err(..)</code> 来转换类型也着实丑陋，下面就来解决这个问题。</p>
<h2 id="error-trait"><a class="header-anchor" href="#error-trait"></a>Error Trait</h2>
<p>把错误转换成 <code>String</code> 返回有一个不足，就是我们失去了错误原本的类型信息，不利于函数的调用者再针对错误的类型做不同的处理。于是 Rust 为我们定了一个统一的类型来表示错误：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Display&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Error</span>: <span class="built_in">Debug</span> + Display &#123;</span><br><span class="line">  <span class="comment">/// A short description of the error.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The lower level cause of this error, if any.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;Error&gt; &#123; <span class="literal">None</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果所有的错误全都实现了 <code>Error</code> trait，则我们很容易就能创建自己的错误类型，目的则是统一函数里会发生的错误，继续上节的例子，我们首先定义自己的类型：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Parse</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>File::open(file_path)</code> 会返回 <code>io::Error</code> 类型，通过 <code>CliError::Io</code> 可以转换成 <code>CliError</code></li>
<li><code>file.read_to_string</code> 与 <code>File::open</code> 类似，也返回 <code>io::Error</code> 的错误。</li>
<li><code>String::parse</code> 则返回的是 <code>num::ParseIntError</code> 类型，能通过
<code>CliError::Parse</code> 转换成 <code>CliError</code> 类型。</li>
</ul>
<p>当然，为了保证与其它类型的兼容性，我们也需要为 <code>CliError</code> 实现 <code>Error</code> triat：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// Both underlying errors already impl `Display`, so we defer to</span></span><br><span class="line">            <span class="comment">// their implementations.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="comment">// Both underlying errors already impl `Error`, so we defer to their</span></span><br><span class="line">        <span class="comment">// implementations.</span></span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;error::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// N.B. Both of these implicitly cast `err` from their concrete</span></span><br><span class="line">            <span class="comment">// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)</span></span><br><span class="line">            <span class="comment">// to a trait object `&amp;Error`. This works because both error types</span></span><br><span class="line">            <span class="comment">// implement `Error`.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; <span class="title function_ invoke__">Some</span>(err),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; <span class="title function_ invoke__">Some</span>(err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可见，只要每个错误类型都实现了 <code>Error</code> trait，则很容易通过建立新的自定义类型来统一错误类型。</p>
<h2 id="from-trait"><a class="header-anchor" href="#from-trait"></a>From trait</h2>
<p><code>Error</code> trait 虽然统一了错误类型，但我们依旧要写一堆 <code>.map_err(...)</code> 来转换类型，有没有什么更好的方法呢？rust 定义了一个通用的 triat 用于转换类型：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">From</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>再次重申，有点类型于 Java 中的 <code>interface</code>，<code>trait</code> 只是一种“约定”，而约定之所以有用，是因为 rust 的标准库都遵守了这个约定。如 <code>From</code> 要求类型实现从其它类型的转换函数，例如你可以做下面的操作：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string</span>: <span class="type">String</span> = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cow</span>: ::std::borrow::Cow&lt;<span class="type">str</span>&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>这是因为标准库中的 <code>String</code> 类型已经实现了 <code>From&lt;&amp;str&gt;</code>，另外几个也类似。</p>
<p>那么为什么上节中我们自定义的错误类型要实现 <code>Error</code> trait 呢？其中一个重要原因是标准库已经为 <code>Box&lt;Error&gt;</code> 实现了 <code>From</code> trait：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, E: Error + <span class="symbol">&#x27;a</span>&gt; <span class="built_in">From</span>&lt;E&gt; <span class="keyword">for</span> <span class="title class_">Box</span>&lt;Error + <span class="symbol">&#x27;a</span>&gt;</span><br></pre></td></tr></table></figure></div>
<p>也因此我们可以用 <code>From::from</code> 来进行错误类型间的转换如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We have to jump through some hoops to actually get error values.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">io_err</span>: io::Error = io::Error::<span class="title function_ invoke__">last_os_error</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">parse_err</span>: num::ParseIntError = <span class="string">&quot;not a number&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_err</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, here are the conversions.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">err1</span>: <span class="type">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(io_err);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">err2</span>: <span class="type">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(parse_err);</span><br></pre></td></tr></table></figure></div>
<p>因此，有了 <code>Error</code> 和 <code>From</code> 两个 trait 及标准库对两个 trait 的实现，<code>try!</code> 宏的真正实现方式就进化了：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(::std::convert::<span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(err)),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>有了这两个工具，我们就可以：</p>
<ol>
<li>不定义自己的类型，而直接使用 <code>Box&lt;Error&gt;</code> 来统一错误类型。</li>
<li>用 <code>try!</code> 宏来传递错误。</li>
</ol>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="built_in">try!</span>(File::<span class="title function_ invoke__">open</span>(file_path));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">try!</span>(file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="built_in">try!</span>(contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>完美！并且，在 rust 1.13 中加入了 <code>?</code> 操作符，用来替代 <code>try!</code> 因此可以这么写：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="统一自定义错误类型"><a class="header-anchor" href="#统一自定义错误类型"></a>统一自定义错误类型</h2>
<p>最后一个大问题是自定义错误类型。有了 <code>From</code> trait 之后，我们可以轻易地将任意实现了 <code>Error</code> trait 的错误转换成 <code>Box&lt;Error&gt;</code>，但如果我们要返回的不是
<code>Box&lt;Error&gt;</code> 而是自定义错误，那要怎么办呢？答案也很简单，为可能出现的错误实现
<code>From</code> trait。</p>
<p>上几节的例子中，可能出现的错误为 <code>io::Error</code> 和 <code>num::ParseIntError</code>，因此我们需要为 <code>CliError</code> 实现 <code>From&lt;io::Error&gt;</code> 和 <code>From&lt;num::ParseIntError&gt;</code>。如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: io::Error) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Io</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: num::ParseIntError) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Parse</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>有了上述的实现，我们就可以写出如下代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="built_in">try!</span>(File::<span class="title function_ invoke__">open</span>(file_path));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">try!</span>(file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="built_in">try!</span>(contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>终于搞定了！</p>
<h2 id="如何处理错误？"><a class="header-anchor" href="#如何处理错误？"></a>如何处理错误？</h2>
<p>综上，在 rust 语言中，处理错误有几种方式：</p>
<p>对于函数的作者而言，返回值可以是：</p>
<ol>
<li>正常的值，即 <code>i32</code>, <code>String</code> 等等，表明该函数不可能发生错误。</li>
<li>返回 <code>Option</code> 表示函数可能会失败。</li>
<li>不自定义错误。返回 <code>Result&lt;..., Box&lt;Error&gt;&gt;</code> 。</li>
<li>返回自定义错误，如上例中的 <code>Result&lt;i32, CliError&gt;</code>。</li>
</ol>
<p>而当函数 <code>A</code> 调用的子函数 <code>B</code> 返回错误时，有几种处理的方式：</p>
<ol>
<li>不处理错误。即调用 <code>unwrap</code> 来获取返回数据。</li>
<li>在函数 <code>A</code> 内部处理。即通过 <code>match</code> 语句或 <code>unwrap_or</code> 等函数来处理返回值可能包含错误的情况。</li>
<li>当函数 <code>A</code> 返回值为 <code>Result</code> 且 <code>B</code> 的返回值也为 <code>Result</code> 时，可以通过
<code>try!(B())</code> 来获得 <code>B</code> 的返回值。而若返回值为 <code>Err</code> 时，<code>try!</code> 会自动退出函数 <code>A</code> 并将错误进行处理后返回。</li>
</ol>
<p>最后，当函数的作用决定自定义错误类型（如 <code>CliError</code>）时，需要做几项操作：</p>
<ol>
<li>实现 <code>Error</code> trait。即实现 <code>description</code> 和 <code>cause</code> 函数，来提供错误的内容。</li>
<li>为可能发生的错误实现 <code>From</code> trait。如上文中 <code>CliError</code> 实现了
<code>From&lt;io::Error&gt;</code> 和 <code>From&lt;num::ParseIntError&gt;</code>。</li>
</ol>
<p>上述两项工作完成后就可以放心地使用 <code>try!</code> 来获取子函数返回值的内容了。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>本文首先区别介绍了“返回错误”和“异常处理”的区别。Rust 选择了“返回错误”的道路，本文也因此介绍了它面临了几个问题：</p>
<ol>
<li>如何表示返回值有错误？Rust 提供了 <code>Option</code> 与 <code>Result</code> 这两个“容器”来满足不同需求。</li>
<li>调用不同子函数可能返回不同错误类型，于是使用 <code>Error</code> trait 来统一类型。</li>
<li>解构返回值需要写大量 <code>match</code> 语句，Rust 引入宏 <code>try!</code> 来减少工作量。</li>
<li>不同错误类型间的转换需要写很多代码，Rust 引入 <code>From</code> trait 来减少程序员的输入。</li>
</ol>
<p>最后，若用户需要自定义错误类型，它需要同时实现 <code>Error</code> 与 <code>From</code> 两个 trait.</p>
<p>与其它语言对比，rust 的错误处理是相当地复杂。其中的重要原因是它更像是一种高层的约定，而非语言层面的机制，换句话说，你用其它的语言也能实现类似的功能。</p>
<p>由于我写过的 rust 程序都不大，并且没有写过库，因此对这套错误处理方式的优点并不是特别“感同深受”，也许它更适合大型程序的开发吧。</p>
<h2 id="reference"><a class="header-anchor" href="#reference"></a>Reference</h2>
<ul>
<li><a href="http://blog.honeypot.io/errors-and-exceptions-in-rust/">http://blog.honeypot.io/errors-and-exceptions-in-rust/</a> : Rust 处理错误异常的方式，介绍了不同语言处理异常的方式。</li>
<li><a href="https://news.ycombinator.com/item?id=9545647">https://news.ycombinator.com/item?id=9545647</a> : 关于 rust 为何不采用“异常处理”的讨论。</li>
<li><a href="http://www.infoq.com/cn/news/2012/11/go-error-handle">http://www.infoq.com/cn/news/2012/11/go-error-handle</a> : Go语言的错误处理机制引发争议。</li>
</ul>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>