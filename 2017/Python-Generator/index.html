<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Python 中的生成器 (generator) 是一个十分有用的工具，它让我们能方便地生成迭代器
(iterator)。这篇文章里，我们就来说说什么是生成器，生成器有什么作用以及如何使用。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Python Generator | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Generator/" rel="tag">Generator</a><a class="post-tag-noise-link" href="/tags/python/" rel="tag">python</a></div><div class="post-time">2017-08-29</div></div></div><div class="container post-header"><h1>Python Generator</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">iterator 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-iterator-%E5%88%B0-generator"><span class="toc-number">2.</span> <span class="toc-text">从 Iterator 到 Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generator-%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">3.</span> <span class="toc-text">Generator 与控制流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield-%E5%8A%A0%E5%BC%BA%E7%89%88"><span class="toc-number">4.</span> <span class="toc-text">yield 加强版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield-from"><span class="toc-number">5.</span> <span class="toc-text">yield from</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>Python 中的生成器 (generator) 是一个十分有用的工具，它让我们能方便地生成迭代器
(iterator)。这篇文章里，我们就来说说什么是生成器，生成器有什么作用以及如何使用。</p>
<p>本文需要你对 Python 基本的语法有一定的了解，并知道 iterator 是什么，且我们可以通过 <code>next(iterator)</code> 来获取 <code>iterator</code> 的下一个值。</p>
<h2 id="iterator-简介"><a class="header-anchor" href="#iterator-简介"></a>iterator 简介</h2>
<p>想象这样一个需求，我们需要从网上获取一些图片，这些图片的名字的规律是数字递增，因此我们有类似下面的代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_images</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        result.append(get_image_by_id(i))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">images = get_images(n)</span><br></pre></td></tr></table></figure></div>
<p>现在，假设我们需要对图片进行一些操作，但依当前图片的情况不同，我们也许不需要后续的图片，并且， <code>get_image_by_id</code> 是一个很耗时的操作，我们希望在不需要的情况下尽量避免调用它。</p>
<p>换句话说，我们希望能对 <code>get_image_by_id</code> 进行懒执行 (lazy evaluation)。这也不难，我们可以这么做：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_id = -<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_image</span>():</span><br><span class="line">    <span class="keyword">global</span> image_id</span><br><span class="line">    image_id += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> get_image_by_id(image_id)</span><br><span class="line"></span><br><span class="line">image0 = next_image()</span><br><span class="line">image1 = next_image()</span><br></pre></td></tr></table></figure></div>
<p>这里函数 <code>next_image</code> 使用了全局的变量保存当前已获取的图片的 <code>id</code>，使用全局变量决定了 <code>next_image</code> 无法被两个个体使用。例如两个人都想从头获取图片，这是没法完成的，因此我们定义一个类来解决这个问题：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImageRepository</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.image_id = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_image</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.image_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> get_image_by_id(<span class="variable language_">self</span>.image_id)</span><br><span class="line"></span><br><span class="line">repo = ImageRepository()</span><br><span class="line">image0 = repo.next_image()</span><br><span class="line">image1 = repo.next_image()</span><br></pre></td></tr></table></figure></div>
<p>如果你熟悉 iterator 的话，应该知道上面这个需求是一个典型的 iterator，因此我们可以实现 <code>__iter__</code> 及 <code>__next__</code> 方法来将它变成一个 iterator，从而充分利用
iterator 现成的一些工具：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImageRepository</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.image_id = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.image_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> get_image_by_id(<span class="variable language_">self</span>.image_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> ImageRepository():</span><br><span class="line">    <span class="comment"># some operation on each image</span></span><br></pre></td></tr></table></figure></div>
<p>是不是也没什么难度？下面我们看看其它的一些思路。</p>
<h2 id="从-iterator-到-generator"><a class="header-anchor" href="#从-iterator-到-generator"></a>从 Iterator 到 Generator</h2>
<p>上面的 iterator 的例子有一个特点，就是它需要我们自己去管理 iterator 的状态，即
<code>image_id</code>。这种写法跟我们的思维差异较大，因此懒惰的我们希望有一些更好，更方便的写法，这就是我们要介绍的 genrator 。</p>
<p>在 Python 中，只要一个函数中使用了 <code>yeild</code> 这个关键字，就代表这个函数是一个生成器 (generator)。而 <code>yield</code> 的作用就相当于让 Python 帮我们把一个“串行”的逻辑转换成 iterator 的形式。例如，上面的例子用 generator 的语法写就变成了：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">image_repository</span>()</span><br><span class="line">    image_id = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        image_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> get_image_by_id(image_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> image_repository():</span><br><span class="line">    <span class="comment"># do some operation</span></span><br></pre></td></tr></table></figure></div>
<p>首先，就写法上，这种写法与我们最先开始的循环写法最为类似；其次，在功能上，调用这个函数 <code>image_repository()</code> 返回的是一个 generator object，它实现了 iterator 的方法，因此可以将它作为普通的 iterator 使用 （<code>for ... in ...</code>）；最后，注意到我们所要做的，就是把平时使用的 <code>return</code> 换成 <code>yield</code> 就可以了。</p>
<p>再举个例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>():</span><br><span class="line">    a, b = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line"></span><br><span class="line">fibos = fibonacci()</span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 0</span></span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure></div>
<p>通过 generator ，我们很轻松地就写出了一个无限的斐波那契数列函数。如果要手写的话，它相当于：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        result = <span class="variable language_">self</span>.a</span><br><span class="line">        <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="variable language_">self</span>.b, <span class="variable language_">self</span>.a + <span class="variable language_">self</span>.b</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">fibos = Fibonacci()</span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 0</span></span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line"><span class="built_in">next</span>(fibos) <span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure></div>
<p>显然 generator 的写法更为清晰，且符合我们平时书写顺序结构的习惯。</p>
<h2 id="generator-与控制流"><a class="header-anchor" href="#generator-与控制流"></a>Generator 与控制流</h2>
<p>前面我们提到，Generator 的作用其实是实现了懒执行 (lazy evaluation) ，即在真正需要某个值的时候才真正去计算这个值。因此，更进一步，Generator 其实是返回了控制流。当一个 generator 执行到 yeild 语句时，它便保存当前的状态，返回所给的结果（也可以没有），并将当前的执行流还给调用它的函数，而当再次调用它时，Generator
就从上次 yield 的位置继续执行。例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;before&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>            <span class="comment"># break 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;middle&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>            <span class="comment"># break 2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = generator()</span><br><span class="line"><span class="built_in">next</span>(x)</span><br><span class="line"><span class="comment">#=&gt; before</span></span><br><span class="line"><span class="built_in">next</span>(x)</span><br><span class="line"><span class="comment">#=&gt; middle</span></span><br><span class="line"><span class="built_in">next</span>(x)</span><br><span class="line"><span class="comment">#=&gt; after</span></span><br><span class="line"><span class="comment">#=&gt; exception StopIteration</span></span><br></pre></td></tr></table></figure></div>
<p>可以看到，第一次调用 <code>next(x)</code>，程序执行到了 <code>break 1</code> 处就返回了，第二次调用
<code>next(x)</code> 时从之前 yield 的位置（即 <code>break 1</code>） 处继续执行。同理，第三次调用
<code>next(x)</code> 时从 <code>break 2</code> 恢复执行，最终退出函数时，抛出 <code>StopIteration</code> 异常，代表 <code>generator</code> 已经退出。</p>
<p>为什么要提到 generator 的“控制流”的特点呢？因为 genrator 表允许我们从“顺序”执行流中暂时退出，利用这个特性我们能做一些很有意义的事。</p>
<p>例如，我们提供一个 API，它要求调用者首先调用 <code>call_this_first</code> 然后做一些操作，然后再调用 <code>call_this_second</code>，再做一些操作，最后调用 <code>call_this_last</code>。也就是说这些 API 的调用是有顺序的。但 API 的提供者并没有办法强制使用者按我们所说的顺序去调用这几个 API。但有了 generator，我们可以用另一种形式提供 API，如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">API</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_this_first</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_this_second</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_this_last</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">api</span>():</span><br><span class="line">    first()</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    second()</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    last()</span><br></pre></td></tr></table></figure></div>
<p>通过这种方式提供的 API 能有效防止使用者的误用。这也是 generator 能 “从控制流中返回” 这个特性的一个应用。</p>
<h2 id="yield-加强版"><a class="header-anchor" href="#yield-加强版"></a>yield 加强版</h2>
<p>上面我们说到 Generator 允许我们暂停控制流，并返回一些数据，之后能从暂停的位置恢复。那我们就会有疑问，既然暂停控制流时能返回数据，那恢复控制流的时候能不能传递数据到暂停的位置呢？ <a href="https://www.python.org/dev/peps/pep-0342">PEP 342</a>
中就加入了相关的支持。这个需求说起来比较抽象，我们举个例子：</p>
<p>想象我们要写一个函数，计算多个数的平均值，我们称它为 <code>averager</code>。我们希望每次调用都提供一个新的数，并返回至今为止所有提供的数的平均值。让我们先来看看用
generator 的加强版语法怎么实现：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>():</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">sum</span> += (<span class="keyword">yield</span> <span class="built_in">sum</span> / num <span class="keyword">if</span> num &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x = averager()</span><br><span class="line">x.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#=&gt; 0</span></span><br><span class="line">x.send(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.0</span></span><br><span class="line">x.send(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.5</span></span><br><span class="line">x.send(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#=&gt; 2.0</span></span><br></pre></td></tr></table></figure></div>
<p>这个加强版的语法是这么工作的： yield 之前是语句，现在是表达式，是表达式就意味着我们能这么写 <code>x = yield 10</code>, <code>y = 10 + (yield)</code>, <code>foo(yield 42)</code>。Python 规定，除非 yield 左边直接跟着等号（不准确），否则必须用扩号括起来。</p>
<p>当 Python 执行到 yield 表达式时，它首先计算 yield 右边的表达式，上例中即为
<code>sum / num if num &gt; 0 else 0</code> 的值，暂停当前的控制流，并返回。之后，除了可以用
<code>next(generator)</code> 的方式（即 iterator  的方式）来恢复控制流之外，还可以通过
<code>generator.send(some_value)</code> 来传递一些值。例如上例中，如果我们调用
<code>x.send(3)</code> 则 Python 恢复控制流， <code>(yield sum/sum ...)</code> 的值则为我们赋予的
<code>3</code>，并接着执行 <code>sum += 3</code> 以及之后的语句。注意的是，如果这时我们用的是
<code>next(generator)</code> 则它等价为 <code>generator.send(None)</code>。</p>
<p>最后要注意的是，刚调用 generator 生成 generator object 时，函数并没有真正运行，也就是说这时控制流并不在 <code>yield</code> 表达式上等待用户传递值，因此我们需要先调用 <code>generate.send(None)</code> 或 <code>next(generator)</code> 来触发最开始的执行。</p>
<p>那么说到这里，用 generator 来实现这个需求明显没有其它方法好用，例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Averager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">avg_num</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">sum</span> += n</span><br><span class="line">        <span class="variable language_">self</span>.num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">sum</span> / <span class="variable language_">self</span>.num</span><br><span class="line">averager = Averager()</span><br><span class="line">averager.avg_num(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.0</span></span><br><span class="line">averager.avg_num(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.5</span></span><br><span class="line">averager.avg_num(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#=&gt; 2.0</span></span><br></pre></td></tr></table></figure></div>
<p>这种写法比 generator 更直观，并且用户调用起来也方便，不需要额外调用一次
<code>x.send(None)</code>。显然 generator 的加强版语法并不是为了专门用来解决我们这里提到的需求的。它要解决的真正问题是支持协程 (coroutine) 来实现异步编程的。由于这个问题比较复杂，这里就不深入讨论了。</p>
<h2 id="yield-from"><a class="header-anchor" href="#yield-from"></a>yield from</h2>
<p>考虑我们有多个 generator 并想把 generator 组合起来，如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odds</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evens</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">odd_even</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> odds(n):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> evens(n):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> odd_even(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#=&gt; 1, 3, 5, 0, 2, 4</span></span><br></pre></td></tr></table></figure></div>
<p><code>for x in generator(): yield x</code> 这种写法不太方便，因此 <a href="https://www.python.org/dev/peps/pep-0380/">PEP
380</a> 引入了 <code>yield from</code> 语法，来替代我们前面说的这种语法，因此上面的例子可以改成：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odd_even</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> odds(n)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> evens(n)</span><br></pre></td></tr></table></figure></div>
<p>是不是清晰许多？</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>我们简单介绍了 iterator ；之后介绍了使用 generator 来更方便地生成 iterator；之后举例说明了 yield 的加强版语法，最后介绍了 yield from 语法。</p>
<ol>
<li>当一个函数里使用了 yield 关键字，则该函数就被称为一个 generator （生成器）。</li>
<li>Generator 被调用时返回 Generator Object，它实现了 iterator 的接口。所以可以认为 generator 调用后返回了一个 iterator。</li>
<li>yeild 可以从控制流中暂时退出，之后可以从退出的位置恢复。通过加强版的语法还能在恢复时传递一些值给 generator。</li>
<li>yield from 语法可以用来方便地组合不同的 generator。</li>
</ol>
<p>Generator 是生成 iterator 非常方便的工具，希望本文能让你对 generator 有更好的了解，也希望 Generator 能给你今后的 Python 生涯带来更多的方便。</p>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>