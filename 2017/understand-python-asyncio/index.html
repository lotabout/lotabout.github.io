<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="协程 (coroutine) 几乎是 Python 里最为复杂的特性之一了，这篇文章我们来说一说
asyncio 的内部实现机制，借此来理解一门语言要支持协程需要做的工作。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>理解 Python asyncio | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/async/" rel="tag">async</a><a class="post-tag-noise-link" href="/tags/coroutine/" rel="tag">coroutine</a><a class="post-tag-noise-link" href="/tags/python/" rel="tag">python</a></div><div class="post-time">2017-09-03</div></div></div><div class="container post-header"><h1>理解 Python asyncio</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">多线程与协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#event-loop"><span class="toc-number">2.</span> <span class="toc-text">Event Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#callback-vs-promise-vs-await"><span class="toc-number">3.</span> <span class="toc-text">Callback vs Promise vs await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-%E6%81%A2%E5%A4%8D%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">4.</span> <span class="toc-text">上下文切换（恢复控制流）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">6.</span> <span class="toc-text">扩展阅读</span></a></li></ol></details></div><div class="container post-content"><p>协程 (coroutine) 几乎是 Python 里最为复杂的特性之一了，这篇文章我们来说一说
asyncio 的内部实现机制，借此来理解一门语言要支持协程需要做的工作。</p>
<p>本文需要提前了解 Python 的 <code>yield from</code> 语法，不了解的话，可以看看<a href="/2017/Python-Generator/" title="Python Generator">之前关于 Generator 的文章</a> ；另外，最好对 future/promise 的概念有一定了解。文中不会介绍如何使用 asyncio 及协程，并且文中给出的代码不一定能实际运行（不然代码量太大）。</p>
<h2 id="多线程与协程"><a class="header-anchor" href="#多线程与协程"></a>多线程与协程</h2>
<p>CPU 的执行是顺序的，线程是操作系统提供的一种机制，允许我们在操作系统的层面上实现“并行”。而协程则可以认为是应用程序提供的一种机制（用户或库来完成），允许我们在应用程序的层面上实现“并行”。</p>
<p>由于本质上程序是顺序执行的，要实现这种“并行”的假像，我们需要一种机制，来“暂停”当前的执行流，并在之后“恢复”之前的执行流。这在操作系统及多线程/多进程中称为“上下文切换” (context switch)。其中“上下文”记录了某个线程执行的状态，包括线程里用到的各个变量，线程的调用栈等。而“切换”指的就是保存某个线程当前的运行状态，之后再从之前的状态中恢复。只不过线程相关的工作是由操作系统完成，而协程则是由应用程序自己来完成。</p>
<p>与线程不同的是，协程完成的功能通常较小，所以会有需求将不同的协程串起来，我们暂时称它为协程链 (coroutine chain)。</p>
<p>那么，与线程类似，要实现一个协程的库，我们需要这几样东西：</p>
<ol>
<li>事件循环 (event loop)。一方面，它类似于 CPU ，顺序执行协程的代码；另一方面，它相当于操作系统，完成协程的调度，即一个协程“暂停”时，决定接下来执行哪个协程。</li>
<li>上下文的表示。在 Python 中，我们使用 Python 本身支持的生成器 Generator 来代表基本的上下文，但协程链是如何工作的呢？</li>
<li>上下文的切换。最基础的切换也是通过 Python 生成器的 yield 加强版语法来完成的，但我们还要考虑协程链的情况。</li>
</ol>
<h2 id="event-loop"><a class="header-anchor" href="#event-loop"></a>Event Loop</h2>
<p>首先，因为协程是一种能暂停的函数，那么它暂停是为了什么？一般是等待某个事件，比如说某个连接建立了；某个 socket  接收到数据了；某个计时器归零了等。而这些事件应用程序只能通过轮询的方式得知是否完成，但是操作系统（所有现代的操作系统）可以提供一些中断的方式通知应用程序，如 <code>select</code>, <code>epoll</code>, <code>kqueue</code> 等等。</p>
<p>那么有了操作系统的支持，我们就可以手写这样的循环（伪代码）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span></span><br><span class="line">    happend = poll_events(events_to_listen, timeout)</span><br><span class="line">    process_events(happend)</span><br></pre></td></tr></table></figure></div>
<p>第一个问题是：如何注册我们想监听的事件？很简单，把事件加到 <code>events_to_listen</code>
里就可以了。第二个问题，可以监听什么事件？由于 <code>poll_events</code> 需要操作系统的支持，那么我们想监听的事件是需要操作系统支持才行的，一般操作系统支持网络 I/O
的文件描述符 (file descriptor)。</p>
<p>接下来，当事件发生时，我们要指定做一些事，一般称为回调 (callback)。也就是说我们需要告诉 event loop 一个 <code>事件:回调</code> 的对应关系。现在我们把 event loop 用类表示：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.events_to_listen = []</span><br><span class="line">        <span class="variable language_">self</span>.callbacks = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.timeout = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register_event</span>(<span class="params">self, event, callback</span>):</span><br><span class="line">        <span class="variable language_">self</span>.events_to_listen.append(event)</span><br><span class="line">        <span class="variable language_">self</span>.callbacks[event] = callback</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unregister_event</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="variable language_">self</span>.events_to_listen.remove(evenrt)</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.callbacks[event]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_events</span>(<span class="params">self, events</span>):</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">            <span class="variable language_">self</span>.callbacks[event](event)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_loop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            events_happend = poll_events(<span class="variable language_">self</span>.events_to_listen, timeout)</span><br><span class="line">            <span class="variable language_">self</span>._process_events(events_happend)</span><br><span class="line"></span><br><span class="line">loop = EventLoop()</span><br><span class="line">loop.register_event(fd, callback)</span><br><span class="line">loop.start_loop()</span><br></pre></td></tr></table></figure></div>
<p><code>register_event</code> 用于注册 <code>事件: 回调</code> 的关系，<code>start_loop</code> 用于开启事件循环。</p>
<p>现在，你可能想说，之前提到过事件也包括“某个计时器归零了”，但 <code>poll_events</code> 只支持网络 I/O 的文件描述符，计时器又要如何实现呢？一般 <code>poll_events</code> 函数支持
<code>timeout</code> 参数表示等待的时间。因此可以修改 <code>start_loop</code>:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">call_later</span>(<span class="params">self, delay, callback</span>):</span><br><span class="line">    <span class="variable language_">self</span>.call_at(now() + delay, callback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_at</span>(<span class="params">self, when, callback</span>):</span><br><span class="line">    <span class="variable language_">self</span>.timeout_callbacks[when] = callback</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_loop</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        timeout = <span class="built_in">min</span>(<span class="variable language_">self</span>.timeout_callbacks.keys()) - now()</span><br><span class="line">        events_happend = poll_events(<span class="variable language_">self</span>.events_to_listen, timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> empty(events_happend):</span><br><span class="line">            <span class="variable language_">self</span>._process_events(events_happend)</span><br><span class="line">        <span class="variable language_">self</span>._process_timeout_events()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_process_timeout_events</span>(<span class="params">self</span>):</span><br><span class="line">    time_now = now()</span><br><span class="line">    <span class="keyword">for</span> time, callback <span class="keyword">in</span> <span class="variable language_">self</span>.timeout_callbacks.iteritems():</span><br><span class="line">        <span class="keyword">if</span> time &lt; time_now:</span><br><span class="line">            callback()</span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.timeout_callbacks[time]</span><br></pre></td></tr></table></figure></div>
<p>这里 <code>poll_events</code> 之前，会去计算所有计时器事件最少需要等待的时间，这个时间内即使没有事件发生，<code>poll_events</code> 也会退出，以便触发计时器事件。
<code>_process_timeout_events</code> 函数的作用是对比当前时间与计时器的目标执行时间，如果目标执行时间已经到达，则执行相应的回调函数。</p>
<p>于是一个简单的 event loop 就完成了。可以看到，它是异步操作的基础：允许等待某个事件的发生并执行相应的操作。同时，它还是个简单的调度器，能顺序地执行发生事件的回调函数。</p>
<h2 id="callback-vs-promise-vs-await"><a class="header-anchor" href="#callback-vs-promise-vs-await"></a>Callback vs Promise vs await</h2>
<p>好了，现在我们有了 event loop ，它允许我们为事件注册回调函数。现在假设我们要顺序调用几个 API， 用阻塞式编程如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result1 = api1()</span><br><span class="line">result2 = api2(result1)</span><br><span class="line">result3 = api3(result2)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
<p>如果这几个 API 都是异步的，用 event loop + callback 怎么实现？</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Implementation for api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">api1</span>(<span class="params">callback</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback_for_api1</span>():</span><br><span class="line">        result1 = some_calculation_1()</span><br><span class="line">        event_loop.unregister_event(event1)</span><br><span class="line">        <span class="keyword">return</span> callback(result1)</span><br><span class="line">    event_loop.register_event(event1, callback_for_api1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">api2</span>(<span class="params">result, callback</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback_for_api2</span>():</span><br><span class="line">        result2 = some_calculation_2(result)</span><br><span class="line">        event_loop.unregister_event(event2)</span><br><span class="line">        <span class="keyword">return</span> callback(result2)</span><br><span class="line">    event_loop.register_event(event2, callback_for_api2)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Our code</span></span><br><span class="line"><span class="keyword">global</span> result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">api1_callback</span>(<span class="params">result1</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">api2_callback</span>(<span class="params">result2</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">api3_callback</span>(<span class="params">result3</span>):</span><br><span class="line">            <span class="keyword">global</span> result</span><br><span class="line">            result = some_calculation(result3)</span><br><span class="line">        <span class="keyword">return</span> api3(result2, api3_callback)</span><br><span class="line">    <span class="keyword">return</span> api2(result1, api2_callback)</span><br><span class="line">api1(api1_callback)</span><br></pre></td></tr></table></figure></div>
<p>这里 <code>api1</code> <code>api2</code> 的实现由于需要用 event loop 来注册注销某些事件，所以显得特别复杂，这里我们可以先忽略它们的实现，但是看最后一段“用户代码”是不是极其复杂？随着操作的复杂性增加，回调函数的嵌套会越变越深。如果你熟悉Javascript，你应该听过“callback hell”的大名。回调函数的方式为什么不好？最重要的就是它违反了我们写代码的直觉，我们都习惯顺序执行的代码。</p>
<p>例如上例中，我们期待的是 <code>api1</code> 先执行，我们再用它的结果做点什么，但采用回调的方式，我们就需要在写 <code>api1</code> 的回调时，就去思考我们想用它的结果做些什么操作。在这个例子里，我们需要调用 <code>api2</code> 及 <code>api3</code>，这些嵌套的思考又得一遍遍重复下去。最终代码非常难以理解。</p>
<p>因此 Javascript 提出了 Promise ，所谓的 promise 像是一个占位符，它表示一个运算现在还未完成，但我保证它会做完的；你可以指定它完成的时候做些其它的事。下面我们尝试用这个思路去做一些改进（Python 没有原生的 promise 支持）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">then</span>(<span class="params">self, callback_that_return_promise</span>):</span><br><span class="line">        <span class="variable language_">self</span>._then = callback_that_return_promise</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_result</span>(<span class="params">self, result</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._then(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Implementation for api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">api1</span>():</span><br><span class="line">    promise = Promise()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback_for_api1</span>():</span><br><span class="line">        promise.set_result(some_calculation_1())</span><br><span class="line">        event_loop.unregister_event(event1)</span><br><span class="line">    event_loop.register_event(event1, callback_for_api1)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">api2</span>(<span class="params">result</span>):</span><br><span class="line">    promise = Promise()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback_for_api2</span>():</span><br><span class="line">        promise.set_result((some_calculation_2(result))</span><br><span class="line">        event_loop.unregister_event(event2)</span><br><span class="line">        <span class="keyword">return</span> callback(result2)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Our code</span></span><br><span class="line"><span class="keyword">global</span> result</span><br><span class="line">promise = api1().then(<span class="keyword">lambda</span> result1: <span class="keyword">return</span> api2(result1))</span><br><span class="line">    .then(<span class="keyword">lambda</span> result2: <span class="keyword">return</span> api3(result3))</span><br><span class="line">    .then(<span class="keyword">lambda</span> result3: <span class="keyword">global</span> result; result = result3)</span><br><span class="line"></span><br><span class="line">promise.wait_till_complete()</span><br></pre></td></tr></table></figure></div>
<p>这里我们简单实现了一个我们自己的 Promise 类，当它的 <code>set_result</code> 方法被调用时，Promise 会去执行之前用 <code>.then</code> 注册的回调函数，该回调函数将执行另一些操作并返回一个新的 Promise。也因此，我们可以不断地调用 <code>then</code> 将不同的 Promise 组合起来。可以看到，现在我们的代码就是线性的了！</p>
<p>然而故事还没有结束，人们依旧不满于 Promise 的写法和用法，又提出了
<code>async/await</code> 的写法。在 Python 中，上面的代码用 <code>async/await</code> 重写如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result1 = <span class="keyword">await</span> api1()</span><br><span class="line">result2 = <span class="keyword">await</span> api2(result1)</span><br><span class="line">result3 = <span class="keyword">await</span> api3(result2)</span><br></pre></td></tr></table></figure></div>
<p>是不是简单明了？它的效果和我们前几个例子是等价的，但它的写法与我们初开始的阻塞版本几乎一致。这样能把异步与同步的编码在结构上尽量统一起来。</p>
<p>这里我不禁想问，为什么大家没有一开始就想到 <code>async/await</code> 的方式呢？我的一个猜想是 <code>async/await</code> 是需要语言本身的支持的，而写编译器/解释器的专家不一定有编写应用的丰富经验，是很可能从一开始就拒绝这样的修改的。因此程序员们只能自己用库的形式添加支持了。当然这纯粹是猜测，只想感叹下不同领域的隔阂。</p>
<p>总而言之，有了 event loop 我们就能通过回调函数来完成异步编程，但这种方式非常不友好，因此人们又提出了类似 Promise 的思想，让我们能顺序编写异步代码，最后通过语言对 <code>async/await</code> 的语法支持，异步与同步代码的结构就几乎达到统一。这种统一有很重要的意义，它使我们能以同步的思维去理解异步的代码而不受回调方式的代码结构的影响。</p>
<p>而这一切都是为了将不同的异步函数“链接”起来，只不过是 <code>async/await</code> 的方式最为方便。对比线程，操作系统是没有提供方式将不同的线程链接起来的，因此这种将不同的协程链接起来的工具是协程比线程好的一个方面。</p>
<h2 id="上下文切换-恢复控制流"><a class="header-anchor" href="#上下文切换-恢复控制流"></a>上下文切换（恢复控制流）</h2>
<p>前面提到过，如果某个协程在等待某些资源，我们需要暂停它的执行，在 event loop 中注册这个事件，以便当事件发生的时候，能再次唤醒该协程的执行。</p>
<p>这里举一个 Python <a href="https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines">官方文档</a>
的例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Compute %s + %s ...&quot;</span> % (x, y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">print_sum</span>(<span class="params">x, y</span>):</span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s + %s = %s&quot;</span> % (x, y, result))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></div>
<p>上面的代码的执行流程是（图源自 python 3.6 <a href="https://docs.python.org/3.6/library/asyncio-task.html">官方文档
</a>，3.7 及之后无此配图）</p>
<p><img src="https://docs.python.org/3.6/_images/tulip_coro.png" alt="Control Flow of Coroutine"></p>
<p>这里有两个问题：</p>
<ol>
<li>谁向 event loop 注册了事件（及回调）？</li>
<li>程序从哪里恢复执行？</li>
</ol>
<p>程序从 <code>print_sum</code> 开始执行，执行到 <code>asyncio.sleep</code> 时需要暂停，那么肯定是在
<code>sleep</code> 中向 event loop 注册了计时器事件。那们问题来了，当程序恢复执行时，它应该从哪里恢复呢？</p>
<p>从上面的流程图中，可以看见它是从 <code>print_sum</code> 开始恢复，但这样的话，<code>sleep</code> 注册事件时就需要知道是谁（即 <code>print_sum</code>）调用了它，这样才能在 callback 中指定从
<code>print_sum</code> 开始恢复执行！</p>
<p>但如果不是从 <code>print_sum</code> 恢复执行，那么一样的，从 <code>sleep</code> 恢复执行后，<code>sleep</code>
需要知道接下来返回到什么位置（即 compute 函数中的 await 位置）， asyncio 又是如何做到这点的？</p>
<p>那么事实（代码实现）是怎样的呢？</p>
<p>当我们把一个协程用 <code>loop.run_until_complete</code> （或其它相似方法）执行时，
event loop 会把它包裹成一个
<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L23">Task</a> 。当协程开始执行或被唤醒时，Task 的
<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L164">_step</a>
方法会被调用，<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L180">这里</a> 它会调用 <code>coro.send(None)</code> 来执行/唤醒它包裹着的协程。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> exc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># We use the `send` method directly, because coroutines</span></span><br><span class="line">    <span class="comment"># don&#x27;t have `__iter__` and `__next__` methods.</span></span><br><span class="line">    result = coro.send(<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = coro.throw(exc)</span><br></pre></td></tr></table></figure></div>
<p>注意到这里将 <code>coro.send</code> 的结果赋值给了 <code>result</code>，那么它会返回什么呢？在我们这个例子中，协程链的最末尾是 <code>asyncio.sleep</code>，我们看看 <a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L469">它的实现</a>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">delay, result=<span class="literal">None</span>, *, loop=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Coroutine that completes after a given time (in seconds).&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> delay == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        loop = events.get_event_loop()</span><br><span class="line">    future = loop.create_future()</span><br><span class="line">    h = future._loop.call_later(delay,</span><br><span class="line">                                futures._set_result_unless_cancelled,</span><br><span class="line">                                future, result)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> future)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        h.cancel()</span><br></pre></td></tr></table></figure></div>
<p>这里它创建了一个 <code>future</code> 并为它注册了事件（<code>call_later</code>），最终调用了 <code>yield from future</code> 返回。它代表什么呢？我们已经假设你明白 <code>yield from</code> 的使用方法，这代表 Python 会首先调用 <code>future.__iter__</code> 函数，我们来看看<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/futures.py#L329">它长什么样</a>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.done():</span><br><span class="line">        <span class="variable language_">self</span>._asyncio_future_blocking = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="variable language_">self</span>  <span class="comment"># This tells Task to wait for completion.</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="variable language_">self</span>.done(), <span class="string">&quot;yield from wasn&#x27;t used with future&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.result()  <span class="comment"># May raise too.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> compat.PY35:</span><br><span class="line">    __await__ = __iter__ <span class="comment"># make compatible with &#x27;await&#x27; expression</span></span><br></pre></td></tr></table></figure></div>
<p>注意这里的 <code>yield self</code>！也就是说 future 在第一次执行到这里时，会暂停执行并返回它自己，由于 coroutine 中使用的都是 <code>yield from/await</code> （它们在接收的参数上有区别，但在本文的讨论中没有区别），因此这个值会一直向上传递，到 <code>Task._step</code>
函数的 <code>result = coro.send(None)</code> 这里，那我们来看看 <code>Task</code> 对 <code>result</code> 做了什么，重要的是<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L216">这一句</a>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result.add_done_callback(<span class="variable language_">self</span>._wakeup)</span><br></pre></td></tr></table></figure></div>
<p>也就是说 task(<code>print_sum</code>) 得到了最内层暂停的 <code>sleep</code> 生成的 future 并为该
future 注册了一个回调，使得在 <code>future.set_result</code> 被调用时，<code>task._wakeup</code> 会被调用。这部分的逻辑可以看<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/futures.py#L303">这里</a>。</p>
<p>我们再回过头来看看 <code>future.set_result</code> 会在什么时候被调用，在 <code>asyncio.sleep</code>
函数里，我们为 event loop 注册了一个回调函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = future._loop.call_later(delay,</span><br><span class="line">                            futures._set_result_unless_cancelled,</span><br><span class="line">                            future, result)</span><br></pre></td></tr></table></figure></div>
<p>那么这个 <a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/futures.py#L344">_set_result_unless_cancelled</a> 是这样的：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_set_result_unless_cancelled</span>(<span class="params">fut, result</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper setting the result only if the future was not cancelled.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> fut.cancelled():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    fut.set_result(result)</span><br></pre></td></tr></table></figure></div>
<p>因此，所有的流程应该是这样的：</p>
<img src="/2017/understand-python-asyncio/asyncio-flow.png" class="">
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>那么 asyncio 做为一个库，做了什么，没做什么？</p>
<ol>
<li>控制流的暂停与恢复，这是通过 Python 内部的 Generator（生成器）相关的功能实现的。</li>
<li>协程链，即把不同协程链链接在一起的机制。依旧是通过 Python 的内置支持，即
async/await，或者说是生成器的 yield from。</li>
<li>Event Loop，这个是 asyncio 实现的。它决定了我们能对什么事件进行异步操作，目前只支持定时器与网络 IO 的异步。</li>
<li>协程链的控制流恢复，即内部的协程暂停了，恢复时却需要从最外层的协程开始恢复。这是 asyncio 实现的内容。</li>
<li>其它的库支持，这里指的是像 <code>asyncio.sleep()</code> 这种协程链的最内层的协程，因此我们一般不希望自己去调用 event loop 注册/注销事件。</li>
</ol>
<p>因此，如果没有 asyncio，我们要实现相应的功能，主要的内容就是 Event Loop 及控制流的恢复，最后再加上一些好用的协程函数。</p>
<h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读"></a>扩展阅读</h2>
<ul>
<li><a href="https://www.slideshare.net/saghul/asyncio-internals">asyncio internals</a> 关于 asyncio 内部的一些机制。</li>
</ul>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>