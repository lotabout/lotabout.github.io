<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="今天来说说 Python 里的装饰器 (decorator)。它不难，但却几乎是 “精通” Python 的路上的第一道关卡。让我们来看看它到底是什么东西，为什么我们需要它。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Python Decorator(装饰器) | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/decorator/" rel="tag">decorator</a><a class="post-tag-noise-link" href="/tags/python/" rel="tag">python</a></div><div class="post-time">2017-09-29</div></div></div><div class="container post-header"><h1>Python Decorator(装饰器)</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">手写装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">2.</span> <span class="toc-text">@ 语法糖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">带参数的装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">我是谁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E4%B8%BA%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">类作为装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">7.</span> <span class="toc-text">扩展阅读</span></a></li></ol></details></div><div class="container post-content"><p>今天来说说 Python 里的装饰器 (decorator)。它不难，但却几乎是 “精通” Python 的路上的第一道关卡。让我们来看看它到底是什么东西，为什么我们需要它。</p>
<h2 id="手写装饰器"><a class="header-anchor" href="#手写装饰器"></a>手写装饰器</h2>
<p>现在我们要写一个函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>
<p>然后我们想看看运行的结果，于是写了几个 print 语句：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(10)&quot;</span>,       add(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(20, 30)&quot;</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(&#x27;a&#x27;, &#x27;b&#x27;)&quot;</span>, add(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results:</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># add(&#x27;a&#x27;, &#x27;b&#x27;) ab</span></span><br></pre></td></tr></table></figure></div>
<p>现在我们想看看测试这个函数的性能，于是我们加上这个代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(10)&quot;</span>,       add(<span class="number">10</span>))</span><br><span class="line">after = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time taken: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(after - before))</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(20, 30)&quot;</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">after = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time taken: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(after - before))</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(&#x27;a&#x27;, &#x27;b&#x27;)&quot;</span>, add(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">after = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time taken: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(after - before))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># time taken: 0.00017189979553222656</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># time taken: 9.751319885253906e-05</span></span><br><span class="line"><span class="comment"># add(&#x27;a&#x27;, &#x27;b&#x27;) ab</span></span><br><span class="line"><span class="comment"># time taken: 0.00012969970703125</span></span><br></pre></td></tr></table></figure></div>
<p>代码马上变得很复杂。但最重要的是，我们得写一堆代码（复制粘贴），程序员是懒惰的，所以我们就想到一些更简单的方法，与其写这么多次，我们可以只写一次代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">    before = time()</span><br><span class="line">    result = x + y</span><br><span class="line">    after = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;elapsed: &#x27;</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(10)&quot;</span>,       add(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(20, 30)&quot;</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(&#x27;a&#x27;, &#x27;b&#x27;)&quot;</span>, add(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results</span></span><br><span class="line"><span class="comment"># elapsed:  1.9073486328125e-06</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># elapsed:  9.5367431640625e-07</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># elapsed:  1.9073486328125e-06</span></span><br><span class="line"><span class="comment"># add(&#x27;a&#x27;, &#x27;b&#x27;) ab</span></span><br></pre></td></tr></table></figure></div>
<p>不论是代码的修改量还是代码的美观程度，都比之前的版本要好！</p>
<p>但是，现在我们写了另一个函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br></pre></td></tr></table></figure></div>
<p>我们必须再为 <code>sub</code> 函数加上和 <code>add</code> 相同的性能测试代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">    before = time()</span><br><span class="line">    result = x - y</span><br><span class="line">    after = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;elapsed: &#x27;</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div>
<p>作为一个懒惰的程序员，我们立马就发现了，有一个 “模式” 反复出现，即执行一个函数，并计算这个函数的执行时间。于是我们就可以把这个模式抽象出来，用函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func, x, y = <span class="number">10</span></span>):</span><br><span class="line">    before = time()</span><br><span class="line">    result = func(x, y)</span><br><span class="line">    after = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;elapsed: &quot;</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x, y = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(10)&quot;</span>, timer(add, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(20, 30)&quot;</span>, timer(add, <span class="number">20</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure></div>
<p>但这样还是很麻烦，因为我们得改到所有的测试用例，把 <code>add(20, 30)</code> 改成
<code>timer(add, 20, 30)</code>。于是我们进一步改进，让 timer 返回函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wraper</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">        before = time()</span><br><span class="line">        result = func(x, y)</span><br><span class="line">        after = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;elapsed: &quot;</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add = timer(add)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x, y = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">sub = timer(sub)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(10)&quot;</span>,       add(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add(20, 30)&quot;</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure></div>
<p>这里的最后一个问题是，我们的 timer 包装的函数可能有不同的参数，于是我们可以进一步用 <code>*args, **kwargs</code> 来传递参数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wraper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        before = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;elapsed: &quot;</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>timer</code> 函数就是一个 “装饰器”，它接受一个函数，并返回一个新的函数。在装饰器的内部，对原函数进行了“包装”。</p>
<p>注：上面的例子取自 <a href="https://youtu.be/7lmCu8wz8ro?t=45m25s">What Does it Take to Be an Expert At Python</a>。</p>
<h2 id="语法糖"><a class="header-anchor" href="#语法糖"></a>@ 语法糖</h2>
<p>上一节是一个懒惰的程序员用原生的 Python 写的装饰器，但在装饰器的使用上，用的是这个代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add = timer(add)        <span class="comment"># &lt;- notice this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x, y = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">sub = timer(sub)</span><br></pre></td></tr></table></figure></div>
<p>上面这个语句里，我们把 <code>add</code> 的名字重复了 3 次，如果函数改了名字，我们就得改 3
处。懒惰的程序员就想了一个更“好”的方法，提供了一个语法来替换上面的内容：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>
<p>这就是我们最常见的装饰器的形式了，这两种写法完全等价，只是 <code>@</code> 写法更简洁一些。</p>
<h2 id="带参数的装饰器"><a class="header-anchor" href="#带参数的装饰器"></a>带参数的装饰器</h2>
<p>我们知道下面两种代码是等价的：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func = dec(func)</span><br></pre></td></tr></table></figure></div>
<p>我们可以把它当成是纯文本的替换，于是可以是这样的：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dec(<span class="params">arg</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func = dec(arg)(func)</span><br></pre></td></tr></table></figure></div>
<p>这也就是我们看到的“带参数”的装饰器。可见，只要 <code>dec(arg)</code> 的返回值满足 “装饰器” 的定义即可。（接受一个函数，并返回一个新的函数）</p>
<p>这里举一个例子（<a href="https://foofish.net/python-decorator.html">来源</a>）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_logging</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">&quot;warn&quot;</span>:</span><br><span class="line">                logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">&quot;info&quot;</span>:</span><br><span class="line">                logging.info(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(<span class="params">level=<span class="string">&quot;warn&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&#x27;foo&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am %s&quot;</span> % name)</span><br></pre></td></tr></table></figure></div>
<p>先不管 <code>use_logging</code> 长什么样，先关心它的返回值 <code>decorator</code>，看到 <code>decorator</code>
本身是一个函数，并且参数是函数，返回值是函数，于是确认 <code>decorator</code> 是一个 “装饰器”。于是上面这种“带参数的装饰器”的作用也就很直接了。</p>
<h2 id="我是谁？"><a class="header-anchor" href="#我是谁？"></a>我是谁？</h2>
<p>上面介绍的方法让我们能正确地写出一个装饰器，但是实际使用时还有一个问题：函数信息的丢失：我们可以通过 <code>.__name__</code> 来查看函数的名称，用 <code>help(func)</code> 来查看
<code>func</code> 的 docstring：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add.__name__</span><br><span class="line">wrapper</span><br><span class="line">&gt;&gt;&gt; help(add)</span><br><span class="line">Help on function wraper in module __main__:</span><br><span class="line"></span><br><span class="line">wraper(*args, **kwargs)</span><br></pre></td></tr></table></figure></div>
<p>可以看到被装饰的函数，名称变成了装饰器返回的函数名 <code>wraper</code>，这对于函数的使用者来说很不方便。于是我们需要修改装饰器，保留原函数的名称：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wraper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        before = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;elapsed: &quot;</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    wraper.__name__ = func.__name__  <span class="comment"># &lt;- 保留原函数信息</span></span><br><span class="line">    wraper.__doc__ = func.__doc__    <span class="comment"># &lt;- 保留原函数信息</span></span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Add two numbers&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>
<p>此时再查看函数的信息：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add.__name__</span><br><span class="line">add</span><br><span class="line">&gt;&gt;&gt; help(add)</span><br><span class="line">Help on function add in module __main__:</span><br><span class="line"></span><br><span class="line">add(*args, **kwargs)</span><br><span class="line">    Add two numbers</span><br></pre></td></tr></table></figure></div>
<p>当然，函数的信息除了 <code>__name__</code> 与 <code>__doc__</code> 外，还有 <code>__module__</code>,
<code>__qualname__</code> 等，每次都手写很浪费时间。Python 提供了内置的装饰器 <code>wraps</code> 来装饰返回的函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>) </span><span class="comment"># &lt;- 用于保留原函数信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wraper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        before = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;elapsed: &quot;</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br></pre></td></tr></table></figure></div>
<p>这样一个完整的装饰器就新鲜出炉了。</p>
<h2 id="类作为装饰器"><a class="header-anchor" href="#类作为装饰器"></a>类作为装饰器</h2>
<p>如果说 Python 里一切都是对象的话，那函数怎么表示成对象呢？其实只需要一个类实现
<code>__call__</code> 方法即可。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="variable language_">self</span>._func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        before = time()</span><br><span class="line">        result = <span class="variable language_">self</span>._func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;elapsed: &quot;</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Add two numbers&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>
<p>也就是说把类的构造函数当成了一个装饰器，它接受一个函数作为参数，并返回了一个对象，而由于对象实现了 <code>__call__</code> 方法，因此返回的对象相当于返回了一个函数。因此该类的构造函数就是一个装饰器。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>装饰器中还有一些其它的话题，例如装饰器中元信息的丢失，如何在类及类的方法上使用装饰器等。但本文里我们主要目的是简单介绍装饰器的原因及一般的使用方法，能用上的地方就大胆地用上吧！</p>
<h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读"></a>扩展阅读</h2>
<ul>
<li>[PEP 0318 – Decorators for Functions and Methods](PEP 0318 – Decorators for Functions and Methods)</li>
<li><a href="http://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html">Python Decorator in Detail</a></li>
<li><a href="https://youtu.be/7lmCu8wz8ro?t=45m25s">What Does it Take to Be an Expert At Python</a></li>
<li><a href="https://foofish.net/python-decorator.html">理解 Python 装饰器看这一篇就够了</a></li>
<li><a href="http://blog.dscpl.com.au/2014/01/how-you-implemented-your-python.html">How you implemented your Python decorator is wrong</a></li>
</ul>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>