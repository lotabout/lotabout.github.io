<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;（这是两年前的笔记，现在把它搬到博客上，Underscore 版本：1.8.3）&lt;/p&gt;
&lt;p&gt;受 &lt;a href=&quot;http://web.jobbole.com/83872/&quot;&gt;这篇文章&lt;/a&gt; 的启发,萌生阅读 underscore.js 源码的念头,其中有许多不理解的地方,也是读了上述文章后才明白的.为了保持本文的完整性,也尽量按自己的理解进行注释. 不再提及上述引用文章.&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Underscore.js 源码阅读 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/javascript/" rel="tag">javascript</a><a class="post-tag-noise-link" href="/tags/underscore/" rel="tag">underscore</a></div><div class="post-time">2017-09-24</div></div></div><div class="container post-header"><h1>Underscore.js 源码阅读</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">全局定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">链式调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">链式调用的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%89%8D%E6%96%87"><span class="toc-number">3.</span> <span class="toc-text">接前文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">Collection 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数相关的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">Object 相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-number">7.</span> <span class="toc-text">相等判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">8.</span> <span class="toc-text">类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template"><span class="toc-number">9.</span> <span class="toc-text">template</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2"><span class="toc-number">10.</span> <span class="toc-text">写在后面</span></a></li></ol></details></div><div class="container post-content"><p>（这是两年前的笔记，现在把它搬到博客上，Underscore 版本：1.8.3）</p>
<p>受 <a href="http://web.jobbole.com/83872/">这篇文章</a> 的启发,萌生阅读 underscore.js 源码的念头,其中有许多不理解的地方,也是读了上述文章后才明白的.为了保持本文的完整性,也尽量按自己的理解进行注释. 不再提及上述引用文章.</p>
<span id="more"></span>
<h2 id="全局定义"><a class="header-anchor" href="#全局定义"></a>全局定义</h2>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></div>
<p>underscore.js 中通过自执行函数来防止打乱已有的命令空间中的变量.这样函数中定义的所有变量在外部都是不可见的.但是仍旧需要以某种方式来导出其中定义的变量.</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Establish the root object, `window` (`self`) in the browser, `global`</span></span><br><span class="line"><span class="comment">// on the server, or `this` in some virtual machines. We use `self`</span></span><br><span class="line"><span class="comment">// instead of `window` for `WebWorker` support.</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">&#x27;object&#x27;</span> &amp;&amp; self.<span class="property">self</span> === self &amp;&amp; self ||</span><br><span class="line">        <span class="keyword">typeof</span> <span class="variable language_">global</span> == <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">global</span>.<span class="property">global</span> === <span class="variable language_">global</span> &amp;&amp; <span class="variable language_">global</span> ||</span><br><span class="line">        <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure></div>
<p><code>root</code> 变量的作用是用来捕捉外部环境. 由于在自执行函数中,<code>this</code> 变量会被设置成
<code>Window</code> (浏览器中),所以我们可能通过为 <code>this</code> (即此处的<code>root</code>) 添加相应的变量来导出函数. 如:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exported_var</span> = <span class="number">10</span></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">exported_var</span>);</span><br><span class="line"><span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure></div>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Save bytes in the minified (but not gzipped) version:</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ArrayProto</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="title class_">ObjProto</span> = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure></div>
<p>为了减少 JS 代码在网络传输中占用的流量,通常要对其进行压缩,以减少源代码的大小.方法之一是替换现有的变量名.将 <code>Array.prototype</code> 赋值给新变量,就允许我们对该变量进行重命名.例如: <code>ArrayProto.toString =&gt; a.toString</code> 而若使用诸如
<code>Array.prototype.toString =&gt; a.prototype.toString</code> 则找不到该函数.</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create quick reference variables for speed access to core prototypes.</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  push = <span class="title class_">ArrayProto</span>.<span class="property">push</span>,</span><br><span class="line">  slice = <span class="title class_">ArrayProto</span>.<span class="property">slice</span>,</span><br><span class="line">  toString = <span class="title class_">ObjProto</span>.<span class="property">toString</span>,</span><br><span class="line">  hasOwnProperty = <span class="title class_">ObjProto</span>.<span class="property">hasOwnProperty</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All **ECMAScript 5** native function implementations that we hope to use</span></span><br><span class="line"><span class="comment">// are declared here.</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  nativeIsArray = <span class="title class_">Array</span>.<span class="property">isArray</span>,</span><br><span class="line">  nativeKeys = <span class="title class_">Object</span>.<span class="property">keys</span>,</span><br><span class="line">  nativeCreate = <span class="title class_">Object</span>.<span class="property">create</span>;</span><br></pre></td></tr></table></figure></div>
<p>以上同理.</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Naked function reference for surrogate-prototype-swapping.</span><br><span class="line">var Ctor = function()&#123;&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>Ctor</code> 函数只有一个用途,就是为了兼容老版本 JavaScript 的继承,即用来实现
<code>Object.create</code> 函数.</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubClass.prototype = Object.create(SuperClass.prototype)</span><br><span class="line">// 等价于</span><br><span class="line">var ctor = function () &#123;&#125;</span><br><span class="line">ctor.prototype = SuperClass.prototype;</span><br><span class="line">SubClass.prototype = new ctor();</span><br></pre></td></tr></table></figure></div>
<p><code>Ctor</code> 在之后的 <code>baseCreate</code> 函数中使用.</p>
<h2 id="链式调用"><a class="header-anchor" href="#链式调用"></a>链式调用</h2>
<p>因为涉及的内容较多,所以归成一节.</p>
<p>首先,我们要明白什么是链式调用.简单地说,链式调用是方便我们写代码的一个手段,看下面的例子:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = obj.method_O();</span><br><span class="line">var y = x.method_X();</span><br><span class="line">var z = y.method_Y();</span><br><span class="line">z.method_Z();</span><br></pre></td></tr></table></figure></div>
<p>上述写法需要许多中间变量,由于对象 <code>obj</code> 的 <code>method_O</code> 方法正好返回一个类 <code>X</code>
的对象(这里指的是返回的变量 <code>x</code> 需要有 <code>method_X</code> 方法),所以可以直接调用 <code>X</code> 的方法 <code>method_X()</code>. 以此类推.因此我们可以省略其中的中间变量,写成:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.method_O().method_X().method_Y().method_Z();</span><br></pre></td></tr></table></figure></div>
<p>要达到上述效果,我们便需要让 <code>method_O()</code> 方法在结束时返回一个类 <code>X</code> 的对象:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">method_O</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="title function_">X</span>(); <span class="comment">// 创建一个 `X` 的对象返回</span></span><br><span class="line">    一些逻辑处理</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>以此类推.上述方法是 Javascript 原生支持的.现在的问题在于,例如调用 <code>method_X</code>
方法返回了 <code>Y</code> 的对象,就再也无法使用类 <code>X</code> 中的方法了.例如:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var flattened_obj = _([[1,2]]).flatten();</span><br><span class="line">flattened_obj.each(...) // 出错</span><br></pre></td></tr></table></figure></div>
<p>上述代码中我们首先创建了一个 underscore.js 的对象 <code>_([[1,2]])</code> 目的是使用
underscore.js 为我们提供的丰富辅助函数.之后我们调用 underscore.js 中的
<code>flatten</code> 函数得到一个扁平化的数组: <code>[1,2]</code>. 之后我们想在其中调用
underscore.js 的 <code>each</code> 函数. 此时报错,提示没有该函数.故此时我们无法使用链式调用:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_([[1,2]]).flatten().each(...) // 报错</span><br></pre></td></tr></table></figure></div>
<p>故而 underscore.js 需要提供一些机制来包裹返回的对象,使之能访问 underscore.js
中的函数.</p>
<p>underscore.js 中通过 <code>_.chain(obj)</code> 来返回一个包裹的 <code>_</code> 对象;再对
underscore.js 中提供的所有函数做特殊的处理,使得:当调用函数的是包裹的对象时,返回的结果也是一个 <code>_</code> 的对象,而由于 underscore.js 中的所有函数都存放在 <code>_</code>
中,所以调用链中的每一步都可以访问 underscore.js 中的函数.</p>
<p>例如:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.chain([[1,2]]) instanceof _; // =&gt; true</span><br><span class="line">_.chain([[1,2]]).flatten() instanceof _; // =&gt; true</span><br><span class="line">_([[1,2]]).flatten() instanceof _; // =&gt; false</span><br></pre></td></tr></table></figure></div>
<h3 id="链式调用的实现"><a class="header-anchor" href="#链式调用的实现"></a>链式调用的实现</h3>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Create a safe reference to the Underscore object for use below.</span><br><span class="line">var _ = function(obj) &#123;</span><br><span class="line">  if (obj instanceof _) return obj;</span><br><span class="line">  if (!(this instanceof _)) return new _(obj);</span><br><span class="line">  this._wrapped = obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Add a &quot;chain&quot; function. Start chaining a wrapped Underscore object.</span><br><span class="line">_.chain = function(obj) &#123;</span><br><span class="line">  var instance = _(obj);</span><br><span class="line">  instance._chain = true;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>从上面的函数可以看到 <code>_</code> 函数生成一个新的 <code>_</code> 对象,并将输入的 <code>obj</code> 置于
<code>this._wrapped</code> 中. 而 <code>_.chain</code> 函数则再设置 <code>this._chain = true</code> 的标志.</p>
<p>单凭上述两个函数并没有实际用途,因此需要一个辅助函数:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Helper function to continue chaining intermediate results.</span><br><span class="line">var chainResult = function(instance, obj) &#123;</span><br><span class="line">  return instance._chain ? _(obj).chain() : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>该函数检查 <code>instacne</code> 本身是否设置了 <code>_chain</code> 标志,若是则将 <code>obj</code> 用 <code>chain()</code>
包裹,它的作用就是对调用链上函数返回的结果进行处理,如 <code>x.method()</code> 中,若设置了 <code>_chain</code> 标志,则将 <code>x.method()</code> 的返回结果再用 <code>chain()</code> 包裹.这样调用链中的每个函数返回的都是一个 <code>_</code> 的对象,因此也就能继续访问类 <code>_</code> 的方法了.</p>
<p>还有一个问题是,即使有以上函数, underscore.js 在定义新的函数时仍需手工调用
<code>chainResult</code> 函数,十分麻烦. 所以 underscore.js 又提供了另一个辅助函数,将所有已有的函数进行包裹:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Add your own custom functions to the Underscore object.</span><br><span class="line">_.mixin = function(obj) &#123;</span><br><span class="line">  _.each(_.functions(obj), function(name) &#123;</span><br><span class="line">    var func = _[name] = obj[name];</span><br><span class="line">    _.prototype[name] = function() &#123;</span><br><span class="line">      var args = [this._wrapped];</span><br><span class="line">      push.apply(args, arguments);</span><br><span class="line">      return chainResult(this, func.apply(_, args));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Add all of the Underscore functions to the wrapper object.</span><br><span class="line">_.mixin(_);</span><br></pre></td></tr></table></figure></div>
<p>该函数将 <code>obj</code> 中的所有函数替换成包裹后的函数.首先取出 <code>_</code> 对象中包裹的实际值, <code>push.apply(args, arguments)</code> 将该值与现有的函数参数结合,最后对原函数的返回值进行处理: <code>chainResult(this, func.apply(_, args))</code>.</p>
<p>还有一些函数单独作了处理,如 <code>pop</code>, <code>push</code>, <code>reverse</code>, 等等,此处不再详谈.</p>
<h2 id="接前文"><a class="header-anchor" href="#接前文"></a>接前文</h2>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Export the Underscore object for **Node.js**, with</span></span><br><span class="line"><span class="comment">// backwards-compatibility for their old module API. If we&#x27;re in</span></span><br><span class="line"><span class="comment">// the browser, add `_` as a global object.</span></span><br><span class="line"><span class="comment">// (`nodeType` is checked to ensure that `module`</span></span><br><span class="line"><span class="comment">// and `exports` are not HTML elements.)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> != <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !<span class="built_in">exports</span>.<span class="property">nodeType</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> != <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !<span class="variable language_">module</span>.<span class="property">nodeType</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) &#123;</span><br><span class="line">    <span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span> = _;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">_</span> = _;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  root.<span class="property">_</span> = _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Current version.</span></span><br><span class="line">_.<span class="property">VERSION</span> = <span class="string">&#x27;1.8.3&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<p>上文较好理解，判断不同的平台，导出 <code>_</code> 变量。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Internal function that returns an efficient (for current engines) version</span></span><br><span class="line"><span class="comment">// of the passed-in callback, to be repeatedly applied in other Underscore</span></span><br><span class="line"><span class="comment">// functions.</span></span><br><span class="line"><span class="keyword">var</span> optimizeCb = <span class="keyword">function</span>(<span class="params">func, context, argCount</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">switch</span> (argCount == <span class="literal">null</span> ? <span class="number">3</span> : argCount) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">call</span>(context, value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class="line">    <span class="comment">// made use of it.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">value, index, collection</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">call</span>(context, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">call</span>(context, accumulator, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> func.<span class="title function_">apply</span>(context, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>要理解 <code>optimizeCb</code> 的作用，需要先理解 underscore.js 提供的 context 切换的功能。我们首先查看 <code>_.each</code> 的文档：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">each: _.each(list, iteratee, [context]) Alias: forEach</span><br></pre></td></tr></table></figure></div>
<p>它接收额外的参数 <code>context</code>。而它的作用是在 <code>iteratee</code> 函数中将 <code>this</code> 指向
<code>context</code>。下面的是一个
<a href="http://stackoverflow.com/questions/4946456/underscore-js-eachlist-iterator-context-what-is-context">StackOverflow</a>
的例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someOtherArray = [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;patrick&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;w&quot;</span>];</span><br><span class="line"></span><br><span class="line">_.<span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数内， this “等于” someOtherArray</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">alert</span>( <span class="variable language_">this</span>[num] ); <span class="comment">// num is the value from the array being iterated</span></span><br><span class="line">                        <span class="comment">//    so this[num] gets the item at the &quot;num&quot; index of</span></span><br><span class="line">                        <span class="comment">//    someOtherArray.</span></span><br><span class="line">&#125;, someOtherArray);</span><br></pre></td></tr></table></figure></div>
<p>关于 context 的具体应用可以参考 <a href="https://medium.com/@jedschneider/the-secret-life-of-context-in-underscore-and-lodash-722ce3e24608#.l4kxy31d5">这篇文章</a></p>
<p>为了切换 <code>this</code> 的实际值，我们需要做如下的工作：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> origin = <span class="keyword">function</span>(<span class="params">arg ...</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> withContext = orig.<span class="title function_">call</span>(context, arg ...);</span><br></pre></td></tr></table></figure></div>
<p>即通过 <code>function.call(...)</code> 的方式来调用函数，以传入新的 <code>this</code> 值。而
<code>optimizeCb</code> 函数便是 underscore.js 内部用于完成这个转换的辅助函数。</p>
<p><code>optimizeCb</code> 函数中判断了目标函数 <code>func</code> 的参数个数，返回不同的函数，如果参数的个数不是 1～4，则采用通用的逻辑 <code>func.apply</code> 代替 <code>func.call</code>。似乎对当前的引擎而言，<code>func.call</code> 要稍快于 <code>func.apply</code>。 <a href="https://jsperf.com/function-calls-direct-vs-apply-vs-call-vs-bind/6">这个网页</a> 用于测试各种调用方式的效率，在我本机测试下 <code>call</code> 要稍快于（7％） <code>apply</code></p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A mostly-internal function to generate callbacks that can be applied</span></span><br><span class="line"><span class="comment">// to each element in a collection, returning the desired result — either</span></span><br><span class="line"><span class="comment">// `identity`, an arbitrary callback, a property matcher, or a property accessor.</span></span><br><span class="line"><span class="keyword">var</span> cb = <span class="keyword">function</span>(<span class="params">value, context, argCount</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.<span class="property">identity</span>;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isFunction</span>(value)) <span class="keyword">return</span> <span class="title function_">optimizeCb</span>(value, context, argCount);</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isObject</span>(value)) <span class="keyword">return</span> _.<span class="title function_">matcher</span>(value);</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">property</span>(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.<span class="property">iteratee</span> = <span class="keyword">function</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">cb</span>(value, context, <span class="title class_">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>cb</code> 几乎只被内部函数使用，用途是根据 <code>value</code> 的类型生成回调函数。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similar to ES6&#x27;s rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)</span></span><br><span class="line"><span class="comment">// This accumulates the arguments passed into an array, after a given index.</span></span><br><span class="line"><span class="keyword">var</span> restArgs = <span class="keyword">function</span>(<span class="params">func, startIndex</span>) &#123;</span><br><span class="line">  startIndex = startIndex == <span class="literal">null</span> ? func.<span class="property">length</span> - <span class="number">1</span> : +startIndex;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> - startIndex, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> rest = <span class="title class_">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      rest[index] = <span class="variable language_">arguments</span>[index + startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (startIndex) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.<span class="title function_">call</span>(<span class="variable language_">this</span>, rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>], rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>], <span class="variable language_">arguments</span>[<span class="number">1</span>], rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>(startIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class="line">      args[index] = <span class="variable language_">arguments</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    args[startIndex] = rest;</span><br><span class="line">    <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>restArgs</code> 也只在内部使用，它用来实现类似其它语言（及ES6）的 <code>rest</code> 参数。rest
参数的作用是将多余的参数以数组（Array）的方式保存为最后一个参数。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b, rest</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>) =&gt; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [],</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) =&gt; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>],</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) =&gt; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>, <span class="number">4</span>],</span><br></pre></td></tr></table></figure></div>
<p>当然，JavaScript 并不直接支持（ES6 前）这样的语法，所以 underscore.js 自己实现了一个（JavaScript 真强大啊！）。有了 <code>restArgs</code> 我的就能写成：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">orig</span>(<span class="params">a, b, rest</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="title function_">restArgs</span>(orig, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>) =&gt; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [],</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) =&gt; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>],</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) =&gt; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>, <span class="number">4</span>],</span><br></pre></td></tr></table></figure></div>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An internal function for creating a new object that inherits from another.</span></span><br><span class="line"><span class="keyword">var</span> baseCreate = <span class="keyword">function</span>(<span class="params">prototype</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.<span class="title function_">isObject</span>(prototype)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> <span class="title function_">nativeCreate</span>(prototype);</span><br><span class="line">  <span class="title class_">Ctor</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Ctor</span>;</span><br><span class="line">  <span class="title class_">Ctor</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>baseCreate</code> 与 <code>Object.create(...)</code> 等价，只是老版本的 JavaScript 没有
<code>Object.create</code> 函数，因此用它来做兼容。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper for collection methods to determine whether a collection</span></span><br><span class="line"><span class="comment">// should be iterated as an array or as an object.</span></span><br><span class="line"><span class="comment">// Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength</span></span><br><span class="line"><span class="comment">// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">MAX_ARRAY_INDEX</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = <span class="title function_">property</span>(<span class="string">&#x27;length&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="keyword">function</span>(<span class="params">collection</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length = <span class="title function_">getLength</span>(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">&#x27;number&#x27;</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= <span class="variable constant_">MAX_ARRAY_INDEX</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>isArrayLike</code> 用来判断一个 collection 是否是“类数组”的，那什么是“类数组”呢？需要满足两个条件：</p>
<ol>
<li>元素可以通过编号访问</li>
<li>元素个数通过 <code>length</code> 属性得到。</li>
</ol>
<p>“类数组” 不要求有数组（Array）提供的函数，如 <code>push</code>, <code>forEach</code> 及 <code>indexOf</code>. 例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arrayLikeCollection = &#123;&#125;</span><br><span class="line">arrayLikeCollection[0] = 0</span><br><span class="line">arrayLikeCollection[1] = 10;</span><br><span class="line">arrayLikeCollection[2] = 20;</span><br><span class="line">arrayLikeCollection[3] = 30;</span><br><span class="line">arrayLikeCollection.length = 4;</span><br></pre></td></tr></table></figure></div>
<p>所以，underscore.js 中定义的 <code>isArrayLike</code> 并没有真正检查条件1。条件 2 在先前的版本中是通过 <code>obj.length === +obj.length</code> 完成的，但似乎在某些情况下有 BUG，于是改成了当前的版本。</p>
<h2 id="collection-函数"><a class="header-anchor" href="#collection-函数"></a>Collection 函数</h2>
<p>本节中讲的是一些 collection 的辅助函数，如 <code>map</code>, <code>each</code>, <code>reduce</code> 等等。这些函数常用于函数式编程语言（如 Haskell）中，它们能更好地描述 collection 的一些操作。在编程中，我们要学习利用这些函数，学会从 collection 的整体角度进行思考，而不以 collection 中的元素作为处理对象。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The cornerstone, an `each` implementation, aka `forEach`.</span></span><br><span class="line"><span class="comment">// Handles raw objects in addition to array-likes. Treats all</span></span><br><span class="line"><span class="comment">// sparse array-likes as if they were dense.</span></span><br><span class="line">_.<span class="property">each</span> = _.<span class="property">forEach</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">  iteratee = <span class="title function_">optimizeCb</span>(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArrayLike</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="title function_">iteratee</span>(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="title function_">iteratee</span>(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the results of applying the iteratee to each element.</span></span><br><span class="line">_.<span class="property">map</span> = _.<span class="property">collect</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">  iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !<span class="title function_">isArrayLike</span>(obj) &amp;&amp; _.<span class="title function_">keys</span>(obj),</span><br><span class="line">      length = (keys || obj).<span class="property">length</span>,</span><br><span class="line">      results = <span class="title class_">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    results[index] = <span class="title function_">iteratee</span>(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>_.each</code> 函数是 collection 相关函数的基石，它的作用是将函数 <code>iteratee</code> 应用于
collection 中的每个元素，而 <code>map</code> 函数将 <code>iteratee</code> 每次调用的结果收集，以一个数组返回。</p>
<p>注意的是 <code>_.each</code> 与 <code>_.map</code> 同时支持以 “类数组”及 collection。在
underscore.js 中，通常将 object 抽象成 “广义的数组”。广义的数组包含一个键数组 <code>keys</code> 和一个值数组 <code>values</code>，它们一一对应，而由于它们是数组，也因此可以通过索引进行访问。对于普通的“类数组”，键数组中包含的就是对应值的索引。</p>
<p>所以，在涉及到索引相关的运算时，underscore.js 通常会先获取键数组，如 <code>_.map</code>
函数中的：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键数组</span></span><br><span class="line"><span class="keyword">var</span> keys = !<span class="title function_">isArrayLike</span>(obj) &amp;&amp; _.<span class="title function_">keys</span>(obj),</span><br><span class="line">length = (keys || obj).<span class="property">length</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br></pre></td></tr></table></figure></div>
<p>相应的，如果涉及值运算时，underscore.js 通常会先取得它的值数组：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj = <span class="title function_">isArrayLike</span>(obj) ? obj : _.<span class="title function_">values</span>(obj);</span><br></pre></td></tr></table></figure></div>
<p>这个模式中 underscore.js 中被多次运用。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a reducing function iterating left or right.</span></span><br><span class="line"><span class="keyword">var</span> createReduce = <span class="keyword">function</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">  <span class="comment">// Optimized iterator function as using arguments.length</span></span><br><span class="line">  <span class="comment">// in the main function will deoptimize the, see #1991.</span></span><br><span class="line">  <span class="keyword">var</span> reducer = <span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = !<span class="title function_">isArrayLike</span>(obj) &amp;&amp; _.<span class="title function_">keys</span>(obj),</span><br><span class="line">        length = (keys || obj).<span class="property">length</span>,</span><br><span class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">      memo = obj[keys ? keys[index] : index];</span><br><span class="line">      index += dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">      memo = <span class="title function_">iteratee</span>(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> initial = <span class="variable language_">arguments</span>.<span class="property">length</span> &gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reducer</span>(obj, <span class="title function_">optimizeCb</span>(iteratee, context, <span class="number">4</span>), memo, initial);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **Reduce** builds up a single result from a list of values, aka `inject`,</span></span><br><span class="line"><span class="comment">// or `foldl`.</span></span><br><span class="line">_.<span class="property">reduce</span> = _.<span class="property">foldl</span> = _.<span class="property">inject</span> = <span class="title function_">createReduce</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The right-associative version of reduce, also known as `foldr`.</span></span><br><span class="line">_.<span class="property">reduceRight</span> = _.<span class="property">foldr</span> = <span class="title function_">createReduce</span>(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
<p>与 <code>_.map</code> 一样，<code>_.reduce</code> 也是函数式编程语言中常用的辅助函数，上面的代码较乱，下面是一个更为简单的实现，用以演示核心的逻辑。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">coll, func, init_val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; coll.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    init_val = <span class="title function_">func</span>(init_val, coll[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> init_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="title function_">reduce</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">memo, num</span>)&#123; <span class="keyword">return</span> memo + num; &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure></div>
<p>这里的实现使用了两个闭包，<a href="http://web.jobbole.com/83872/">这篇文章</a> 认为这里闭包的作用是持久化变量。但我认为，这里将逻辑分成两个函数的目的，如注释所说的，是为了提高执行的效率。即使主逻辑中不包含对<code>arguments.length</code>的使用，但具体为何能提高效率，还有待学习。</p>
<p><code>_.find</code>, <code>_.filter</code>, <code>_.reject</code>, <code>_.every</code>, <code>_.some</code> 等函数中规中矩，唯一要注意的是它们是如何同时处理 collection 和“类数组”的情况。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> group = <span class="keyword">function</span>(<span class="params">behavior, partition</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = partition ? [[], []] : &#123;&#125;;</span><br><span class="line">    iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">    _.<span class="title function_">each</span>(obj, <span class="keyword">function</span>(<span class="params">value, index</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = <span class="title function_">iteratee</span>(value, index, obj);</span><br><span class="line">      <span class="title function_">behavior</span>(result, value, key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><code>group</code> 函数稍微难理解一些，它只在 underscore 内部使用。函数的主要复杂性来源于参数 <code>partition</code>，它用来标记 <code>group</code> 返回的函数返回结果的类型。我认为这是一个不恰当的抽象，一个更直观的抽象应该是（这里不考虑 context 切换的问题）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simpleGroup = <span class="keyword">function</span>(<span class="params">behavior</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj, iteratee</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">        _.<span class="title function_">each</span>(obj, <span class="keyword">function</span>(<span class="params">value, index</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> key = <span class="title function_">iteratee</span>(value, index, obj);</span><br><span class="line">            <span class="title function_">behavior</span>(result, value, key);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>即对于 <code>obj</code> 中的每个元素，通过调用 <code>iteratee</code> 函数得到一个分组的依据 <code>key</code>，再调用 <code>behavior</code> 对返回的结果进行组装。如 <code>_.groupBy</code> 函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Groups the object&#x27;s values by a criterion. Pass either a string attribute</span></span><br><span class="line"><span class="comment">// to group by, or a function that returns the criterion.</span></span><br><span class="line">_.<span class="property">groupBy</span> = <span class="title function_">group</span>(<span class="keyword">function</span>(<span class="params">result, value, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">has</span>(result, key)) result[key].<span class="title function_">push</span>(value); <span class="keyword">else</span> result[key] = [value];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>它的 <code>behavior</code> 函数就是将 <code>iteratee</code> 调用后的结果 <code>value</code> 按 <code>key</code> 进行分组。</p>
<p>上面提到，<code>group</code> 由于支持 <code>partition</code> 带来了额外的复杂性，具体的调用如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">partition</span> = <span class="title function_">group</span>(<span class="keyword">function</span>(<span class="params">result, value, pass</span>) &#123;</span><br><span class="line">  result[pass ? <span class="number">0</span> : <span class="number">1</span>].<span class="title function_">push</span>(value);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>
<p>而其实该函数可以由 <code>_.groupBy</code> 实现：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">partition</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = _.<span class="title function_">groupBy</span>(obj, iteratee);</span><br><span class="line">    <span class="keyword">return</span> [result[<span class="literal">true</span>], result[<span class="literal">false</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator function to create the findIndex and findLastIndex functions</span></span><br><span class="line"><span class="keyword">var</span> createPredicateIndexFinder = <span class="keyword">function</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">array, predicate, context</span>) &#123;</span><br><span class="line">    predicate = <span class="title function_">cb</span>(predicate, context);</span><br><span class="line">    <span class="keyword">var</span> length = <span class="title function_">getLength</span>(array);</span><br><span class="line">    <span class="keyword">var</span> index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">predicate</span>(array[index], index, array)) <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the first index on an array-like that passes a predicate test</span></span><br><span class="line">_.<span class="property">findIndex</span> = <span class="title function_">createPredicateIndexFinder</span>(<span class="number">1</span>);</span><br><span class="line">_.<span class="property">findLastIndex</span> = <span class="title function_">createPredicateIndexFinder</span>(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
<p><code>createPredicateIndexFinder</code> 根据指定的步长 <code>dir</code> 创建遍历的函数。而实际上它在被用来创建 <code>_.findIndex</code> 和 <code>_.findLastIndex</code>，但无疑，这增加了许多阅读上的复杂度。当一个逻辑没有被很多使用时，是否需要独立成一个单独的模块，值得思考与讨论。</p>
<h2 id="函数相关的函数"><a class="header-anchor" href="#函数相关的函数"></a>函数相关的函数</h2>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Determines whether to execute a function as a constructor</span></span><br><span class="line"><span class="comment">// or a normal function with the provided arguments</span></span><br><span class="line"><span class="keyword">var</span> executeBound = <span class="keyword">function</span>(<span class="params">sourceFunc, boundFunc, context, callingContext, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.<span class="title function_">apply</span>(context, args);</span><br><span class="line">  <span class="keyword">var</span> self = <span class="title function_">baseCreate</span>(sourceFunc.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">var</span> result = sourceFunc.<span class="title function_">apply</span>(self, args);</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isObject</span>(result)) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a function bound to a given object (assigning `this`, and arguments,</span></span><br><span class="line"><span class="comment">// optionally). Delegates to **ECMAScript 5**&#x27;s native `Function.bind` if</span></span><br><span class="line"><span class="comment">// available.</span></span><br><span class="line">_.<span class="property">bind</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">func, context, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.<span class="title function_">isFunction</span>(func)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Bind must be called on a function&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> bound = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">callArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">executeBound</span>(func, bound, context, <span class="variable language_">this</span>, args.<span class="title function_">concat</span>(callArgs));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>这里，我们首先回顾一下 <code>restArgs(func, startIndex)</code> 默认的使用方法。当参数
<code>startIndex</code> 为空时，它默认为 <code>func</code> 参数个数减一。所以有：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function orig(a, b, rest) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var test = restArgs(orig);</span><br><span class="line"></span><br><span class="line">test(1, 2) =&gt; a: 1, b: 2, rest: [],</span><br><span class="line">test(1, 2, 3) =&gt; a: 1, b: 2, rest: [3],</span><br><span class="line">test(1, 2, 3, 4) =&gt; a: 1, b: 2, rest: [3, 4],</span><br><span class="line">// 即此时 test 的多余参数都将收集成一个数组，作为 orig 调用里的 rest 参数</span><br></pre></td></tr></table></figure></div>
<p>知道了这点就不难看懂 <code>_.bind</code> 与 <code>executeBound</code>
函数。还有一点需要深追的是条件判断：<code>(!(callingContext instanceof boundFunc))</code>，它的作用是什么呢？</p>
<p>其实 <code>_.bind</code> 是要实现 ECMA5 中的 <code>Function.bind</code> 类似的功能，我们从 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">MDN</a> 上截取 <code>bind</code> 函数的一个使用实例：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">81</span>,</span><br><span class="line">  <span class="attr">getX</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">getX</span>(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="variable language_">module</span>.<span class="property">getX</span>;</span><br><span class="line"><span class="title function_">retrieveX</span>(); <span class="comment">// 9, because in this case, &quot;this&quot; refers to the global object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new function with &#x27;this&#x27; bound to module</span></span><br><span class="line"><span class="comment">//New programmers (like myself) might confuse the global var getX with module&#x27;s property getX</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.<span class="title function_">bind</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="comment">// var boundGetX = _.bind(retrieveX, module); // underscore.js 相应的替代方法。</span></span><br><span class="line"><span class="title function_">boundGetX</span>(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure></div>
<p>上述例子在执行时，<code>callingContext</code> 指向的是全局的 <code>Window</code>（浏览器中）。而只有当我们创建一个新的该函数的对象时，才会出现 <code>callingContent instanceof boundFunc</code> 的情形：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title function_">boundGetX</span>(); <span class="comment">// 或者</span></span><br><span class="line">boundGetX.<span class="title function_">apply</span>(instance);</span><br></pre></td></tr></table></figure></div>
<p>这是由 <code>new</code> 操作符的特性导致的。一般来说，获取一个函数（类）的一个实例“只能”通过 <code>new</code> 操作符来完成。<code>new func(...)</code> 执行了三个步骤：</p>
<ol>
<li>创建一个新的对象，该对象继承了 <code>func.prototype</code>；</li>
<li>以新创建的对象为 <code>this</code> 调用构造函数 <code>func</code>；</li>
<li>如果 <code>func</code> 有返回值则返回它，若没有，则返回第1步创建的对象。</li>
</ol>
<p>以代码来说就是：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(func.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="keyword">var</span> result = func.<span class="title function_">apply</span>(newObj, ...args...);</span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> object) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此，在上述例子中 <code>func.apply</code> 的过程中，<code>this</code> 指针必须要指向 <code>newObj</code> 而不能指向先前绑定的 <code>context</code> 值。所以 <code>executeBound</code> 判断了这一情况，并实现了类似 <code>new</code> 操作符的逻辑。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Partially apply a function by creating a version that has had some of its</span></span><br><span class="line"><span class="comment">// arguments pre-filled, without changing its dynamic `this` context. _ acts</span></span><br><span class="line"><span class="comment">// as a placeholder by default, allowing any combination of arguments to be</span></span><br><span class="line"><span class="comment">// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.</span></span><br><span class="line">_.<span class="property">partial</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">func, boundArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> placeholder = _.<span class="property">partial</span>.<span class="property">placeholder</span>;</span><br><span class="line">  <span class="keyword">var</span> bound = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="number">0</span>, length = boundArgs.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      args[i] = boundArgs[i] === placeholder ? <span class="variable language_">arguments</span>[position++] : boundArgs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (position &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>) args.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[position++]);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">executeBound</span>(func, bound, <span class="variable language_">this</span>, <span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">_.<span class="property">partial</span>.<span class="property">placeholder</span> = _;</span><br></pre></td></tr></table></figure></div>
<p><code>partial</code> 函数类似于科里化（curry），但功能更加强大。关键在于支持占位符。如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subtract = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123; <span class="keyword">return</span> b - a; &#125;;</span><br><span class="line">subFrom20 = _.<span class="title function_">partial</span>(subtract, _, <span class="number">20</span>);</span><br><span class="line"><span class="title function_">subFrom20</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =&gt; 15</span></span><br></pre></td></tr></table></figure></div>
<p>并且，由于要支持占位符，所以每次执行 <code>_.partial</code> 返回的函数，它的内部都要访问
<code>_.partial</code> 定义时的参数，无形中降低了一些效率。即：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">args[i] = boundArgs[i] === placeholder ? <span class="variable language_">arguments</span>[position++] : boundArgs[i];</span><br></pre></td></tr></table></figure></div>
<p><code>_.throttle</code> 和 <code>_.debounce</code> 函数都比较有意思。其中 <code>_.throttle</code> 将对一个函数进行包裹，返回一个函数，当我们迅速调用该函数时，在一个的时间范围内，至多被调用一次。可以实验以下代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inc = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;out&gt;&gt; &quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yyy = _.<span class="title function_">throttle</span>(inc, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迅速调用 n 次</span></span><br><span class="line"><span class="title function_">yyy</span>(); <span class="comment">// =&gt; out&gt;&gt; 1, 1</span></span><br><span class="line"><span class="title function_">yyy</span>(); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="title function_">yyy</span>(); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="title function_">yyy</span>(); <span class="comment">// 3s 后 =&gt; out&gt;&gt; 2, 2</span></span><br></pre></td></tr></table></figure></div>
<p>可以看到在 3s 内它只会被调用一次，且在这个时间范围内，调用直接返回前一次调用得到的结果，而不实际执行函数。</p>
<p><code>_.debound(func, wait)</code> 正好相反，如果执行了某个函数后，在 <code>wait</code> 时间内，若再调用该函数，则不执行它，并且将等待时间置零，直到 <code>wait</code> 时间后才继续执行。</p>
<h2 id="object-相关函数"><a class="header-anchor" href="#object-相关函数"></a>Object 相关函数</h2>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Keys in IE &lt; 9 that won&#x27;t be iterated by `for key in ...` and thus missed.</span></span><br><span class="line"><span class="keyword">var</span> hasEnumBug = !&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> nonEnumerableProps = [<span class="string">&#x27;valueOf&#x27;</span>, <span class="string">&#x27;isPrototypeOf&#x27;</span>, <span class="string">&#x27;toString&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;propertyIsEnumerable&#x27;</span>, <span class="string">&#x27;hasOwnProperty&#x27;</span>, <span class="string">&#x27;toLocaleString&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> collectNonEnumProps = <span class="keyword">function</span>(<span class="params">obj, keys</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nonEnumIdx = nonEnumerableProps.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">var</span> constructor = obj.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">var</span> proto = _.<span class="title function_">isFunction</span>(constructor) &amp;&amp; constructor.<span class="property"><span class="keyword">prototype</span></span> || <span class="title class_">ObjProto</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructor is a special case.</span></span><br><span class="line">  <span class="keyword">var</span> prop = <span class="string">&#x27;constructor&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">has</span>(obj, prop) &amp;&amp; !_.<span class="title function_">contains</span>(keys, prop)) keys.<span class="title function_">push</span>(prop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (nonEnumIdx--) &#123;</span><br><span class="line">    prop = nonEnumerableProps[nonEnumIdx];</span><br><span class="line">    <span class="keyword">if</span> (prop <span class="keyword">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.<span class="title function_">contains</span>(keys, prop)) &#123;</span><br><span class="line">      keys.<span class="title function_">push</span>(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>In IE &lt; 9, JScript will skip over any property in any object where there is a same-named property in the object’s prototype chain that has the DontEnum attribute.</p>
</blockquote>
<p>在 IE &lt; 9 中，若 object 中的某个属性在它的原形链 (prototype chain)
上有一个同名的，具有 DontEnum 特性的属性，则在 <code>for key in object</code>
枚举时将被忽略。</p>
<p>上述代码就是用来处理这个情形。注意代码中是如何手工判断 <code>obj</code> 是否含有键 <code>prop</code> ：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (prop <span class="keyword">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.<span class="title function_">contains</span>(keys, prop)) &#123;</span><br><span class="line">  keys.<span class="title function_">push</span>(prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An internal function for creating assigner functions.</span></span><br><span class="line"><span class="keyword">var</span> createAssigner = <span class="keyword">function</span>(<span class="params">keysFunc, defaults</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (defaults) obj = <span class="title class_">Object</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span> || obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="variable language_">arguments</span>[index],</span><br><span class="line">          keys = <span class="title function_">keysFunc</span>(source),</span><br><span class="line">          l = keys.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = keys[i];</span><br><span class="line">        <span class="keyword">if</span> (!defaults || obj[key] === <span class="keyword">void</span> <span class="number">0</span>) obj[key] = source[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend a given object with all the properties in passed-in object(s).</span></span><br><span class="line">_.<span class="property">extend</span> = <span class="title function_">createAssigner</span>(_.<span class="property">allKeys</span>);</span><br></pre></td></tr></table></figure></div>
<p><code>createAssigner</code> 看似较为复杂，但只要了解了它如何使用，那其中的逻辑也不难理解了。我们看 <code>_.extend</code> 的使用例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">extend</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;moe&#x27;</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">50</span>&#125;);</span><br><span class="line"><span class="comment">// =&gt; &#123;name: &#x27;moe&#x27;, age: 50&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>即，它以接收多个 object 作为参数，将第2个及之后的 object 的属性不断加入/覆盖到第一个 object 中并返回。因此 <code>createAssigner</code> 的核心就是两层循环，外层对参数进行迭代，内层对该参数的所有属性进行迭代。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Internal pick helper function to determine if `obj` has key `key`.</span></span><br><span class="line"><span class="keyword">var</span> keyInObj = <span class="keyword">function</span>(<span class="params">value, key, obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a copy of the object only containing the whitelisted properties.</span></span><br><span class="line">_.<span class="property">pick</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">obj, keys</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;, iteratee = keys[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isFunction</span>(iteratee)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys.<span class="property">length</span> &gt; <span class="number">1</span>) iteratee = <span class="title function_">optimizeCb</span>(iteratee, keys[<span class="number">1</span>]);</span><br><span class="line">    keys = _.<span class="title function_">allKeys</span>(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iteratee = keyInObj;</span><br><span class="line">    keys = <span class="title function_">flatten</span>(keys, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    obj = <span class="title class_">Object</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = keys.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    <span class="keyword">var</span> value = obj[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">iteratee</span>(value, key, obj)) result[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p><code>_.pick</code> 的复杂性也是由于额外的支持引起的。由于它可以接受一个函数作为参数，用作判断一个键是否选取的依据，因此它的代码中就要对参数 <code>keys</code> 是函数的情况进行判断。如果 <code>keys</code> 只是普通的键名，则 <code>iteratee</code> 退化为 <code>keyInObj</code>。额外的一点是，<code>_.pick</code> 除了接收函数作参数，同时还支持改变该函数的 <code>context</code>，函数中的</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (keys.<span class="property">length</span> &gt; <span class="number">1</span>) iteratee = <span class="title function_">optimizeCb</span>(iteratee, keys[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></div>
<p>就是起这个作用的。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invokes interceptor with the obj, and then returns obj.</span></span><br><span class="line"><span class="comment">// The primary purpose of this method is to &quot;tap into&quot; a method chain, in</span></span><br><span class="line"><span class="comment">// order to perform operations on intermediate results within the chain.</span></span><br><span class="line">_.<span class="property">tap</span> = <span class="keyword">function</span>(<span class="params">obj, interceptor</span>) &#123;</span><br><span class="line">  <span class="title function_">interceptor</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>前面提到了链式调用，<code>_.tap(func)</code> 的作用是将 <code>func</code> 应用到链式调用的中间结果。看 underscore.js 官方的例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">chain</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">200</span>])</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">num</span>) &#123; <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">  .<span class="title function_">tap</span>(alert)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">num</span>) &#123; <span class="keyword">return</span> num * num &#125;)</span><br><span class="line">  .<span class="title function_">value</span>();</span><br><span class="line">=&gt; <span class="comment">// [2, 200] (alerted)</span></span><br><span class="line">=&gt; [<span class="number">4</span>, <span class="number">40000</span>]</span><br></pre></td></tr></table></figure></div>
<p>从 <code>_.tap</code> 的实现中我们注意到，几乎所有 underscore.js 内置的函数的第一个参数都是 <code>obj</code>。而这样定义的函数我们又能以两种方式调用，如 <code>_.each</code> 函数：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">each</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="keyword">function</span> (<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x);&#125;); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">_</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x);&#125;); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// _([1,2,3]).each([3,4,5], function (x) &#123; console.log(x);&#125;); // 3 出错</span></span><br></pre></td></tr></table></figure></div>
<p>而 <code>_.each = function(obj, iteratee, context) &#123;...&#125;</code> 包含三个参数，为什么第 2
种调用可行，而第三种调用则出错呢？</p>
<p>原因是：1、2 两种调用的根本就不是一个函数！</p>
<p>首先要注意的是 <code>_</code> 变量本身是一个函数，而在 Javascript 中，函数同时承载着“类”的功能。因此要区分两种赋值方式：<code>_.attr = ...</code> 及 <code>_.prototype[attr] = ...</code>
第一种是为变量（对象）本身添加属性，第二种是为原型（类）添加属性。区分以下例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var underscore = function () &#123;&#125;</span><br><span class="line">underscore.attr = 10;</span><br><span class="line">underscore.prototype[&#x27;attr&#x27;] = 20;</span><br><span class="line"></span><br><span class="line">console.log(underscore.attr); // =&gt; 10</span><br><span class="line"></span><br><span class="line">var instance = new underscore();</span><br><span class="line">console.log(instance.attr); // =&gt; 20</span><br></pre></td></tr></table></figure></div>
<p>所以，当我们试图访问变量（对象）的某个属性时，它会首先寻找变量本身的属性，若不存在，则通过原型链（prototype chain）进行查找。</p>
<p>回到 <code>_.each</code> 的例子上，<code>_.each([1,2,3], func...)</code> 的调用的方法是变量（对象）
<code>_</code> 的属性，而 <code>_([1,2,3]).each(...)</code> 调用的是变量（对象）<code>_([1,2,3])</code> 的属性，而由于该变量并没有 <code>each</code> 属性，所以是调用的是 <code>_.prototype.each</code> 函数。</p>
<p>最后一个问题是 <code>_.prototype.each</code> 是在哪里设置的呢？答案是 <code>_.mixin</code> 函数中，上文已有讨论。</p>
<h2 id="相等判断"><a class="header-anchor" href="#相等判断"></a>相等判断</h2>
<p>（不知道 Equality 怎么翻译）</p>
<p>这部分是用来学习 Javascript 内部判等机制的好材料。这里只涉及一个函数 <code>eq</code> 用来深度判等，举例来说，两个数组相等，当且仅当包含同样个数，且每个元素都相等，由于元素可能还是数组，所以要递归（深度）地进行判断。</p>
<p>先来个链接：<a href="https://dorey.github.io/JavaScript-Equality-Table/">判等表格</a></p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eq = <span class="keyword">function</span>(<span class="params">a, b, aStack, bStack</span>) &#123;</span><br><span class="line">  <span class="comment">// Identical objects are equal. `0 === -0`, but they aren&#x27;t identical.</span></span><br><span class="line">  <span class="comment">// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).</span></span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line">  <span class="comment">// A strict comparison is necessary because `null == undefined`.</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> a === b;</span><br><span class="line">  <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">  <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</span><br><span class="line">  <span class="comment">// Exhaust primitive checks</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; type !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">deepEq</span>(a, b, aStack, bStack);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>可见，几乎所有的原子型数据都可以通过 <code>===</code> 进行判断。具体的判断方法参见 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-strict-equality-comparison">ECMA6
Strict Equality
Comparison</a></p>
<p>个人觉得使用 <code>x === y</code> 有几点值得一说：</p>
<ol>
<li><code>===</code> 会首先判断 <code>x</code> 与 <code>y</code> 的类型，若不相同，则返回 <code>false</code>。</li>
<li><code>===</code> 会判断 <code>x</code> 与 <code>y</code> 的值（原子类型），若相等，则返回 <code>true</code>，反之
<code>false</code>.</li>
<li><code>NaN</code> 不等于任意数字，另 <code>-0 === +0</code>。</li>
<li>对于非原子类型，当且仅当它们是指向同一个 object 时才 <code>===</code>。</li>
</ol>
<p>接下去的 <code>deepEq</code> 函数很长，我们逐步分析。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Internal recursive comparison function for `isEqual`.</span></span><br><span class="line">deepEq = <span class="keyword">function</span>(<span class="params">a, b, aStack, bStack</span>) &#123;</span><br><span class="line">  <span class="comment">// Unwrap any wrapped objects.</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> _) a = a.<span class="property">_wrapped</span>;</span><br><span class="line">  <span class="keyword">if</span> (b <span class="keyword">instanceof</span> _) b = b.<span class="property">_wrapped</span>;</span><br><span class="line">  <span class="comment">// Compare `[[Class]]` names.</span></span><br><span class="line">  <span class="keyword">var</span> className = toString.<span class="title function_">call</span>(a);</span><br><span class="line">  <span class="keyword">if</span> (className !== toString.<span class="title function_">call</span>(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">    <span class="comment">// Strings, numbers, regular expressions, dates, and booleans are compared by value.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;[object RegExp]&#x27;</span>:</span><br><span class="line">    <span class="comment">// RegExps are coerced to strings for comparison (Note: &#x27;&#x27; + /a/i === &#x27;/a/i&#x27;)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;[object String]&#x27;</span>:</span><br><span class="line">      <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is</span></span><br><span class="line">      <span class="comment">// equivalent to `new String(&quot;5&quot;)`.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> + a === <span class="string">&#x27;&#x27;</span> + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;[object Number]&#x27;</span>:</span><br><span class="line">      <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">      <span class="comment">// Object(NaN) is equivalent to NaN</span></span><br><span class="line">      <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">      <span class="comment">// An `egal` comparison is performed for other numeric values.</span></span><br><span class="line">      <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;[object Date]&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;[object Boolean]&#x27;</span>:</span><br><span class="line">      <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span></span><br><span class="line">      <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span></span><br><span class="line">      <span class="comment">// of `NaN` are not equivalent.</span></span><br><span class="line">      <span class="keyword">return</span> +a === +b;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>虽然在 <code>eq</code> 函数中判断了原子型数据，但由于我们可能创建了 underscore.js 的对象，如 <code>_(1)</code> 或 <code>_(&quot;abc&quot;)</code>，它们并不是原子型数据，所以上面的代码相当于自己实现了 <code>===</code> 的逻辑。根据 <code>a</code> <code>b</code>的类型进行相应的判断。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> areArrays = className === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<p>判断一个对象是否是 ‘Array’ 的正确方法。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!areArrays) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> b != <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Objects with different constructors are not equivalent, but `Object`s or `Array`s</span></span><br><span class="line">  <span class="comment">// from different frames are.</span></span><br><span class="line">  <span class="keyword">var</span> aCtor = a.<span class="property">constructor</span>, bCtor = b.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.<span class="title function_">isFunction</span>(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp;</span><br><span class="line">                           _.<span class="title function_">isFunction</span>(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor)</span><br><span class="line">                      &amp;&amp; (<span class="string">&#x27;constructor&#x27;</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">&#x27;constructor&#x27;</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上文代码应是有些 Bug，因为函数并非数组，所以会进入该 <code>if</code> 语句，但由于它们的类型并非 <code>object</code> 所以直接返回 <code>false</code>，即所有函数都不相等。考虑下面的测试用例：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">_.<span class="title function_">isEqual</span>(tmp, tmp); <span class="comment">// =&gt; false, 似乎有些版本的 underscore.js 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">_</span>(tmp);</span><br><span class="line"><span class="keyword">var</span> y = <span class="title function_">_</span>(tmp);</span><br><span class="line"></span><br><span class="line">_.<span class="title function_">isEqual</span>(x, y); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure></div>
<p>所以结果是所有的函数都不相等。</p>
<p>接下来重要的是下面这个代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Assume equality for cyclic structures. The algorithm for detecting cyclic</span></span><br><span class="line"><span class="comment">// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initializing stack of traversed objects.</span></span><br><span class="line"><span class="comment">// It&#x27;s done here since we only need them for objects and arrays comparison.</span></span><br><span class="line">aStack = aStack || [];</span><br><span class="line">bStack = bStack || [];</span><br><span class="line"><span class="keyword">var</span> length = aStack.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">while</span> (length--) &#123;</span><br><span class="line">  <span class="comment">// Linear search. Performance is inversely proportional to the number of</span></span><br><span class="line">  <span class="comment">// unique nested structures.</span></span><br><span class="line">  <span class="keyword">if</span> (aStack[length] === a) <span class="keyword">return</span> bStack[length] === b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面的代码是用来检测环形数据结构的，什么意思呢？就是对象中直接或间接地引用了自己本身，如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接引用</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a[<span class="number">0</span>] = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间接引用</span></span><br><span class="line"><span class="keyword">var</span> x = [];</span><br><span class="line"><span class="keyword">var</span> y = [x];</span><br><span class="line">x[<span class="number">0</span>] = y;</span><br></pre></td></tr></table></figure></div>
<p>上述检测环形数据的原理是：只要是环形数据，意味着在递归获取子结构时，在某个时候，得到的子结构会与之前访问过的某一结构完全一致。如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><span class="line">          ^         |</span><br><span class="line">          |         v</span><br><span class="line">          8 &lt;- 7 &lt;- 6</span><br></pre></td></tr></table></figure></div>
<p>在第一次访问 3 时，<code>aStack</code> 中保存了整个环（3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt;
…），所以第二次访问 3 时，仍然得到这个环（3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt;
…），此时，条件 <code>if(aStack[length] === a)</code> 就会通过，从而检测出该环。</p>
<h2 id="类型判断"><a class="header-anchor" href="#类型判断"></a>类型判断</h2>
<p>接下去是一些类型判断的函数如 <code>isArray</code>，<code>isObject</code> 等。主要的判断依据是
<code>toString</code> 函数。</p>
<p>根据 <a href="http://ecma262-5.com/ELS5_HTML.htm#Section_15.2.4.2">ELS6</a>，
<code>Object.prototype.toString</code> 会输出调用时 <code>this</code> 所指对象的内部 <code>[[Class]]</code> 属性。输出 <code>&quot;[object&quot; + [[Class]] + &quot;]&quot;</code>。</p>
<p>例如，在创建数组对象时，对象的 <code>[[Class]]</code> 属性会被设置为 <code>Array</code>，故对数组调用 <code>toString</code> 时将输出 <code>[object Array]</code>。</p>
<p>这里要注意的是 <code>toString</code> 的调用方法：<code>toString.call(obj)</code> 而非
<code>toString(obj)</code>。这就涉及到函数调用 <code>toString(obj)</code> 时 <code>this</code> 的值究竟是什么？它的规则如下：</p>
<p>函数是否由 <code>new</code> 调用？</p>
<ol>
<li>是 -&gt; <code>this</code> 指向新建的对象</li>
<li>否 -&gt; 函数是否由 <code>dot(.)</code> 进行调用？
<ol>
<li>是 -&gt; <code>this</code> 指向 dot 之前的对象</li>
<li>否 -&gt; <code>this</code> 指向全局对象 window</li>
</ol>
</li>
</ol>
<p>请参见 <a href="http://web.jobbole.com/84046/">图解 Javascript this 指向什么</a></p>
<p>测试下面代码的结果：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="string">&quot;abc&quot;</span>);      <span class="comment">// =&gt; &quot;[object Undefined]&quot;</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// =&gt; &quot;[object String]&quot;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="template"><a class="header-anchor" href="#template"></a>template</h2>
<p>模板函数是 underscore.js 中个人觉得最有趣的函数。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript micro-templating, similar to John Resig&#x27;s implementation.</span></span><br><span class="line"><span class="comment">// Underscore templating handles arbitrary delimiters, preserves whitespace,</span></span><br><span class="line"><span class="comment">// and correctly escapes quotes within interpolated code.</span></span><br><span class="line"><span class="comment">// NB: `oldSettings` only exists for backwards compatibility.</span></span><br><span class="line">_.<span class="property">template</span> = <span class="keyword">function</span>(<span class="params">text, settings, oldSettings</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!settings &amp;&amp; oldSettings) settings = oldSettings;</span><br><span class="line">  settings = _.<span class="title function_">defaults</span>(&#123;&#125;, settings, _.<span class="property">templateSettings</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Combine delimiters into one regular expression via alternation.</span></span><br><span class="line">  <span class="keyword">var</span> matcher = <span class="title class_">RegExp</span>([</span><br><span class="line">    (settings.<span class="property">escape</span> || noMatch).<span class="property">source</span>,</span><br><span class="line">    (settings.<span class="property">interpolate</span> || noMatch).<span class="property">source</span>,</span><br><span class="line">    (settings.<span class="property">evaluate</span> || noMatch).<span class="property">source</span></span><br><span class="line">  ].<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) + <span class="string">&#x27;|$&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compile the template source, escaping string literals appropriately.</span></span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> source = <span class="string">&quot;__p+=&#x27;&quot;</span>;</span><br><span class="line">  text.<span class="title function_">replace</span>(matcher, <span class="keyword">function</span>(<span class="params">match, <span class="built_in">escape</span>, interpolate, evaluate, offset</span>) &#123;</span><br><span class="line">    source += text.<span class="title function_">slice</span>(index, offset).<span class="title function_">replace</span>(escapeRegExp, escapeChar);</span><br><span class="line">    index = offset + match.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">escape</span>) &#123;</span><br><span class="line">      source += <span class="string">&quot;&#x27;+\n((__t=(&quot;</span> + <span class="built_in">escape</span> + <span class="string">&quot;))==null?&#x27;&#x27;:_.escape(__t))+\n&#x27;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interpolate) &#123;</span><br><span class="line">      source += <span class="string">&quot;&#x27;+\n((__t=(&quot;</span> + interpolate + <span class="string">&quot;))==null?&#x27;&#x27;:__t)+\n&#x27;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evaluate) &#123;</span><br><span class="line">      source += <span class="string">&quot;&#x27;;\n&quot;</span> + evaluate + <span class="string">&quot;\n__p+=&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adobe VMs need the match returned to produce the correct offset.</span></span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">  &#125;);</span><br><span class="line">  source += <span class="string">&quot;&#x27;;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a variable is not specified, place data values in local scope.</span></span><br><span class="line">  <span class="keyword">if</span> (!settings.<span class="property">variable</span>) source = <span class="string">&#x27;with(obj||&#123;&#125;)&#123;\n&#x27;</span> + source + <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  source = <span class="string">&quot;var __t,__p=&#x27;&#x27;,__j=Array.prototype.join,&quot;</span> +</span><br><span class="line">    <span class="string">&quot;print=function()&#123;__p+=__j.call(arguments,&#x27;&#x27;);&#125;;\n&quot;</span> +</span><br><span class="line">    source + <span class="string">&#x27;return __p;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> render;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    render = <span class="keyword">new</span> <span class="title class_">Function</span>(settings.<span class="property">variable</span> || <span class="string">&#x27;obj&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, source);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    e.<span class="property">source</span> = source;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> template = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> render.<span class="title function_">call</span>(<span class="variable language_">this</span>, data, _);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Provide the compiled source as a convenience for precompilation.</span></span><br><span class="line">  <span class="keyword">var</span> argument = settings.<span class="property">variable</span> || <span class="string">&#x27;obj&#x27;</span>;</span><br><span class="line">  template.<span class="property">source</span> = <span class="string">&#x27;function(&#x27;</span> + argument + <span class="string">&#x27;)&#123;\n&#x27;</span> + source + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> template;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>当然在使用之前要明白它的 <a href="http://underscorejs.org/#template">使用方法</a>。简单来说就是预先定义好模板，之后就可以用它来生成字符串。</p>
<p>模板中支持三种替换类型：值替换（interpolate）<code>&lt;%= ... %&gt;</code>；执行替换（evaluate） <code>&lt;% ... %&gt;</code> 及转义替换（escape） <code>&lt;%- ... %&gt;</code>。</p>
<p>下面的例子取自官网：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var compiled = _.template(&quot;hello: &lt;%= name %&gt;&quot;);</span><br><span class="line">compiled(&#123;name: &#x27;moe&#x27;&#125;);</span><br><span class="line">=&gt; &quot;hello: moe&quot;</span><br><span class="line"></span><br><span class="line">var template = _.template(&quot;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&quot;);</span><br><span class="line">template(&#123;value: &#x27;&lt;script&gt;&#x27;&#125;);</span><br><span class="line">=&gt; &quot;&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;&quot;</span><br><span class="line"></span><br><span class="line">var compiled = _.template(&quot;&lt;% print(&#x27;Hello &#x27; + epithet); %&gt;&quot;);</span><br><span class="line">compiled(&#123;epithet: &quot;stooge&quot;&#125;);</span><br><span class="line">=&gt; &quot;Hello stooge&quot;</span><br></pre></td></tr></table></figure></div>
<p>在试图看懂这段代码之前，我们先来了解 Javascript 中的
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval">eval</a>
函数。它的作用是将输入的字符串作为代码执行。举个“看似”有用的例子：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function gen_getter_setter(obj, field) &#123;</span><br><span class="line">    var field_path = obj + &#x27;.&#x27; + field;</span><br><span class="line"></span><br><span class="line">    return &#x27;function get_&#x27; + field + &#x27;() &#123;\n&#x27;</span><br><span class="line">        + &#x27;return &#x27; + field_path + &#x27;;\n&#x27;</span><br><span class="line">        + &#x27;&#125;\n&#x27;</span><br><span class="line">        + &#x27;function set_&#x27; + field + &#x27;(val) &#123;\n&#x27;</span><br><span class="line">        + field_path + &#x27;= val;\n&#x27;</span><br><span class="line">        + &#x27;&#125;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var object = &#123;a: 10&#125;;</span><br><span class="line"></span><br><span class="line">eval(gen_getter_setter(&#x27;object&#x27;, &#x27;a&#x27;));</span><br><span class="line"></span><br><span class="line">get_a(); // =&gt; 10</span><br><span class="line">set_a(20);</span><br><span class="line">object.a; // =&gt; 20</span><br></pre></td></tr></table></figure></div>
<p>例子中 <code>gen_getter_setter('object', 'a')</code> 生成的字符串如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;function get_a() &#123;</span><br><span class="line">return object.a;</span><br><span class="line">&#125;</span><br><span class="line">function set_a(val) &#123;</span><br><span class="line">object.a= val;</span><br><span class="line">&#125;&quot;</span><br></pre></td></tr></table></figure></div>
<p>也即我们生成了一个字符串，但字符串的内容完全符合 Javascript 的语法，因此
<code>eval</code> 可以根据 Javascript 的语法来解析该字符串。可以参考 Lisp 中的 Macro
（宏）。</p>
<p>说了这么多，可是代码里根本没有 <code>eval</code> 啊？好吧，是的，只是代码里通过 <code>new Function(...)</code> 创建新的函数对象时，也是传递字符串作为函数的函数体（函数的正文）。所以要明确的就是我们可以构建字符串，将字符串作为代码来执行。</p>
<p>因此，<code>_.template</code> 函数的大部分功能就是在构造 <code>render</code> 函数的函数体。我们先撇开对 <code>source</code> 的构建，先看 <code>render</code> 的框架部分（重新调整了格式）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">obj, _</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> __t,</span><br><span class="line">      __p = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      __j = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>,</span><br><span class="line">      print = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        __p += __j.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">with</span>(<span class="params">obj || &#123;&#125;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      the content <span class="keyword">of</span> source</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从上面的代码可以看出，生成的代码根据参数 <code>obj</code> 进行操作（具体操作未知），最终将代码存放在变量 <code>__p</code> 中返回。</p>
<p>所以具体的操作就要看 <code>source</code> 中的内容，而它又是根据模板字符串 <code>text</code> 生成的。下面再贴出主要逻辑的代码，以便于查看：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="string">&quot;__p+=&#x27;&quot;</span>;</span><br><span class="line">text.<span class="title function_">replace</span>(matcher, <span class="keyword">function</span>(<span class="params">match, <span class="built_in">escape</span>, interpolate, evaluate, offset</span>) &#123;</span><br><span class="line">  source += text.<span class="title function_">slice</span>(index, offset).<span class="title function_">replace</span>(escapeRegExp, escapeChar);</span><br><span class="line">  index = offset + match.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">escape</span>) &#123;</span><br><span class="line">    source += <span class="string">&quot;&#x27;+\n((__t=(&quot;</span> + <span class="built_in">escape</span> + <span class="string">&quot;))==null?&#x27;&#x27;:_.escape(__t))+\n&#x27;&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interpolate) &#123;</span><br><span class="line">    source += <span class="string">&quot;&#x27;+\n((__t=(&quot;</span> + interpolate + <span class="string">&quot;))==null?&#x27;&#x27;:__t)+\n&#x27;&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evaluate) &#123;</span><br><span class="line">    source += <span class="string">&quot;&#x27;;\n&quot;</span> + evaluate + <span class="string">&quot;\n__p+=&#x27;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adobe VMs need the match returned to produce the correct offset.</span></span><br><span class="line">  <span class="keyword">return</span> match;</span><br><span class="line">&#125;);</span><br><span class="line">source += <span class="string">&quot;&#x27;;\n&quot;</span>;</span><br></pre></td></tr></table></figure></div>
<p>这段代码将匹配 <code>_.template</code> 支持的三种模式，即 <code>&lt;%= ... %&gt;</code>、<code>&lt;% .. %&gt;</code>及<code>&lt;%- .. %&gt;</code> 并将其替换成相应的代码。</p>
<p>例如：对于模板字符串 <code>&quot;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&quot;</code>，则会进入 <code>escape</code> 分支（注意会调用不止一次），生成相应的代码放在之前的上下文中如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">obj, _</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> __t,</span><br><span class="line">      __p = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      __j = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>,</span><br><span class="line">      print = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        __p += __j.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the content of source</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">with</span>(<span class="params">obj || &#123;&#125;</span>) &#123;</span><br><span class="line">      __p += <span class="string">&#x27;&lt;b&gt;&#x27;</span></span><br><span class="line">        + ((__t = (value)) == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : _.<span class="built_in">escape</span>(__t))</span><br><span class="line">        + <span class="string">&#x27;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;/b&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>理解 <code>_.template</code> 代码要注意区分生成字符串的代码与生成的字符串。相信跟着例子调试几次就能够完全理解它了。</p>
<h2 id="写在后面"><a class="header-anchor" href="#写在后面"></a>写在后面</h2>
<p>阅读 underscore.js 的代码花费了许多时间，但受益颇丰。通过深究其中的许多细节，让我对 Javascript 的原理有了更深的理解和掌握。相信只要读者静下心来，仔细钻研其中的细节，定有收获。</p>
<p>文章写得匆忙，也只是作为个人的笔记，若有错误不足之处，敬请批评指正。</p>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>