<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java 提供了动态修改字节码的能力，而 Java Agent 提供了外挂修改的能力，能不动已有的 jar 包，在运行时动态修改 jar 内的字节码。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Java Agent 入门教程 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Agent/" rel="tag">Agent</a><a class="post-tag-noise-link" href="/tags/Java/" rel="tag">Java</a></div><div class="post-time">2024-05-05</div></div></div><div class="container post-header"><h1>Java Agent 入门教程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-agent-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Java Agent 项目结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#premain-%E4%B8%8E-agentmain"><span class="toc-number">1.1.</span> <span class="toc-text">premain 与 agentmain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#manifest"><span class="toc-number">1.2.</span> <span class="toc-text">MANIFEST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pom-xml"><span class="toc-number">1.3.</span> <span class="toc-text">pom.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-attach"><span class="toc-number">1.4.</span> <span class="toc-text">动态加载 Attach</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instrumentation"><span class="toc-number">2.</span> <span class="toc-text">Instrumentation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instrumentation-api"><span class="toc-number">2.1.</span> <span class="toc-text">Instrumentation API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classfiletransformer"><span class="toc-number">2.2.</span> <span class="toc-text">ClassFileTransformer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asm-api-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">ASM API 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#asm-%E6%A0%B8%E5%BF%83-api"><span class="toc-number">3.1.</span> <span class="toc-text">ASM 核心 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6-type-descriptor"><span class="toc-number">3.2.</span> <span class="toc-text">类型描述符(Type Descriptor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%8F%8F%E8%BF%B0%E7%AC%A6-method-descriptor"><span class="toc-number">3.3.</span> <span class="toc-text">方法描述符(Method Descriptor)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E6%89%93%E5%8D%B0%E6%AF%8F%E4%B8%AA%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">示例-打印每个调用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#println-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">4.1.</span> <span class="toc-text">println 字节码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-transformer"><span class="toc-number">4.2.</span> <span class="toc-text">自定义 Transformer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">4.3.</span> <span class="toc-text">组装与测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>Java 提供了动态修改字节码的能力，而 Java Agent 提供了外挂修改的能力，能不动已有的 jar 包，在运行时动态修改 jar 内的字节码。</p>
<p>本文会从零构建一个 Java Agent，让Jar 包在运行时打印每一个调用的方法名，其中涉及到 Java Agent 的整体结构，ASM 库的基础操作，文章较长，建议跟着走一遍。</p>
<h2 id="java-agent-项目结构"><a class="header-anchor" href="#java-agent-项目结构"></a>Java Agent 项目结构</h2>
<p>先创建如下目录结构：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── me</span><br><span class="line">        │       └── lotabout</span><br><span class="line">        │           └── Launcher.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── META-INF</span><br><span class="line">                └── MANIFEST.MF</span><br></pre></td></tr></table></figure></div>
<h3 id="premain-与-agentmain"><a class="header-anchor" href="#premain-与-agentmain"></a>premain 与 agentmain</h3>
<p>我们知道常规 Java 程序的入口是 <code>main</code> 函数，而 Java Agent 在不同的架构模式下有不同的入口<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<ul>
<li>静态加载入口为 <code>premain</code>：如 <code>java -javaagent:my-agent.jar -jar app.jar</code>，在启动 Jar 包时指定要加载的 agent，权限较高。</li>
<li>动态加载入口为 <code>agentmain</code>：已经通过 <code>java -jar app.jar</code> 等方式运行的 JVM，可以动态 Attach 后加载 Agent，权限较低，如无法新增属性、方法等。</li>
</ul>
<p>两个方法定义如下（定义放在哪个类中都可以，下面会在 <code>MANIFEST.MF</code> 文件中声明）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><figcaption><span>Launcher.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.lotabout;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数中的 <code>agentArgs</code> 是传递给 Agent 的参数。例如这样调用 <code>java -javaagent:my-agent.jar=my-agent-args app.jar</code>，则 <code>my-agent.jar</code> 中的
<code>premain</code> 函数中的 <code>agentArgs</code> 参数的值，就是字符串 <code>&quot;my-agent-args&quot;</code>。</li>
<li>参数中的 <code>Instrumentation</code> 是 Java 提供的修改字节码的 API. 通常 Java Agent
作者的任务，就是利用 <code>Instrumentation</code> 定位到希望修改的类并做出修改。</li>
</ul>
<p>另外容易踩坑的一点是，调用 <code>Instrumentation.addTransformer</code> 添加的 transformer
默认只对“ <strong>未来加载的类</strong> ”才会生效。而动态加载(<code>agentmain</code>)通常是在应用程序启动后才加载，就会出现添加的 transformer 不生效的情况。对静态加载(<code>premain</code>)则一般不会有这个问题，因为它是在 <code>main</code> 函数之前加载的，</p>
<p>动态加载(<code>agentmain</code>) 如果想修改 <code>main</code> 中就已经加载的类，则需要在添加
transformer 再调用<code>Instrumentation#retransformClasses</code> 对已加载的类执行转换才能生效。</p>
<h3 id="manifest"><a class="header-anchor" href="#manifest"></a>MANIFEST</h3>
<p>上面提到 <code>premain</code> 和 <code>agentmain</code> 可以定义在任何类中，那 JVM 怎么知道去哪找呢？我们需要在 jar
包的 <code>MANIFEST.MF</code> 文件<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 中指定 agent 的入口类是什么，以及 agent
会有哪些能力：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight text"><figcaption><span>MANIFEST.MF</span></figcaption><table><tr><td class="code"><pre><span class="line">Premain-Class: me.lotabout.Launcher # 静态加载(premain) Agent 时的入口类</span><br><span class="line">Agent-Class: me.lotabout.Launcher   # 动态加载(agentmain) Agent 时的入口类</span><br><span class="line">Can-Redefine-Classes: true          # 该 Agent 能否重新定义类</span><br><span class="line">Can-Retransform-Classes: true       # 该 Agent 能否修改已有类</span><br><span class="line">Can-Set-Native-Method-Prefix: true  # 是否允许修改 Native 方法的前缀</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Premain-Class: 静态加载(premain) Agent 时的入口类</li>
<li>Agent-Class: 动态加载(agentmain) Agent 时的入口类</li>
<li>Can-Redefine-Classes: 该 Agent 能否重新定义类</li>
<li>Can-Retransform-Classes: 该 Agent 能否修改已有类</li>
<li>Can-Set-Native-Method-Prefix: 是否允许修改 Native 方法的前缀。Native 方法不是字节码实现的，Agent 修改不了它的逻辑。通常修改 Native 是Proxy 的做法，把原有的 Native 方法重命名，新建同名的 Java 方法来调用老方法。此时需要修改
Native 方法前缀的能力。</li>
</ul>
<h3 id="pom-xml"><a class="header-anchor" href="#pom-xml"></a>pom.xml</h3>
<p>打包本身也比较烦，比如 maven 打包时需要指定 <code>MANIFEST.MF</code> 路径，示例如下：</p>
<div class="noise-code-block" style="--code-block-max-height:300px"><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.lotabout<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-agent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ow2.asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line marked">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ow2.asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line marked">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm-tree<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line marked">            <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span>src/main/resources/META-INF/MANIFEST.MF<span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>我们额外引入了 <code>asm</code> 与 <code>asm-tree</code> 库，我们后面要用它们来操作字节码。</p>
<p><code>mvn clean package</code> 后得到 <code>target/my-agent-1.0-SNAPSHOT-jar-with-dependencies.jar</code>，之后就可以用
<code>java -javaagent:target/my-agent-1.0-SNAPSHOT-jar-with-dependencies.jar -jar app.jar</code> 来调用了。这个名字太长了，后面我们写命令时会简写成 <code>my-agent.jar</code>。</p>
<h3 id="动态加载-attach"><a class="header-anchor" href="#动态加载-attach"></a>动态加载 Attach</h3>
<p>假设我们已经执行了 <code>java -jar app.jar</code>，希望加载 <code>my-agent.jar</code>，要怎么做？需要利用 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.attach/module-summary.html">Attach API</a>。</p>
<ol>
<li>先得到 <code>app.jar</code> 进程的 PID，并 attach 得到 <code>app.jar</code> 的 <code>VirtualMachine</code> 实例：<code>VirtualMachine vm = VirtualMachine.attach(PID);</code></li>
<li>调用 <code>VirtualMachine#loadAgent(&quot;my-agent.jar&quot;)</code> 让 <code>app.jar</code> 进程加载 agent</li>
</ol>
<p>为了方便上述操作，我们可以把这段逻辑写到 <code>Launcher</code> 的 <code>main</code> 函数中：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pid</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Launcher.class.getProtectionDomain().getCodeSource().getLocation().getPath();</span><br><span class="line">    <span class="type">VirtualMachine</span> <span class="variable">vm</span> <span class="operator">=</span> VirtualMachine.attach(pid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        vm.loadAgent(path);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        vm.detach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>再在 <code>MANIFEST.MF</code> 中增加一行：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main-Class: me.lotabout.Launcher</span><br></pre></td></tr></table></figure></div>
<p>现在就可以使用 <code>java -jar my-agent.jar &lt;目标 PID&gt;</code> 来动态加载 agent 了。注意此时调用的是 agent 的 <code>agentmain</code> 方法。</p>
<h2 id="instrumentation"><a class="header-anchor" href="#instrumentation"></a>Instrumentation</h2>
<p>上节中的内容是建立 java agent 项目结构，目标是产出一个能被 JVM 识别的Agent。接下来的任务是找到 <code>app.jar</code> 中感兴趣的类并修改这些类的字节码。这些工作都要基于
JDK 提供的 Instrumentation API。</p>
<h3 id="instrumentation-api"><a class="header-anchor" href="#instrumentation-api"></a>Instrumentation API</h3>
<p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.instrument/java/lang/instrument/Instrumentation.html">Instrumentation</a>
的核心抽象是 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a>
，对字节码的修改逻辑都在这个接口中实现，而 Instrumentation 接口则是用来添加、删除 transformer 的。Instrumentation 常见的使用流程（伪代码）为:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于未加载的类，addTransformer 后就能生效</span></span><br><span class="line">instrument.addTransformer(myTransformer, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 对于已经加载的类，需要调用 retransformClasses 来触发修改</span></span><br><span class="line"><span class="keyword">for</span> (Class clazz: instrument.getAllLoadedClasses()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needToTransform(clazz)) &#123;</span><br><span class="line">        instrument.retransformClasses(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>Instrumentation</code> 的一些常用接口定义如下：</p>
<ul>
<li><code>getAllLoadedClasses()</code> 获取所有加载的类，得到数组后我们可以自己筛选出关心的类</li>
<li><code>redefineClasses(ClassDefinition... definitions)</code> 使用参数中的类定义重新定义类</li>
<li><code>retransformClasses(Class&lt;?&gt;... classes)</code> 使用添加的 transformers 修改指定的类</li>
<li><code>addTransformer(ClassFileTransformer transformer)</code> 注册 <code>transformer</code></li>
<li><code>removeTransformer(ClassFileTransformer transformer)</code> 注销 <code>transformer</code></li>
</ul>
<h3 id="classfiletransformer"><a class="header-anchor" href="#classfiletransformer"></a>ClassFileTransformer</h3>
<p>对字节码的修改逻辑需要定义在
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a>
的 <code>transform</code> 方法中，方法的签名如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] transform(ClassLoader loader,</span><br><span class="line">                 String className,</span><br><span class="line">                 Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                 ProtectionDomain protectionDomain,</span><br><span class="line">                 <span class="type">byte</span>[] classfileBuffer)</span><br><span class="line">    <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>通常我们会使用各种信息来过滤掉不感兴趣的类（不想修改就直接直接返回原字节码）。</li>
<li>核心输入输出是 <code>class</code> 二进制流(<code>byte[]</code>)，即 transformer 假定字节码的修改是在二进制层面进行的。</li>
</ul>
<p>直接修改类的二进制不是人能干的事，于是通常会使用一些库把 <code>byte[]</code> 转成一些库定义的结构，操作后再转回 <code>byte[]</code> 返回。下面是常用的一些库：</p>
<ul>
<li><a href="https://asm.ow2.io/">asm</a> JDK 内部也用了它，性能好，但 API 的抽象层度很低</li>
<li><a href="https://www.javassist.org">javaassist</a> API 的抽象比 ASM 更高，更适合普通用户，支持直接写 Java 源码</li>
<li><a href="https://bytebuddy.net">bytebuddy</a> API 抽象度更高，例如有专门的 builder 来创建 Agent</li>
</ul>
<h2 id="asm-api-简介"><a class="header-anchor" href="#asm-api-简介"></a>ASM API 简介</h2>
<h3 id="asm-核心-api"><a class="header-anchor" href="#asm-核心-api"></a>ASM 核心 API</h3>
<p>ASM<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 有两套 API： Event-Based 和 Tree-Based。简单来说 Event-Based 就是 visitor
模式，用户需要定义各种元素的 visitor，扫描字节码中过程中遇到什么元素就调用对应元素的 visitor；Tree-Based 可以理解成先扫一遍字节码组装成一棵树，再对这棵树做后续编辑、修改等操作。Event-Based API 性能更好但 Tree-Based API 更容易理解和使用。</p>
<p>ASM 的整体流程是 <code>byte[] -&gt; ClassNode -&gt; (修改) -&gt; byte[]</code>，其中<code>ClassNode</code> 是
Tree-Based API 对“类”的抽象。基于 Tree-Based API 来修改字节码的 pattern 如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassNode</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNode</span>(ASM4);                       <span class="comment">// 定义解析后的类</span></span><br><span class="line"><span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(origin_classfile_bytes); <span class="comment">// 创建 reader 读取原始字节码</span></span><br><span class="line">cr.accept(cn, <span class="number">0</span>);                                         <span class="comment">// 解析原始字节码，填充到 cn 中</span></span><br><span class="line">...                                                       <span class="comment">// 这里可对 cn 做修改</span></span><br><span class="line"><span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);                      <span class="comment">// 创建 writer</span></span><br><span class="line">cn.accept(cw);                                            <span class="comment">// 把修改后的 cn 写回到 writer</span></span><br><span class="line"><span class="type">byte</span>[] b = cw.toByteArray();                              <span class="comment">// 把 writer 中的字节码转成 byte[]</span></span><br></pre></td></tr></table></figure></div>
<p>对 <code>ClassNode</code> 的操作，最常见的是遍历其中的 <code>cn.methods</code> 属性来遍历该类的所有方法，之后通过修改 <code>method.instructions</code> 来修改字节码。</p>
<h3 id="类型描述符-type-descriptor"><a class="header-anchor" href="#类型描述符-type-descriptor"></a>类型描述符(Type Descriptor)</h3>
<p>ASM 中对于类型的描述有自己的一套规则，严格来说也不是 ASM 自创的，而是 JVM Spec
中定义的<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，定义如下：</p>
<table>
<thead>
<tr>
<th>Java Type</th>
<th>Type Descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean</code></td>
<td><code>Z</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>B</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>C</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>D</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>F</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>I</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>J</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>S</code></td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td><code>int[]</code></td>
<td><code>[I</code></td>
</tr>
<tr>
<td><code>Object[][]</code></td>
<td><code>[[Ljava/lang/Object;</code></td>
</tr>
</tbody>
</table>
<p>基本类型的描述符就是对应的大写字母（除了 <code>boolean</code> 用 <code>Z</code> 代替，因为字母冲突）；其中类的描述符是 <code>L&lt;classname&gt;;</code> 的格式，数组的描述符是 <code>[&lt;array_type&gt;</code>，如果多维就以此类推。</p>
<h3 id="方法描述符-method-descriptor"><a class="header-anchor" href="#方法描述符-method-descriptor"></a>方法描述符(Method Descriptor)</h3>
<p>方法描述符是一个字符串，格式为 <code>(&lt;参数类型1&gt;&lt;参数类型2&gt;...)&lt;返回类型&gt;</code>，其中参数类型就是上节的类型描述符，如果返回 <code>void</code> 则写 <code>V</code>，例如：</p>
<table>
<thead>
<tr>
<th>源文件中类的定义</th>
<th>类型描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void m(int i, float f)</code></td>
<td><code>(IF)V</code></td>
</tr>
<tr>
<td><code>int m(Object o)</code></td>
<td><code>(Ljava/lang/Object;)I</code></td>
</tr>
<tr>
<td><code>int[] m(int i, String s)</code></td>
<td><code>(ILjava/lang/String;)[I</code></td>
</tr>
<tr>
<td><code>Object m(int[] i)</code></td>
<td><code>([I)Ljava/lang/Object;</code></td>
</tr>
</tbody>
</table>
<h2 id="示例-打印每个调用的方法"><a class="header-anchor" href="#示例-打印每个调用的方法"></a>示例-打印每个调用的方法</h2>
<p>由于 ASM 的 API 基本是直接添加字节码，但如果对字节码不熟悉其实很难直接写出，于是一种方法是先用 javap 等工具把一个类的字节码反编译出来，再根据反编译的结果来写。</p>
<h3 id="println-字节码"><a class="header-anchor" href="#println-字节码"></a>println 字节码</h3>
<p>例如我们想在方法被调用时执行如下代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&gt;&gt; calling Method: &lt;my_method&gt;&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>于是我们先写一个类，然后用 <code>javap -c</code> 来反编译：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt; calling Method: &lt;my_method&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>执行如下命令：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ javac Hello.java</span><br><span class="line">$ javap -c Hello</span><br><span class="line">Compiled from <span class="string">&quot;Hello.java&quot;</span></span><br><span class="line">class Hello &#123;</span><br><span class="line">  Hello();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       4: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     <span class="comment">#2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       3: ldc           <span class="comment">#3                  // String &gt;&gt; calling Method: &lt;my_method&gt;</span></span><br><span class="line">       5: invokevirtual <span class="comment">#4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       8: <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>比较关键的是 <code>getstatic</code>, <code>ldc</code>, <code>invokevirtual</code> 这三个指令，分别代表先获取
<code>System.out</code>，再加载常量 <code>&quot;&gt;&gt; calling Method: &lt;my_method&gt;&quot;</code>，最后调用
<code>println</code> 三个操作。</p>
<h3 id="自定义-transformer"><a class="header-anchor" href="#自定义-transformer"></a>自定义 Transformer</h3>
<p>接下来我们定义一个 <code>ClassFileTransformer</code> 来实现上述逻辑：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><figcaption><span>MyTransformer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefixOfclassToPrint</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyTransformer</span><span class="params">(String prefixOfclassToPrint)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.prefixOfclassToPrint = prefixOfclassToPrint.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">      ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!className.startsWith(<span class="built_in">this</span>.prefixOfclassToPrint)) &#123;</span><br><span class="line">      <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;transforming class: &quot;</span> + className);</span><br><span class="line">    <span class="type">ClassNode</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNode</span>(Opcodes.ASM4);</span><br><span class="line">    <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(classfileBuffer);</span><br><span class="line">    cr.accept(cn, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method : cn.methods) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;patching Method: &quot;</span> + method.name);</span><br><span class="line">      <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsnList</span>();</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">FieldInsnNode</span>(Opcodes.GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">LdcInsnNode</span>(<span class="string">&quot;&gt;&gt; calling Method: &quot;</span> + method.name));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">MethodInsnNode</span>(Opcodes.INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>,</span><br><span class="line">          <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">      method.instructions.insert(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">    cn.accept(cw);</span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>第 6 行要注意在 transformer 中拿到的类，包名是以 <code>/</code> 分隔的，而
<code>Instrument.getAllLoadedClasses()</code> 中拿到的类名是以 <code>.</code> 分隔的我们允许传入的参数是以 <code>.</code> 分隔的，所以需要转换一下。</li>
<li>第 12~14 行是过滤掉不感兴趣的类，不感兴趣的类直接返回原字节码。</li>
<li>第 16~19, 32~34 行是上文所说的 ASM 框架代码，反序列化二进制和序列化二进制的过程。</li>
<li>第 21 行开始遍历该类的所有方法，每个方法都插入我们的逻辑</li>
<li>第 24~28 行是插入字节码的逻辑，对应上小节说的 <code>getstatic</code>, <code>ldc</code>,
<code>invokevirtual</code> 三个指令。其中也看到了类型描述符、方法描述符的使用。</li>
<li>第 29 行是把生成的字节码 “insert” 到方法的字节码中，“insert” 是在最前面插入</li>
</ul>
<h3 id="组装与测试"><a class="header-anchor" href="#组装与测试"></a>组装与测试</h3>
<p>最后，我们在 <code>premain</code> 和 <code>agentmain</code> 中注册我们的 <code>MyTransformer</code>，最终 <code>Launcher</code> 类如下：</p>
<div class="noise-code-block" style="--code-block-max-height:300px"><figure class="highlight java"><figcaption><span>Launcher.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, AttachNotSupportedException,</span><br><span class="line">             AgentLoadException, AgentInitializationException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pid</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Launcher.class.getProtectionDomain().getCodeSource().getLocation().getPath();</span><br><span class="line">    <span class="type">VirtualMachine</span> <span class="variable">vm</span> <span class="operator">=</span> VirtualMachine.attach(pid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vm.loadAgent(path, prefix);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      vm.detach();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line">      <span class="keyword">throws</span> UnmodifiableClassException &#123;</span><br><span class="line">    inst.addTransformer(<span class="keyword">new</span> <span class="title class_">MyTransformer</span>(agentArgs), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> clazz : inst.getAllLoadedClasses()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (inst.isModifiableClass(clazz) &amp;&amp; clazz.getName().startsWith(agentArgs)) &#123;</span><br><span class="line">        inst.retransformClasses(clazz);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line">      <span class="keyword">throws</span> UnmodifiableClassException &#123;</span><br><span class="line">    premain(agentArgs, inst);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefixOfclassToPrint</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTransformer</span><span class="params">(String prefixOfclassToPrint)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prefixOfclassToPrint = prefixOfclassToPrint.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!className.startsWith(<span class="built_in">this</span>.prefixOfclassToPrint)) &#123;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;transforming class: &quot;</span> + className);</span><br><span class="line">      <span class="type">ClassNode</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNode</span>(Opcodes.ASM4);</span><br><span class="line">      <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(classfileBuffer);</span><br><span class="line">      cr.accept(cn, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> method : cn.methods) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;patching Method: &quot;</span> + method.name);</span><br><span class="line">        <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsnList</span>();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">FieldInsnNode</span>(Opcodes.GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">LdcInsnNode</span>(<span class="string">&quot;&gt;&gt; calling Method: &quot;</span> + method.name));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">MethodInsnNode</span>(Opcodes.INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">        method.instructions.insert(list);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">      cn.accept(cw);</span><br><span class="line">      <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后有两种调用方式（类名前缀的包名以 <code>.</code> 分隔）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ java -javaagent:my-agent-1.0-SNAPSHOT-jar-with-dependencies.jar=&lt;类名前缀&gt; -jar app.jar</span><br><span class="line">$ java -jar my-agent-1.0-SNAPSHOT-jar-with-dependencies.jar &lt;PID&gt; &lt;类名前缀&gt;</span><br></pre></td></tr></table></figure></div>
<p>对于如下的示例 <code>Hello</code> 类：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      outer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以在运行时挂上 agent 来看到输出:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ javac Hello.java</span><br><span class="line">$ java -javaagent:my-agent-1.0-SNAPSHOT-jar-with-dependencies.jar=Hello Hello</span><br><span class="line">transforming class: Hello</span><br><span class="line">patching Method: &lt;init&gt;</span><br><span class="line">patching Method: main</span><br><span class="line">patching Method: outer</span><br><span class="line">patching Method: test</span><br><span class="line">&gt;&gt; calling Method: main</span><br><span class="line">&gt;&gt; calling Method: outer</span><br><span class="line">&gt;&gt; calling Method: test</span><br><span class="line">Hello world!</span><br><span class="line">&gt;&gt; calling Method: outer</span><br><span class="line">&gt;&gt; calling Method: test</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure></div>
<p>可以看到我们成功的在每个方法调用时打印了一行信息。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>本文介绍了 Java Agent 的基本代码结构，简单介绍了 ASM 库来修改字节码的方法，最后给出了示例，让 Agent 能动态修改类的方法，在方法开始处打印一行信息。</p>
<p>另外一些常见的字节码修改场景可以参考 ASM 的文档或使用其它字节码修改库。例如希望打印每个方法的返回值，理论上需要遍历每个方法的字节码，找到 <code>return</code> 指令，然后在该指令前插入打印指令，这种常见 pattern 通常都有库封装好，可以直接使用。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这里的机制在 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.instrument/java/lang/instrument/package-summary.html">java.lang.instrument 文档</a> 中有详细说明 <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>manifest 的属性参考 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.instrument/java/lang/instrument/package-summary.html">java.lang.instrument 文档</a> <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://asm.ow2.io/asm4-guide.pdf">ASM 官方教程</a> <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.4">JVM Spec: Field Descriptors</a> <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>