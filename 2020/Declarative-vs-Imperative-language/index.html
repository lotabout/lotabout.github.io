<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="声明式(declarative)是结果导向的，命令式(imperative)是过程导向的。它们都有自己适用的场景和局限，于是现实中的编程语言常常都有两者的身影。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>声明式(declarative) vs 命令式(imperative) | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Declarative/" rel="tag">Declarative</a><a class="post-tag-noise-link" href="/tags/Imperative/" rel="tag">Imperative</a><a class="post-tag-noise-link" href="/tags/Programming-Paradigm/" rel="tag">Programming Paradigm</a></div><div class="post-time">2020-05-06</div></div></div><div class="container post-header"><h1>声明式(declarative) vs 命令式(imperative)</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F-vs-%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">命令式 vs 声明式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%B8%8D%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">声明式不是万能的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E9%87%8C%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">命令式里的声明式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>声明式(declarative)是结果导向的，命令式(imperative)是过程导向的。它们都有自己适用的场景和局限，于是现实中的编程语言常常都有两者的身影。</p>
<h2 id="命令式-vs-声明式"><a class="header-anchor" href="#命令式-vs-声明式"></a>命令式 vs 声明式</h2>
<blockquote>
<p><strong>Declarative programming</strong> is a programming paradigm … that expresses the
logic of a computation without describing its control
flow<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
</blockquote>
<blockquote>
<p><strong>Imperative programming</strong> is a programming paradigm that uses statements that
change a program’s state<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
</blockquote>
<p>例如我们有一个用户列表，用 python 查找手机号为 <code>183</code> 开头的用户，可能会这么写：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_users</span>():</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">        <span class="keyword">if</span> user[<span class="string">&#x27;phone&#x27;</span>].startswith(<span class="string">&#x27;183&#x27;</span>):</span><br><span class="line">            ret.append(user)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></div>
<p>这是命令式的作法，给出通向目标的每个指令；而声明式语言则直接描述目标，如 SQL 可能会这么写：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">where</span> phone <span class="keyword">like</span> <span class="string">&#x27;183%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<p>显然，声明式语言对用户更友好，用户可以关心更少的细节。更重要的是：它允许多种底层实现方式，保持目标不变的同时不断优化，如上例中 SQL 的实现既可以遍历所有的用户，也可以使用索引来加速查找。</p>
<p>而命令式的好处自然是它的表达能力了，图灵完备的语言可以表达任何的可计算问题。</p>
<h2 id="声明式不是万能的"><a class="header-anchor" href="#声明式不是万能的"></a>声明式不是万能的</h2>
<p>声明式语言直接描述目标，那怎么才能清晰地描述目标呢？有时候也需要命令式的帮助。</p>
<p>考虑下面的命令式的伪代码要如何用 SQL 实现：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goods = (SELECT * from goods)</span><br><span class="line">for g in goods:</span><br><span class="line">    #&gt;&gt; 注意在内层循环中可以引用外层表 goods 的字段</span><br><span class="line">    evaluations = (SELECT * from evaluations e where e.good_id == g.id)</span><br><span class="line">    if len(evaluations) &gt; 3:</span><br><span class="line">        print(g, len(evaluations))</span><br></pre></td></tr></table></figure></div>
<p>会发现使用常规的 <code>JOIN</code> 语义，很难实现上述目标。子查询里是无法引用其它查询的字段的，这本身是一种优势，数据库内部可以对 JOIN 的实现进行优化，但同时也限制了对复杂 JOIN 语义的表达。</p>
<p>后来 SQL 里加了个关键字：<code>LATERAL</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，用来表达子查询的先后顺序，上例可以写成：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> g.<span class="operator">*</span>, e.num <span class="keyword">FROM</span> goods <span class="keyword">as</span> g</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">LATERAL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(ev.id) <span class="keyword">as</span> num <span class="keyword">FROM</span>  evaluation <span class="keyword">AS</span> ev <span class="keyword">WHERE</span> ev.goods_id<span class="operator">=</span>g.id</span><br><span class="line">) <span class="keyword">AS</span> e <span class="keyword">ON</span> <span class="literal">TRUE</span> <span class="keyword">WHERE</span> num <span class="operator">&gt;</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<p>有了 <code>LATERAL</code>，在 LATERAL 后的子查询就可以引用前面子查询的变量。那么<code>LATERAL</code>
算是声明式还是命令式？似乎变得模糊了，一方面它依旧是表达目标，是声明式；另一方面它似乎指定了操作步骤（先查 goods，再查 evaluations）属于命令式。</p>
<p><strong>当描述的目标变复杂时，声明式语言也不可避免变得更命令式，通过描述过程来描述更多细节</strong></p>
<h2 id="命令式里的声明式"><a class="header-anchor" href="#命令式里的声明式"></a>命令式里的声明式</h2>
<p>传统上的一些编程语言，如 C/C++、Java、Python 等都被认为是命令式语言。用这些语言编写程序时的确是一条语句一条语句导向最终的目标。但这些编程语言与声明式的界限也并非泾渭分明。</p>
<p>除了机器码，包括汇编在内的几乎其它所有编程语言都有“函数”的概念。通过将语句组装成函数，无论是在使用还是阅读上，似乎都可以认为是在指定目标，是声明式的。例如要计算 Fibonacci 数列的第 N 个数，如果已经有现成的库，我们也只需要写 <code>x = fibonacci(n)</code>，似乎也不是“命令式”吧。</p>
<p>另外，编程语言的一些语法糖也加强了我们“声明目标”的能力，如 Python 的装饰器
(decorator) <code>@dataclass</code>，“声明”式地定义一个类为数据类，Java 的 lombok 库也有
<code>@Data</code> 这样的注解(annotation)实现类似的功能。</p>
<p><strong>通过适当的封装、组件化，命令式也可以变成目标导向，变得更加“声明式”</strong></p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>声明式使用方便、容易理解、易于优化，但表达能力有限，要表达更复杂的目标时，它往往也在向命令式靠拢了。而命令式里很多重复性的工作，也可以通过适当地组件化部分变成声明式。这样看来，一门语言是声明式还是命令式，似乎取决于我们接触的细节多少。</p>
<p>生活中，大老板决定路线，小老板决定方案，螺丝钉具体落实，不也类似嘛。</p>
<p>在我们设计语言、库时，尽可能地将接口设计得“声明式”，暴露更少的细节给用户，不仅能让用户用得开心，也方便内部的扩展、优化。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="https://reactjs.org/">https://reactjs.org/</a> React 的设计理念：Declarative view</li>
<li>《Design Data-Intensive Applications》第二章，说明 CSS/XSL 是声明式的语言</li>
<li><a href="https://djyde.github.io/blog/declarative-programming-is-the-future/">未来属于声明式编程</a> 对声明式编程语言的思考</li>
<li><a href="https://cloud.tencent.com/developer/article/1080886">命令式和声明式，哪个才是你的菜</a> 描述了声明式、命令式的一些差别</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Declarative_programming">https://en.wikipedia.org/wiki/Declarative_programming</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Imperative_programming">https://en.wikipedia.org/wiki/Imperative_programming</a> <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p>出现在 <a href="https://ronsavage.github.io/SQL/sql-99.bnf.html">ISO/IEC
7095:199</a> 标准中，Postgre、
Flink 支持，其它本人没查全 <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>