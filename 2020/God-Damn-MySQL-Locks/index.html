<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="MySQL &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html&quot;&gt;官方文档
&lt;/a&gt;给出了不同类型语句的加锁情形，但我觉得&lt;a href=&quot;https://www.jianshu.com/p/13f5777966dd&quot;&gt;这个总结&lt;/a&gt;更到位，因此想结合文章的几种情形，结合 InnoDB Monitor Output 做分析。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>MySQL 加锁机制验证记录 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/MySQL/" rel="tag">MySQL</a><a class="post-tag-noise-link" href="/tags/isolation-level/" rel="tag">isolation level</a><a class="post-tag-noise-link" href="/tags/lock/" rel="tag">lock</a></div><div class="post-time">2020-12-13</div></div></div><div class="container post-header"><h1>MySQL 加锁机制验证记录</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF-innodb-monitor"><span class="toc-number">1.</span> <span class="toc-text">开启 InnoDB Monitor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%83%85%E5%BD%A2%E4%B8%8B%E5%8A%A0%E9%94%81%E9%AA%8C%E8%AF%81"><span class="toc-number">2.</span> <span class="toc-text">不同情形下加锁验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE-rc"><span class="toc-number">2.1.</span> <span class="toc-text">主键 + RC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-rc"><span class="toc-number">2.2.</span> <span class="toc-text">唯一索引 + RC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-rc"><span class="toc-number">2.3.</span> <span class="toc-text">非唯一索引 + RC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%B4%A2%E5%BC%95-rc"><span class="toc-number">2.4.</span> <span class="toc-text">无索引 + RC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE-rr"><span class="toc-number">2.5.</span> <span class="toc-text">主键 + RR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-rr"><span class="toc-number">2.6.</span> <span class="toc-text">唯一索引 + RR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-rr"><span class="toc-number">2.7.</span> <span class="toc-text">非唯一索引 + RR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%B4%A2%E5%BC%95-rr"><span class="toc-number">2.8.</span> <span class="toc-text">无索引 + RR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%AA%8C%E8%AF%81"><span class="toc-number">3.</span> <span class="toc-text">死锁验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>MySQL <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">官方文档
</a>给出了不同类型语句的加锁情形，但我觉得<a href="https://www.jianshu.com/p/13f5777966dd">这个总结</a>更到位，因此想结合文章的几种情形，结合 InnoDB Monitor Output 做分析。</p>
<p>文章是验证过程的记录，全文比较长，建议结合目录查看感兴趣的部分。</p>
<h2 id="开启-innodb-monitor"><a class="header-anchor" href="#开启-innodb-monitor"></a>开启 InnoDB Monitor</h2>
<p>参考：<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-enabling-monitors.html">官方文档</a></p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output<span class="operator">=</span><span class="keyword">ON</span>; <span class="comment">-- 开启输出</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks<span class="operator">=</span><span class="keyword">ON</span>; <span class="comment">-- 开启锁信息输出</span></span><br></pre></td></tr></table></figure></div>
<p>注意这些选项在 mysql 重启后会恢复默认值。接下来使用命令查看信息：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure></div>
<p>样例输出，我们只关心锁相关的内容：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 929632, ACTIVE 27 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 1309, OS thread handle 123145430310912, query id 9179 localhost root</span><br><span class="line">TABLE LOCK table `test`.`id_pk_rc` trx id 929632 lock mode IX</span><br><span class="line">RECORD LOCKS space id 1813 page no 3 n bits 72 index PRIMARY of table `test`.`id_pk_rc` trx id 929632 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000e2f60; asc     /`;;</span><br><span class="line"> 2: len 7; hex 4c000002222e83; asc L   &quot;. ;;</span><br><span class="line"> 3: len 1; hex 63; asc c;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>“page no 3 n bits 72” 代表在第 3 页的记录上，lock bitmap 共 72 位</li>
<li>“index PRIMARY of …” 代表锁在某个索引上，PRIMARY 代表锁在主键上</li>
<li>“lock_mode X” 锁模式，X 代表互斥，锁模式可以参数官方文档 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html">InnoDB
Locking</a></li>
<li>“locks rec but not gap” 代表记录锁，“locks gap before rec” 代表间隙锁，没有说明则代表 Next Key Lock</li>
<li>“heap no 4” 代表记录的序号，0 代表 infimum 记录、1 代表 supremum 记录，用户记录从 2 开始</li>
<li>PHYSICAL RECORD 后面的内容是索引记录的内存结构，通常没办法直接阅读</li>
</ul>
<p>这个记录里没法直接看出锁住了哪些记录。一种方法是通过 <code>select * from information_schema.innodb_locks \G;</code> 查看抢锁没抢到的信息，为了查看记录，在测试时可以另开一个会话，用诸如 <code>SELECT * FROM ... WHERE ... FOR UPDATE</code> 来抢锁，这样就可以看出锁在哪个记录上了。样例输出：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock_id     | 929771:1817:4:4</span><br><span class="line">lock_trx_id | 929771</span><br><span class="line">lock_mode   | X</span><br><span class="line">lock_type   | RECORD</span><br><span class="line">lock_table  | `test`.`id_si_rc`</span><br><span class="line">lock_index  | id_si</span><br><span class="line">lock_space  | 1817</span><br><span class="line">lock_page   | 4</span><br><span class="line">lock_rec    | 4</span><br><span class="line">lock_data   | 5, 3 -- 注意这里是数据标识</span><br></pre></td></tr></table></figure></div>
<p>还有一个工具好用的工具
<a href="https://github.com/jeremycole/innodb_ruby">innodb_ruby</a> 可以用来解析 MySQL 的静态文件。Monitor 日志里我们知道是哪个页的哪条记录，可以使用innodb_ruby 来找到对应的记录。（不过不建议在生产上使用）</p>
<h2 id="不同情形下加锁验证"><a class="header-anchor" href="#不同情形下加锁验证"></a>不同情形下加锁验证</h2>
<p>我们会考查 <code>DELETE FROM t1 WHERE id = 5</code> 语句在不同情形下的加锁情况，通过构造数据、执行语句、查看 Monitor 日志来验证加锁的机制。</p>
<h3 id="主键-rc"><a class="header-anchor" href="#主键-rc"></a>主键 + RC</h3>
<p>结论：只对 ID = 5 这条记录加 Record Lock</p>
<img src="/2020/God-Damn-MySQL-Locks/id_pk_rc.svg" class="" title="主键加锁">
<p>首先建表准备数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> id_pk_rc(id <span class="type">int</span> <span class="keyword">primary key</span>, name <span class="type">varchar</span>(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> id_pk_rc <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_pk_rc <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_pk_rc <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_pk_rc <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_pk_rc <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>执行语句</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置为 RC 隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> id_pk_rc <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 先不结束事务，验证 Monitor Output 再用 ROLLBACK; 回滚</span></span><br></pre></td></tr></table></figure></div>
<p>Monitor 输出日志：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 929632, ACTIVE 27 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 1309, OS thread handle 123145430310912, query id 9179 localhost root</span><br><span class="line">TABLE LOCK table `test`.`id_pk_rc` trx id 929632 lock mode IX</span><br><span class="line">RECORD LOCKS space id 1813 page no 3 n bits 72 index PRIMARY of table `test`.`id_pk_rc` trx id 929632 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000e2f60; asc     /`;;</span><br><span class="line"> 2: len 7; hex 4c000002222e83; asc L   &quot;. ;;</span><br><span class="line"> 3: len 1; hex 63; asc c;;</span><br></pre></td></tr></table></figure></div>
<p>看到输出里有 <code>lock_mode X locks rec but not gap</code>，可以确定持有的是记录锁。</p>
<h3 id="唯一索引-rc"><a class="header-anchor" href="#唯一索引-rc"></a>唯一索引 + RC</h3>
<p>结论：索引和聚簇索引/主键中都对 ID = 5 加 Record Lock</p>
<img src="/2020/God-Damn-MySQL-Locks/id_ui_rc.svg" class="" title="唯一索引会对索引与主键加锁">
<p>首先建表准备数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> id_ui_rc(pk <span class="type">int</span> <span class="keyword">primary key</span>, id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX id_ui <span class="keyword">ON</span> id_ui_rc(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ui_rc <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ui_rc <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ui_rc <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ui_rc <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ui_rc <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">9</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>执行语句：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置为 RC 隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> id_ui_rc <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 先不结束事务，验证 Monitor Output 再用 ROLLBACK; 回滚</span></span><br></pre></td></tr></table></figure></div>
<p>Monitor 输出日志：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 929694, ACTIVE 6 sec</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 1309, OS thread handle 123145430310912, query id 9241 localhost root</span><br><span class="line">TABLE LOCK table `test`.`id_ui_rc` trx id 929694 lock mode IX</span><br><span class="line">RECORD LOCKS space id 1815 page no 4 n bits 72 index id_ui of table `test`.`id_ui_rc` trx id 929694 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 4; hex 80000003; asc     ;;</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 1815 page no 3 n bits 72 index PRIMARY of table `test`.`id_ui_rc` trx id 929694 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 80000003; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000e2f9e; asc     / ;;</span><br><span class="line"> 2: len 7; hex 7a0000059525c9; asc z    % ;;</span><br><span class="line"> 3: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 4: len 1; hex 63; asc c;;</span><br></pre></td></tr></table></figure></div>
<p>可以看到分别对 <code>index id_ui</code> 和 <code>index PRIMARY</code> 加了 Record Lock。</p>
<h3 id="非唯一索引-rc"><a class="header-anchor" href="#非唯一索引-rc"></a>非唯一索引 + RC</h3>
<p>结论：会对所有 ID = 5 的索引记录加 Record Lock，同时对主键加 Record Lock。</p>
<img src="/2020/God-Damn-MySQL-Locks/id_si_rc.svg" class="" title="非唯一索引会对多条记录加锁">
<p>首先建表准备数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> id_si_rc(pk <span class="type">int</span> <span class="keyword">primary key</span>, id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">CREATE</span> INDEX id_si <span class="keyword">ON</span> id_si_rc(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rc <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rc <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rc <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rc <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rc <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>执行语句：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置为 RC 隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> id_si_rc <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 先不结束事务，验证 Monitor Output 再用 ROLLBACK; 回滚</span></span><br></pre></td></tr></table></figure></div>
<p>Monitor 输出日志（省略了 PHYSICAL RECORD 的内容）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 929779, ACTIVE 3 sec</span><br><span class="line">3 lock struct(s), heap size 1136, 4 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 1309, OS thread handle 123145430310912, query id 9325 localhost root</span><br><span class="line">TABLE LOCK table `test`.`id_si_rc` trx id 929779 lock mode IX</span><br><span class="line">RECORD LOCKS space id 1817 page no 4 n bits 72 index id_si of table `test`.`id_si_rc` trx id 929779 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 1817 page no 3 n bits 72 index PRIMARY of table `test`.`id_si_rc` trx id 929779 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div>
<p>可以看到一共有 4 条记录，首先可以看到索引 <code>id_si</code> 和 <code>PRIMARY</code> 分别锁住了两条记录，加的锁都是 X Record Lock No Gap，也就是记录锁。我们通过 <code>select * from information_schema.innodb_locks \G;</code> 查看是锁住了 <code>3, 5</code> 这两条记录。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock_id     | 929779:1817:4:4</span><br><span class="line">lock_trx_id | 929779</span><br><span class="line">lock_mode   | X</span><br><span class="line">lock_type   | RECORD</span><br><span class="line">lock_table  | `test`.`id_si_rc`</span><br><span class="line">lock_index  | id_si</span><br><span class="line">lock_space  | 1817</span><br><span class="line">lock_page   | 4</span><br><span class="line">lock_rec    | 4</span><br><span class="line">lock_data   | 5, 3  &lt;- 注意这里</span><br></pre></td></tr></table></figure></div>
<h3 id="无索引-rc"><a class="header-anchor" href="#无索引-rc"></a>无索引 + RC</h3>
<p>结论：对所有记录加 Record Lock 再释放不匹配的记录锁</p>
<img src="/2020/God-Damn-MySQL-Locks/id_ni_rc.svg" class="" title="无索引会对所有记录加 Record Lock">
<p>这个情形比较特殊，涉及两个<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">知识点
</a></p>
<ol>
<li>MySQL 加锁时是对处理过程中“扫描”到的记录加锁，不管这条记录最终是不是通过
WHERE 语句剔除了</li>
<li>对于 READ COMMITTED，MySQL 在扫描结束后，会违反 #1，释放 WHERE 条件不满足的记录锁</li>
</ol>
<p>首先建表准备数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> id_ni_rc(pk <span class="type">int</span> <span class="keyword">primary key</span>, id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rc <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rc <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rc <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rc <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rc <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>执行语句：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置为 RC 隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> id_ni_rc <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 先不结束事务，验证 Monitor Output 再用 ROLLBACK; 回滚</span></span><br></pre></td></tr></table></figure></div>
<p>Monitor 输出日志（省略了 PHYSICAL RECORD 的内容）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 1446, ACTIVE 17 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 7, OS thread handle 123145446559744, query id 267 localhost root</span><br><span class="line">TABLE LOCK table `test`.`id_ni_rc` trx id 1446 lock mode IX</span><br><span class="line">RECORD LOCKS space id 27 page no 3 n bits 72 index PRIMARY of table `test`.`id_ni_rc` trx id 1446 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div>
<p>看到 TABLE LOCK 的状态是 <code>IX</code> 说明没有加表锁。同时看到最终锁住的只有heap_no =
4 和 6 的两条记录。</p>
<h3 id="主键-rr"><a class="header-anchor" href="#主键-rr"></a>主键 + RR</h3>
<p>当 ID 为主键时，在 RR 隔离级别下，加锁情况与 <a href="#%E4%B8%BB%E9%94%AE-rc">主键 + RC</a> 一致，都是对主键记录加 Record Lock。</p>
<h3 id="唯一索引-rr"><a class="header-anchor" href="#唯一索引-rr"></a>唯一索引 + RR</h3>
<p>当 ID 为唯一索引时，在 RR 隔离级别下，加锁情况与 <a href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-rc">唯一索引 + RC</a>
一致，都是对索引记录和聚簇索引/主键 Record Lock。</p>
<h3 id="非唯一索引-rr"><a class="header-anchor" href="#非唯一索引-rr"></a>非唯一索引 + RR</h3>
<p>结论：对索引记录 Next Key Lock，末尾加 Gap Lock，同时对主键加 Record Lock</p>
<img src="/2020/God-Damn-MySQL-Locks/id_si_rr.svg" class="" title="对索引记录 Next Key Lock，末尾加 Gap Lock，同时对主键加 Record Lock">
<p>Repeatable Read 和 Read Committed 隔离级别的主要区别是 RR 要防止幻读。幻读指的是执行同一个 SQL 两次得到的结果不同。考虑下面的场景：</p>
<ol>
<li>事务 A 执行 <code>SELECT count(*) FROM t WHERE id = 5 FOR UPDATE</code> 返回 2 个元素</li>
<li>事务 B 插入一条 <code>id = 5</code> 的记录</li>
<li>事务 A 再次执行 <code>SELECT count(*) FROM t WHERE id = 5 FOR UPDATE</code> 返回 3 个元素</li>
</ol>
<p>为了要避免这种情况，在 RR 隔离级别下，在 #1 执行时不仅要锁住现有的 ID=5 的索引，还需要阻止 ID = 5 的记录插入（即 #2）。而 Gap Lock 就是实现这个目的的一种手段。</p>
<p>考虑到索引是有序的，因此如果索引里有 <code>[3, 5, 5, 7]</code> 这几个元素，则可以通过锁住
<code>(3, 5)</code>、<code>(5, 7)</code> 这几个区间，加上 <code>[5]</code> 这几个已经存在的元素，就可以阻止 ID
= 5 的记录插入。Gap Lock（间隙锁）的含义是锁住区间，而如果加上右边的闭区间，如
<code>(3, 5]</code> 就称为记录 5 的 Next-Key Lock。</p>
<p>InnoDB 在扫描行时会为扫到的行加上 Next-Key Lock，对于上面的数据，扫到记录 5 时，会加上 <code>(3, 5]</code> 锁，同时，还会对下一个记录加上 Gap Lock，即 <code>(5, 7)</code>，造成
<code>(3, 7)</code> 都无法插入的现象，验证 MySQL 实现如下：</p>
<p>首先建表准备数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> id_si_rr(pk <span class="type">int</span> <span class="keyword">primary key</span>, id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">CREATE</span> INDEX id_si <span class="keyword">ON</span> id_si_rr(id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rr <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rr <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rr <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rr <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_si_rr <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>执行语句：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置为 RC 隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> id_si_rr <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 先不结束事务，验证 Monitor Output 再用 ROLLBACK; 回滚</span></span><br></pre></td></tr></table></figure></div>
<p>Monitor 输出日志（省略 PHYSICAL RECORD 的内容）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 929891, ACTIVE 6 sec</span><br><span class="line">4 lock struct(s), heap size 1136, 5 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 1309, OS thread handle 123145430310912, query id 9442 localhost root</span><br><span class="line">TABLE LOCK table `test`.`id_si_rr` trx id 929891 lock mode IX</span><br><span class="line">RECORD LOCKS space id 1820 page no 4 n bits 72 index id_si of table `test`.`id_si_rr` trx id 929891 lock_mode X</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 1820 page no 3 n bits 72 index PRIMARY of table `test`.`id_si_rr` trx id 929891 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 1820 page no 4 n bits 72 index id_si of table `test`.`id_si_rr` trx id 929891 lock_mode X locks gap before rec</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div>
<p>首先我们看到：</p>
<ul>
<li>对索引 <code>id_si</code> 有两条 Next-Key Lock 记录</li>
<li>对主键有两条 Record Lock 记录</li>
<li>最后对索引 <code>id_si</code> 还有一条 Gap Lock (heap_no = 5 对应 pk = 4 这条记录)</li>
</ul>
<p>为什么唯一索引 + RR 就不需要 Gap Lock 呢？是因为我们的核心目的是不让其它事务插入 <code>ID = 5</code> 的记录，如果 ID 是唯一索引，锁住记录本身就能够满足要求了，不再需要
Gap Lock。</p>
<h3 id="无索引-rr"><a class="header-anchor" href="#无索引-rr"></a>无索引 + RR</h3>
<p>结论：对所有行都加记录锁，且索引前后都要加 Gap Lock</p>
<img src="/2020/God-Damn-MySQL-Locks/id_ni_rr.svg" class="" title="对所有行都加记录锁，且索引前后都要加 Gap Lock">
<p>首先建表准备数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> id_ni_rr(pk <span class="type">int</span> <span class="keyword">primary key</span>, id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rr <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rr <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rr <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rr <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> id_ni_rr <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>执行语句：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置为 RC 隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> id_ni_rr <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 先不结束事务，验证 Monitor Output 再用 ROLLBACK; 回滚</span></span><br></pre></td></tr></table></figure></div>
<p>Monitor 输出日志（省略了部分信息）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 929980, ACTIVE 5 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 6 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 1309, OS thread handle 123145430310912, query id 9529 localhost root</span><br><span class="line">TABLE LOCK table `test`.`id_ni_rr` trx id 929980 lock mode IX</span><br><span class="line">RECORD LOCKS space id 1822 page no 3 n bits 72 index PRIMARY of table `test`.`id_ni_rr` trx id 929980 lock_mode X</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> ...</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div>
<p>首先看到 TABLE LOCK 的状态是 <code>IX</code> 说明没有加表锁。同时看到锁住了 heap no 2~6的记录，对应数据库中的 5 条记录。另外这里的锁是 Next Key Lock，加上 heap no 为 1
的 “supremum” 记录的 gap lock，锁住了所有已经存在和不存在的行。因此如果执行
<code>SELECT * FROM id_ni_rc WHERE id = 0 FOR UPDATE</code> 也会阻塞，尽管 <code>0</code> 记录不在数据库中。</p>
<h2 id="死锁验证"><a class="header-anchor" href="#死锁验证"></a>死锁验证</h2>
<p>死锁与获取锁的顺序有关，一条语句（如 INSERT、DELETE）中对不同行、不同索引的加锁存在先后，因此不同事务内的语句执行时，有可能产生死锁。常见死锁原因（摘自
<a href="https://tanquan.me/2016/05/31/MySQL-InnoDB-Lock/">MySQL InnoDB锁和死锁</a>）：</p>
<ul>
<li>同一索引上，两个session相反的顺序加锁多行记录</li>
<li>UPDATE/DELETE 通过不同的二级索引更新多条记录，可能造成在 Primary key 上不同的加锁顺序</li>
<li>Primary key 和 Secondary index，通过 primary key 找到记录，更新 Secondary
index 字段与通过 Secondary index 更新记录</li>
</ul>
<p>样例情形：</p>
<img src="/2020/God-Damn-MySQL-Locks/id_si_rc_deadlock.svg" class="" title="死锁">
<p>首先建表准备数据：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> deadlock(id <span class="type">int</span> <span class="keyword">primary key</span>, name <span class="type">varchar</span>(<span class="number">32</span>), reg <span class="type">int</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX deadlock_name <span class="keyword">ON</span> deadlock(name);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX deadlock_reg <span class="keyword">ON</span> deadlock(reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> deadlock <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> deadlock <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> deadlock <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> deadlock <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> deadlock <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;e&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
<p>两个事务分别“同时”执行：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Transaction A                       | -- Transaction B</span><br><span class="line">DELETE FROM deadlock WHERE name = &#x27;x&#x27;; | DELETE FROM deadlock WHERE reg &gt;= 2;</span><br></pre></td></tr></table></figure></div>
<p>其中一个事务可能会检测到死锁而出错。Monitor 日志里找到 “LATEST DETECTED
DEADLOCK” 可以看到记录的死锁原因（这个示例复现出的问题与上图不直接一致）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2020-12-13 15:59:40 0x700007a56000</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 930064, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 1309, OS thread handle 123145430310912, query id 9616 localhost root updating</span><br><span class="line">DELETE FROM deadlock WHERE name = &#x27;x&#x27;</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1825 page no 3 n bits 72 index PRIMARY of table `test`.`deadlock` trx id 930064 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 930063, ACTIVE 0 sec updating or deleting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 1308, OS thread handle 123145430589440, query id 9615 localhost root updating</span><br><span class="line">DELETE FROM deadlock WHERE reg &gt;= 2</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 1825 page no 3 n bits 72 index PRIMARY of table `test`.`deadlock` trx id 930063 lock_mode X</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 32</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1825 page no 4 n bits 72 index deadlock_name of table `test`.`deadlock` trx id 930063 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure></div>
<p>我们看到：</p>
<ol>
<li>第一个事务在等待 PRIMARY 索引上 heap_no = 2 的记录的 Record Lock</li>
<li>第二个事务已经取得 PRIMARY 索引上 heap_no = 2 的 Next Key Lock</li>
<li>同时第二个事务在等待 deadlock_name 索引上 heap_no = 2 的 Record Lock</li>
<li>MySQL 选择回滚第一个事务</li>
</ol>
<p>更新操作如 UPDATE/DELETE 加锁的顺序为：<code>查询索引 &gt; 主键索引 &gt; 其它二级索引</code>。如上例中，第二个事务已经锁住了主键索引，准备锁住另一个二级索引 <code>deadlock_name</code>
，而第一个已经锁住了 <code>deadlock_name</code>，准备锁主键索引，造成死锁。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="https://www.jianshu.com/p/13f5777966dd">mysql 索引加锁分析</a> 本文内容的主要参考对象，详细分析了各种情形下的加锁原理</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">Locks Set by Different SQL Statements in
InnoDB</a> 官方文档，介绍了不同语句的加锁方式</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html">InnoDB
Locking</a> 官方文档，介绍了 InnoDB 的不同类型的锁</li>
<li><a href="https://www.slideshare.net/valeriikravchuk1/understanding-innodb-locks-and-deadlocks">Understanding innodb locks and
deadlocks</a>
PPT 解释了 InnoDB 内部的一些数据结构</li>
<li><a href="https://www.cnblogs.com/xiaoboluo768/p/5171425.html">mysql之show engine innodb status解读
</a> 详细介绍了 SHOW
ENGINE INNODB STATUS 输出的内容，也是在这篇文章里认识到人肉看 PHYSICAL
RECORD 的内容不太可能</li>
<li><a href="https://github.com/jeremycole/innodb_ruby">innodb_ruby</a> InnoDB 文件探查工具，学习 InnoDB 利器，会用它来确认 heap_no 对应的记录</li>
</ul>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>