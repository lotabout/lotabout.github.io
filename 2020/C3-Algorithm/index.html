<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="在 Python 中使用 Mixin 有没有遇到过 &lt;code&gt;Cannot create a consistent method resolution&lt;/code&gt; 错误？Mixin 在 Python 里只是多继承(multiple inheritance) 的一种用法，而多继承时，Python 是如何决定父类的顺序呢？咱们就来看看 C3 算法是何方神圣。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>C3 算法：Python 多继承的内部原理 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/C3/" rel="tag">C3</a><a class="post-tag-noise-link" href="/tags/mixin/" rel="tag">mixin</a><a class="post-tag-noise-link" href="/tags/multiple-inheritance/" rel="tag">multiple inheritance</a><a class="post-tag-noise-link" href="/tags/python/" rel="tag">python</a></div><div class="post-time">2020-04-15</div></div></div><div class="container post-header"><h1>C3 算法：Python 多继承的内部原理</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#method-resolution-order-mro"><span class="toc-number">1.</span> <span class="toc-text">Method Resolution Order(MRO)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c3-%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">C3 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">算法示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">反例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-2-3-%E4%B9%8B%E5%89%8D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">Python 2.3 之前的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>在 Python 中使用 Mixin 有没有遇到过 <code>Cannot create a consistent method resolution</code> 错误？Mixin 在 Python 里只是多继承(multiple inheritance) 的一种用法，而多继承时，Python 是如何决定父类的顺序呢？咱们就来看看 C3 算法是何方神圣。</p>
<p>TLDR; 我个人觉得 C3 算法就是拓扑排序…</p>
<h2 id="method-resolution-order-mro"><a class="header-anchor" href="#method-resolution-order-mro"></a>Method Resolution Order(MRO)</h2>
<p>考虑下面的多继承的代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello from A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello from A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">C().hello()</span><br></pre></td></tr></table></figure></div>
<p>上面的 <code>C().hello()</code> 输出是什么呢？这里会输出 <code>hello from A</code>。</p>
<p>Python 的多继承符合直觉，可以认为：在查找一个方法或类时，<strong>会从左到右查找父类的方法或类</strong>，找到为止。这个查找顺序叫作 Method Resolution Order，简称 MRO。可以通过 <code>&lt;class&gt;.mro()</code> 查看，如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; C.mro()</span><br><span class="line">[__main__.C, __main__.A, __main__.B, object]</span><br></pre></td></tr></table></figure></div>
<p>可以看出，查找方法时，会先查 A 再查 B。</p>
<h2 id="c3-算法"><a class="header-anchor" href="#c3-算法"></a>C3 算法</h2>
<p>那么如何计算 MRO 呢？Python 里使用 C3 算法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。其实就是拓扑排序，只是排序的“图”上加了点特技。</p>
<p>符号定义：</p>
<ul>
<li>方便起见，先定义符号 $C_1C_2…C_N$ 代表一个列表 $[C_1, C_2, …, C_N]$</li>
<li>再定义加号： $C + (C_1 C_2 … C_N) = C C_1 C_2 … C_N$</li>
<li>定义 $C_1C_2…C_N$ 列表中，$C_1$ 为头部，$C_2…C_N$ 为尾部</li>
</ul>
<p>算法：</p>
<ul>
<li>对于类定义 <code>class C(B1, B2, ..., BN)</code>，记它的 MRO 为 <code>L[C]</code>（L 代表 linearization）</li>
<li>所有类都会继承 <code>object</code>，定义 <code>L[object] = object</code></li>
<li>算法定义计算步骤为 $L[C] = C + merge(L[B_1], L[B_2], …, L[B_N], B_1B_2…B_N)$
<ul>
<li>注意这里末尾的 $B_1B_2…B_N$，就是我们说的“特技”</li>
</ul>
</li>
<li><code>merge</code> 方法定义为：
<ol>
<li>选取第一个列表 $B_1$</li>
<li>首先选取第一个列表 $B_1$ 第一个元素</li>
<li>如果该元素不出现在 merge 方法其它列表的尾部，则输出元素，并将该元素从其它列表中移除，取下一个元素</li>
<li>如果该元素出现在其它列表的尾部，则选取下一个列表，并重复步骤 2，直到所有列表为空</li>
<li>如果遍历过所有的列表，有列表不为空且过程中没有输出，则说明得不到有效
MRO，报错</li>
</ol>
</li>
</ul>
<h2 id="算法示例"><a class="header-anchor" href="#算法示例"></a>算法示例</h2>
<p>merge 算法其实就是拓扑排序，举例如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">O = <span class="built_in">object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(D,F): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(E,D): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(B,C): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>
<p>继承关系如下图左，而预期的 MRO 关系如下图右（A-&gt;B 表示 MRO 中 A 出现在 B 之前）：</p>
<img src="/2020/C3-Algorithm/C3-example-1.svg" class="" title="C3 Example 1">
<p>计算 MRO 相当于对上右图做拓扑排序，merge 参数的最后一项，实际定义了同层元素间的指向。</p>
<p>Level 2 的 MRO 很容易计算</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L[E] = E + merge(L[O]) = E + merge(O) = E + O = EO</span><br><span class="line">L[D] = D + merge(L[O]) = D + merge(O) = D + O = DO</span><br><span class="line">L[F] = F + merge(L[O]) = F + merge(O) = F + O = FO</span><br></pre></td></tr></table></figure></div>
<p>Level 1 的 MRO 计算如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L[B] = B + merge(L[E], L[D], ED)</span><br><span class="line">     = B + merge(EO, DO, ED)     # 检测 EO 中的元素 E</span><br><span class="line">     = B + E + merge(O, DO, D)   # 检测 DO 中的元素 D</span><br><span class="line">     = B + E + D ＋merge(O, O, ) # 检测元素 O</span><br><span class="line">     = B + E + D ＋O</span><br><span class="line">     = BEDO</span><br><span class="line"></span><br><span class="line">L[C] = C + merge(L[D], L[F], DF)</span><br><span class="line">     = B + merge(DO, FO, DF)     # 检测 DO 中的元素 D</span><br><span class="line">     = B + D + merge(O, FO, F)   # 检测 FO 中的元素 F</span><br><span class="line">     = B + D + F + merge(O, O, ) # 检测元素 O</span><br><span class="line">     = B + D + F + O</span><br><span class="line">     = BDFO</span><br></pre></td></tr></table></figure></div>
<p>于是 A 的 MRO 为：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L[A] = A + merge(L[B], L[C], BC)</span><br><span class="line">     = A + merge(BEDO, BDFO, BC)              # 检测 BEDO 中的 B</span><br><span class="line">     = A + B + merge(EDO, DFO, C)             # 检测 EDO 中的 E</span><br><span class="line">     = A + B + E + merge(DO, DFO, C)          # 检测 DO 中的 D</span><br><span class="line">     = A + B + E + D + merge(O, FO, C)        # 检测 O 中的 O，出现在 FO 尾部</span><br><span class="line">     = A + B + E + D + merge(O, FO, C)        # 检测 C 中的 C</span><br><span class="line">     = A + B + E + D + C + merge(O, FO, )     # 检测 O 中的 O，出现在 FO 尾部</span><br><span class="line">     = A + B + E + D + C + merge(O, FO, )     # 检测 FO 中的 F</span><br><span class="line">     = A + B + E + D + C + F ＋merge(O, O, )  # 检测 O</span><br><span class="line">     = A + B + E + D + C + F ＋O</span><br><span class="line">     = ABEDCFO</span><br></pre></td></tr></table></figure></div>
<p>最后注意根据拓扑图，元素 E 和 C 的顺序先后其实无关紧要。</p>
<h2 id="反例"><a class="header-anchor" href="#反例"></a>反例</h2>
<p>对于下面的类定义，算法就会报错。因为 A 要求 X 在 Y 左边，而 B 的要求正好相反，二者矛盾。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">O = <span class="built_in">object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(X,Y): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(Y,X): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>(A,B): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>
<p>拓扑图如下，我们发现它存在循环引用：</p>
<img src="/2020/C3-Algorithm/Cyclic.svg" class="" title="Cyclic Example">
<p>算法计算过程如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L[X] = XO</span><br><span class="line">L[Y] = YO</span><br><span class="line">L[A] = A + merge(L[X], L[Y], XY)</span><br><span class="line">     = A + merge(XO, YO, XY)</span><br><span class="line">     = AXYO</span><br><span class="line">L[B] = B + merge(L[Y], L[X], XY)</span><br><span class="line">     = B + merge(YO, XO, YX)</span><br><span class="line">     = BYXO</span><br><span class="line">L[T] = T + merge(L[A], L[B], AB)</span><br><span class="line">     = T + merge(AXYO, BYXO, AB)        # 检测 AXYO 中的 A</span><br><span class="line">     = T + A + merge(XYO, BYXO, B)      # 检测 XYO 中的 X，出现在 BYXO 的尾部，跳过</span><br><span class="line">     = T + A + merge(XYO, BYXO, B)      # 检测 BYXO 中的 B</span><br><span class="line">     = T + A + B + merge(XYO, YXO, )    # 检测 YXO 中的 Y，出现在 XYO 的尾部</span><br><span class="line">     # 此处无法再化简，报错</span><br></pre></td></tr></table></figure></div>
<h2 id="python-2-3-之前的问题"><a class="header-anchor" href="#python-2-3-之前的问题"></a>Python 2.3 之前的问题</h2>
<p>C3 算法是在 Python 2.3 后引入的，在这之前，考虑下面的示例：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F=<span class="built_in">type</span>(<span class="string">&#x27;Food&#x27;</span>,(),&#123;<span class="string">&#x27;remember2buy&#x27;</span>:<span class="string">&#x27;spam&#x27;</span>&#125;)</span><br><span class="line">E=<span class="built_in">type</span>(<span class="string">&#x27;Eggs&#x27;</span>,(F,),&#123;<span class="string">&#x27;remember2buy&#x27;</span>:<span class="string">&#x27;eggs&#x27;</span>&#125;)</span><br><span class="line">G=<span class="built_in">type</span>(<span class="string">&#x27;GoodFood&#x27;</span>,(F,E),&#123;&#125;) <span class="comment"># works before Python 2.3</span></span><br></pre></td></tr></table></figure></div>
<p>用 C3 的方式画出拓扑图如下，虽然代码里不明显，图里可以看到存在循环引用：</p>
<img src="/2020/C3-Algorithm/Before-2.3.svg" class="" title="Bad Example Before Python 2.3">
<p>而 Python 2.3 之前的 MRO 算法在调用 <code>G.remember2buy</code> 属性时，预期输出 <code>spam</code>（因为 <code>G(F, E)</code>，预期先查找 F 的方法），而实际会输出 <code>eggs</code>（E 的方法），不符合预期。Python 2.3 及以后就会报错。</p>
<p>因此如果在实现 Mixin 的时候，如果搞错顺序可能就无法运行，例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MixinA</span>(<span class="title class_ inherited__">Base</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MixinB</span>(<span class="title class_ inherited__">Base</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>(MixinA, MixinB, Base): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(Base, MixinA, MixinB): <span class="keyword">pass</span> <span class="comment"># error</span></span><br></pre></td></tr></table></figure></div>
<p>简单的结论是越具体的实现位置越靠前。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>写到最后发现：C3 算法似乎和拓扑排序没有任何区别？只是在标记拓扑图上做一些工夫，保证类定义的先后顺序反映在 MRO 中：即 <code>A(B, C)</code> 最后的 MRO 中 B 一定在 C 之前。</p>
<p>这个知识也许在使用 mixin 出错的时候能帮上忙，剩余时候感觉也没什么用。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<p>算法、示例取自 <a href="https://www.python.org/download/releases/2.3/mro/">The Python 2.3 Method Resolution Order</a>，建议看原文。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px">1.</span><span style="display: inline-block; vertical-align: top">python 2.3 及以后</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div></div></div><script type="text/x-mathjax-config">
   MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>