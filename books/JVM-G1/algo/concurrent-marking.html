<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>并发标记 - Java G1GC 小册子</title>
        
        


        <!-- Custom HTML head -->
        


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../css/lotabout.css">
        

        
        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">JVM G1GC 小册子</a></li><li class="chapter-item expanded affix "><li class="part-title">算法篇</li><li class="chapter-item expanded "><a href="../algo/gcs.html"><strong aria-hidden="true">1.</strong> G1 简介</a></li><li class="chapter-item expanded "><a href="../algo/concurrent-marking.html" class="active"><strong aria-hidden="true">2.</strong> 并发标记</a></li><li class="chapter-item expanded "><a href="../algo/evacuation.html"><strong aria-hidden="true">3.</strong> Evacuation</a></li><li class="chapter-item expanded "><a href="../algo/soft-real-time.html"><strong aria-hidden="true">4.</strong> 软实时性</a></li><li class="chapter-item expanded "><a href="../algo/generational.html"><strong aria-hidden="true">5.</strong> 分代 G1 GC</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <a id="home" class="icon-button" type="button" title="Go to Home" href="/">
                            <i class="fa fa-home"></i>
                        </a>

                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Java G1GC 小册子</h1>

                    <div class="right-buttons">

                        
                        
                        

                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#并发标记" id="并发标记">并发标记</a></h1>
<p>本章比较长，请耐心阅读。主要介绍并发标记算法的各个步骤和细节。</p>
<h2><a class="header" href="#什么是并发标记" id="什么是并发标记">什么是并发标记</a></h2>
<p>前面我们提到 <code>垃圾回收 = 识别 + 回收</code>，并发标记就是识别的部分，需要识别出内存里有哪些对象还存活，哪些对象已经没用了，可以回收。</p>
<h3><a class="header" href="#标记与-gc-roots" id="标记与-gc-roots">标记与 GC Roots</a></h3>
<p>首先有一部分对象我们会认为肯定还活着，一般称为 GC Roots，例如线程堆栈上的变量，如传入方法的参数，创建的临时变量等；例如系统加载的一些类等等<sup class="footnote-reference"><a href="#ref-gc-roots">1</a></sup>。</p>
<p>已知 GC Roots 必不可能是垃圾，那么从 GC Roots 引用的对象，必不可能是垃圾。因此并发标记中的“标记”，本质上就是从 GC Roots 出发，递归遍历所有引用的对象，把它们标记为“live（存活）”，这样没有标记到的就是垃圾，可以被清除。</p>
<h3><a class="header" href="#标记与三色算法" id="标记与三色算法">标记与三色算法</a></h3>
<p>标记本质是在做树/森林的遍历，遍历每一个“可达”的对象，遍历过程中有三个状态，为了方便讨论，通常用三种颜色对应三个状态：</p>
<ul>
<li>Black（黑）: 对象被访问了，且对象发出的引用都加入遍历队列。之后标记程序不会再访问该对象</li>
<li>Grey（灰）: 对象被加入了遍历队列，但还没有被标记程序访问。标记程序之后会访问它</li>
<li>White（白）: 标记程序还没有感知到它的存在，可能是还没遍历到，也可能是它本身不可触达</li>
</ul>
<p>在下面的讨论中我们会用这些概念来讨论一些扫描机制的边界条件，但记住颜色的说法只是方便讨论遍历中节点的不同状态而已。下面再来张图方便直观理解遍历过程：</p>
<p><img src="concurrent-marking/Tri-color-example.svg" alt="" /></p>
<p>细节实现上，上图展示的是宽度搜索，但标记本身并不依赖具体的实现。G1 的实现有点像是宽搜和深搜的复合版本，以平衡效率和空间占用。实现的方式可以参考论文《A
generational mostly-concurrent garbage collector》。</p>
<h2><a class="header" href="#并发与-satb" id="并发与-satb">并发与 SATB</a></h2>
<p>上一章提过 GC 算法的其中一个目标是减少停顿<sup class="footnote-reference"><a href="#comment-pause">2</a></sup>，这里的停顿指的是应用程序的停顿。但像标记的工作，要扫描的存活对象客观上就有那么多，可能就算砸锅卖铁也需要那么长的时间，怎么减少停顿？其中一个想法是“并发”<sup class="footnote-reference"><a href="#comment-parallel-vs-concurrency">3</a></sup>，应用程序工作的同时，拿部分资源做 GC 的事，而不需要将应用程序暂停。</p>
<p>那么代价呢？</p>
<ul>
<li>GC 吞吐变差。如果完全停顿，GC 可以砸锅卖铁用所有资源，现在单位时间内只能用部分资源，GC 的吞吐必然变差</li>
<li>GC 实现更复杂。例如三色算法，考虑的是“静态”的引用树，但在并发模式下，标记到一半时，树的结构可能发生变化，于是算法得有相关的实现来处理这些情况。</li>
</ul>
<p>吞吐问题是效率问题，基本只能靠不断优化算法与实现细节。引用结构变化问题是正确性问题，目前有多种解法，G1GC 采用的是 Snapshot At The Beginning(SATB) 的解法<sup class="footnote-reference"><a href="#ref-incremental-update">4</a></sup>。核心思想是：标记开始前对当前的引用树做个快照，本次标记只对快照负责，对快照后变为垃圾的对象视而不见（这些垃圾也被称为浮动垃圾
floating garbage，会在下次 GC 时被回收）。</p>
<h2><a class="header" href="#标记位图" id="标记位图">标记位图</a></h2>
<p>要把对象标记成“存活”或“垃圾”，这个标记放哪？</p>
<p>我们知道 Java 的每个对象有对象头（object header），一种想法是在对象头里拿一个
bit 来记录这个信息，但这种做法从各种角度都不太好，如需要访问的内存散落各处，对缓存不友好；难以处理并发访问的一些情况；创建子进程时对内存的修改会触发操作系统的 Copy on Write 机制，容易浪费内存。</p>
<p>G1GC 使用的是标记位图，可以类比成为现实世界创建一张地图，标记的时候只在地图上标记，可以解决上面说的相关问题。位图需要占用额外的内存，但大小有限，例如每个对象大小是 8 字节，一个对象只需要 1 bit 标记，于是标记位图大小只需要内存的1/64
即可。</p>
<p>另外，要实现上面提到的 SATB 快照也需要额外记录一些信息，因此 G1 实际上需要记录这么一些内容：</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-bitmap.svg" alt="" /></p>
<p><code>bottom</code> 指针指向区域的开始，<code>top</code> 指向区域内空闲空间的开始。<code>prev</code> 和<code>next</code>代表的是标记位图。额外地还有 TAMS(Top at marking start) 指针，记录的是标记开始时 <code>top</code> 的值，也分 prevTAMS, nextTAMS 两个版本，是实现 SATB 快照用的。</p>
<p>注意到位图和 TAMS 都有 prev 和 next 两个版本，这里 prev 版本是上一次标记的结果，而 next 版本记录的是本次进行中的状态<sup class="footnote-reference"><a href="#ref-single-bitmap">5</a></sup>。<code>TAMS</code> 作用是做 SATB
的快照，对引用树做快照肯定不能复制一份内存，G1 的做法是在标记开始时将 <code>top</code> 值记录为 <code>nextTAMS</code>，本次标记只处理 <code>[bottom, nextTAMS]</code> 之间的对象，同样地回收时只回收 <code>[bottom, prevTAMS)</code> 间的对象<sup class="footnote-reference"><a href="#comment-prevTAMS">6</a></sup>。由于 mutator 并发执行，标记过程中如果创建新对象，<code>top</code>指针会增加，而在 <code>[TAMS, top]</code> 之间的对象，都当作是存活的对象。</p>
<h2><a class="header" href="#并发标记整体步骤" id="并发标记整体步骤">并发标记整体步骤</a></h2>
<p>注意下文介绍的步骤和《深入 Java 虚拟机》一书里介绍的不一样，这里采用了 <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Oracle 教程</a> 的说法。</p>
<ol>
<li>初始标记 (Initial Mark)。标记 GC Root 能直达的对象，STW</li>
<li>根区域扫描 (Root Region Scan)。标记所有从 root region 可达的对象，在 G1 里特指 Survivor 区域。该步骤是为了处理标记与 evacuation 并发执行引发的一些问题。不需要 STW，但需要在下次 evacuation 前完成</li>
<li>并发标记 (Concurrent Mark)。使用三色算法标记所有可达的对象。与 mutator 可并发执行</li>
<li>最终标记 (Remark)。在步骤 ②、③ 中 mutator 可能更改了对象的引用关系，这些关系用 SATB 写屏障做了记录，该步骤会扫描这些记录并做标记。STW</li>
<li>收尾工作 (Cleanup)。主要包含几部分
<ul>
<li>存活对象计数。统计每个区域的存活对象信息，供 evacuation 使用。STW</li>
<li>清理 Remembered Sets(RSet)。STW</li>
<li>释放空区域。并发执行。</li>
</ul>
</li>
</ol>
<p>可以看到步骤很复杂，包含了很多细节。对于初次了解来说可以简单理解成标记过程中有一些不得不 STW 的操作，于是把三色算法拆成了 “停顿 -&gt; 并发 -&gt; 停顿 -&gt; ...” 这样的步骤，之后再理解为什么不得不停顿。</p>
<h2><a class="header" href="#①-初始标记-initial-mark" id="①-初始标记-initial-mark">① 初始标记 (Initial Mark)</a></h2>
<p>初始标记是用来标记 GC Root 能直达的对象，需要 STW 。下图展示了初始标记的操作：</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-initial-mark.svg" alt="" /></p>
<p>GC 线程首先会创建标记位图 <code>next</code>，再将 <code>nextTAMS</code> 置为当前 <code>top</code> 的值。另外由于标记阶段只处理 <code>[bottom, nextTAMS)</code> 之间的对象，因此 <code>next</code> 位图的大小也与<code>top</code>对齐，大小为 <code>(nextTAMS - bottom)/8</code>。</p>
<p>Initial Mark 阶段会扫描所有的 GC Root，将 GC Root 直接引用的对象标记为灰色（加入待遍历的队列），如上图中的对象 <code>C</code>。这个步骤称为根扫描(Root Scan)。</p>
<p>这个过程是 STW 的，如果根扫描的过程中根被 mutator 修改了，这种情况很难处理。虽然 G1GC 中使用写屏障（write barrier）可以感知对象的修改，但大多数根并不是对象，无法用写屏障感知，因此需要暂停 mutator 的执行。</p>
<p>另外实现上，Initial Mark 阶段其实是触发一次 Young GC（在 G1 中称为 Fully Young
Evacuation），在 Young GC 对 GC Root 扫描的过程中顺便做标记。因此在文档上，会说 Initial Mark 这个操作是 &quot;piggy-backed&quot;（趴在猪上，搭载的意思）。</p>
<h2><a class="header" href="#②-根区域扫描-root-region-scan" id="②-根区域扫描-root-region-scan">② 根区域扫描 (Root Region Scan)</a></h2>
<p>这个阶段是对算法实现的一个优化<sup class="footnote-reference"><a href="#ref-JDK-6888336">7</a></sup>，对理解算法没有太大帮助，并且需要一些后续章节的知识才能理解，<strong>可以考虑先跳过</strong>，后续再回头看（不理解官方文档为什么要放在这里）。</p>
<p>我们知道标记和 Young GC 可以并发执行，如果并发标记进行到一半，Young GC 开始执行，那么 Young GC 除了复制存活对象外，还需要维护标记相关的状态，如更新新老区域对应的标记位图，在标记队列中的对象也需要做更新。实测下来很耗时间<sup class="footnote-reference"><a href="#ref-JDK-7112743">8</a></sup>。要理解哪些可以优化，需要先剧透一些信息。</p>
<p>GC 做回收的时候，还是会自己扫描对象引用的，并不会直接复用标记的结果。由于 G1
每次只回收部分区域，如果扫描引用需要扫描整个堆，就太浪费时间了，所以 RSet 就是其中一个优化，只需要找到需要回收区域的 RSet，就能知道有哪些区域引用自己了。</p>
<p>但问题还没解决，即使通过 RSet 找到了引用自己的区域，怎么知道这些区域里哪些对象是活着的？这就是并发标记要解决的，标记能回答，在 TAMS 前的对象都标好了，TAMS之后的对象都当成是活的。因此可以理解为，标记只是为回收提供“额外 root”信息的。</p>
<p>另外由于不管是 Young GC 还是 Mixed GC，Eden 和 Survivor 的所有区域都会被回收，所以这些区域的 mark 信息本质上是没用的，因为 evacuation 时本来就会扫描它们中的所有对象。于是可以推论标记的产出，是 Old Gen 里不被回收的区域中对象的存活信息。</p>
<p>而我们知道 Young GC 只回收 Eden 和 Survivor，过程中需要维护标记信息是防止移动
Eden 和 Survivor 的对象导致扫描出错。那只需要在并发 Young GC 发生之前，就把
Young Gen 的对象都扫完就行了。扫完后 Young Gen 发生的事都跟并发标记无关了。</p>
<p>由于 Initial Mark 本质上是做了一次 Young GC，可以认为 Initial Mark 快照时，
Eden 是空的，所以在下次 Young GC 前，只需要扫完 Survivor 区即可。这个过程被称为根区域扫描，而 Survivor 区也是目前唯一的根区域。</p>
<h2><a class="header" href="#③-并发标记-concurrent-mark" id="③-并发标记-concurrent-mark">③ 并发标记 (Concurrent Mark)</a></h2>
<p>并发标记阶段是用三色算法递归遍历所有引用的过程。另外由于 mutator 也在并发执行，因此需要处理 mutator 修改的引用。</p>
<p>下图表示的是并发标记结束后区域的状态，对象 <code>A</code> 和 <code>E</code> 都被标记了。对于 <code>E</code> 这种占用多个标记位的对象，只有起始位会被标记。在标记过程中，对象 <code>J</code>、<code>K</code> 是新创建的，在 SATB 的机制之下，它们会被认为是存活对象，标记过程完全不会处理它们，只是在 evacuation 使用标记时，会把它们当作是存活的对象。</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-concurrent-mark.svg" alt="" /></p>
<h3><a class="header" href="#标记遗漏问题" id="标记遗漏问题">标记遗漏问题</a></h3>
<p>mutator 与标记并发执行，可能引发两种问题：</p>
<ol>
<li>新增对象，从步骤 ① 中标记的 GCRoot 出发不一定可达，这点在 SATB 中通过
<code>nextTAMS</code> 解决</li>
<li>引用修改，同时满足下列两个条件的修改会造成正确性问题
<ul>
<li>应用线程增加了一个 Black -&gt; White 的引用</li>
<li>同时应用线程断开了 Grey -&gt; White 的(直接或间接)引用</li>
</ul>
</li>
</ol>
<p>第二个问题如下图所示：</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-object-loss.svg" alt="" /></p>
<p>考虑处于图 <code>(a)</code> 状态时标记暂停，此时 mutator 执行 <code>(b)</code> 增加了 <code>A-&gt;C</code> 的引用，再执行 <code>(c)</code> 操作断开 <code>B-&gt;C</code> 的引用。此时标记继续，虽然对象 <code>B</code> 在标记队列里，但此时 <code>B-&gt;C</code> 的引用已经断开，因此从 <code>B</code> 对象出发不会对 <code>C</code> 做标记，而，由于在步骤 <code>(a)</code> 时 <code>A</code> 出发的引用都扫描过了，所以 <code>A</code> 已经标黑，于是后续的标记过程都不会再访问 <code>A</code>，于是也不会从 <code>A</code> 出发对 <code>C</code> 做标记。导致对象 <code>C</code> 被标记遗漏了。</p>
<h3><a class="header" href="#satb" id="satb">SATB</a></h3>
<p>对以上两个标记遗漏问题，G1 中使用 SATB(Snapshot At The Beginning) 的机制：</p>
<ol>
<li>对于新增对象，上面提过，在标记开始时将 <code>top</code> 的值记录为 <code>nextTAMS</code>，大于
<code>nextTAMS</code> 的对象肯定是标记开始后新增的，无论它们实际是否存活，都认为是存活的。</li>
<li>对于引用修改问题，SATB 引入了 SATB 写屏障，在 mutator 对引用做修改时，记录赋值前的对象（即上例中的对象 <code>C</code>），并把它们标记成灰，防止遗漏。</li>
</ol>
<p>这两个操作从效果上等价于在标记开始时给所有旧的引用做了快照，标记只对快照的引用关系进行，而对快照后发生的引用修改视而不见，因此称为 SATB。</p>
<h3><a class="header" href="#satb-专用写屏障" id="satb-专用写屏障">SATB 专用写屏障</a></h3>
<p>所谓的“写屏障”，指的是应用程序的 Java 代码里，对象的域上发生了任何的修改，都额外执行一段代码，SATB 专用的写屏障执行的伪代码如下（后续会介绍 G1 还有维护 RSet
用的写屏障）：</p>
<pre><code>1: def write(field, new_val):
2:     satb_write_barrier(field)
3:     *field = new_val
4: 
5: def satb_write_barrier(field):
6:     if $gc_phase == GC_CONCURRENT_MARK:
7:         old_obj = *field
8:         if old_obj != NULL:
9:             enqueue($current_thread.satb_local_queue, old_obj)
</code></pre>
<p>当执行 <code>obj.field = new_val</code> 时执行 <code>write</code> 方法，注意到<code>satb_write_barrier</code>并不需要知道 <code>new_val</code> 的值，但它由于它需要记录修改之前的值，因此需要在第 3 行之前执行，因此这个写屏障也叫写前屏障（pre-write barrier）。</p>
<p>第 6 行 用来判断当前是不是处于并发标记的阶段；第 8 行判断 <code>old_obj</code> 是否为NULL，如果是 NULL 则不做任何处理；第 9 行在 <code>old_obj</code> 不为 NULL 时将其加入到当前线程自己的 <code>satb_local_queue</code> 中。因为目的是对 <code>old_obj</code> 发出的引用做标记，如果是
NULL 就没有什么可标记的了。</p>
<p>另外注意，把一个对象标成灰需要做两件事，在位图上做标记，同时将对象加入标记队列中，上面的算法只加入队列并没有处理位图，这点与原版的算法（称为汤浅算法，由汤浅太一于 1990 年开发）不同。位图的处理会由其它线程完成，写屏障由 mutator 执行，减少写屏障的开销能减少 mutator 的负担。</p>
<h3><a class="header" href="#satb-队列" id="satb-队列">SATB 队列</a></h3>
<p>一个功能如果涉及多线程，都要考虑同步带来的开销，SATB 的实现也是如此。SATB 没有使用一个全局的大队列，而是每个 mutator 线程各自持有自己的队列，在本地队列装满后（默认大小 1KB），会被添加到全局的<strong>SATB 队列集合</strong>中。这些队列里的对象，可以认为都是灰色的待标记的对象<sup class="footnote-reference"><a href="#comment-satb-queue-skip-obj">9</a></sup>。</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-satb-queue.svg" alt="" /></p>
<p>并发标记阶段，GC 线程会定期检查 SATB 队列集合的大小，如果发现有队列，则会对队列里的对象进行标记和扫描。另外对 SATB 队列的处理，优先级会比常规的三色标记更高，毕竟 SATB 队列占了额外的资源，应该尽快处理，而其它引用关系都在堆里，都是“死”的。</p>
<h3><a class="header" href="#satb-写屏障与多线程执行" id="satb-写屏障与多线程执行">SATB 写屏障与多线程执行</a></h3>
<p>这是《深入 Java 虚拟机》第 2.5.3 一节中额外提到的一个正确性疑问，对于理解 SATB
中的不变性（invarient）有帮助。考虑上面写屏障的代码（按书里的样例重写了）：</p>
<pre><code>1: def satb_write_barrier(field, new_val):
2:     if $gc_phase == GC_CONCURRENT_MARK:
3:         old_obj = *field // ①
4:         if old_obj != NULL:
5:             enqueue($current_thread.satb_local_queue, old_obj) // ②
6:     *field = new_val // ③
</code></pre>
<p>注意到写屏障的代码中从 ① 到 ③ 没有加锁的操作，那考虑下面的场景：</p>
<ul>
<li><code>*field</code> 的值是 <code>obj0</code>（的地址）</li>
<li><code>t1</code>（线程 1）想在 <code>*field</code> 中写入 <code>obj1</code></li>
<li><code>t2</code>（线程 2）想在 <code>*field</code> 中写入 <code>obj2</code></li>
</ul>
<p>现在考虑这样的执行顺序：</p>
<ol>
<li><code>t1</code> 执行 ①：<code>old_obj = obj0</code></li>
<li><code>t2</code> 执行 ①：<code>old_obj = obj0</code></li>
<li><code>t1</code> 执行 ②：将 <code>obj0</code> 添加到 SATB 队列</li>
<li><code>t2</code> 执行 ②：将 <code>obj0</code> 添加到 SATB 队列</li>
<li><code>t1</code> 执行 ③：<code>*field = obj1</code></li>
<li><code>t2</code> 执行 ③：<code>*field = obj2</code></li>
</ol>
<p>最终 <code>*field</code> 的值为 <code>obj2</code>，但我们发现 <code>t1</code> 中途写入的 <code>obj1</code> 并没有被加入到
SATB 队列中，这会不会导致标记遗漏呢？</p>
<p>实际上并不会，我们先逻辑视角来看，SATB 只负责处理快照前的引用关系，要保证<strong>快照前</strong>可达的对象，即使 mutator 修改了引用也能被正确标记，这也是写屏障关心<strong>修改前</strong>对象的原因。那么对于 <code>field</code> 来说，之前可达的只有 <code>obj0</code> 这一个对象，因此只要保证<code>obj0</code> 进队列就可以了。而 <code>obj1</code> 是快照后新增的引用，原则上就是不需要处理的。</p>
<p>当然逻辑上的道理不一定能说服我们，我们考虑实际实现。我们要执行 <code>obj3.field = obj1</code>时，<code>obj1</code> 肯定也是被某个指针引用的，不管它是栈上的临时变量，还是另一个对象的域。我们假设它是 <code>obj4.field</code>，于是上面的过程引用关系变化如下图：</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-satb-barrier-thread-safety.svg" alt="" /></p>
<p>整个过程中，SATB 保证了 <code>obj0</code> 标灰，那 <code>obj1</code> 呢？<code>obj1</code> 还被 <code>obj4</code> 引用着，不管当前 <code>obj4</code> 是白还是灰，最终都能访问到 <code>obj1</code>，但这都跟 <code>obj3</code> 没有关系了。如果后续 <code>obj4</code> 断开了和 <code>obj1</code> 的引用，<code>obj1</code> 也能被对应的写屏障捕捉，标成灰色，但同样的，也跟 <code>obj3</code> 无关了。</p>
<h2><a class="header" href="#④-最终标记-remark" id="④-最终标记-remark">④ 最终标记 (Remark)</a></h2>
<p>如果理解了 SATB 机制，那么最终标记要做什么也很容易理解了。SATB 写屏障队列的处理和标记过程是并发的，那么总需要有一个时机“扫描残留的 SATB 本地队列”，而要清空队列就要保证此时没有新的修改，于是需要暂停 mutator，所以这是个 STW 的过程。</p>
<p>如下图，扫描完 mutator 的本地 SATB 队列后，对象 <code>G</code>，<code>H</code> 也会被标记，且它们的引用 <code>I</code> 也会被标记。</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-remark.svg" alt="" /></p>
<p>Remark 阶段结束后，所有存活对象都被标记，不带标记的对象都认为是垃圾了。</p>
<p>另外实现上 Remark 阶段还会做一些额外的操作，如弱引用处理（reference
processing）、类卸载（Class Unloading）、释放空的区域、重建
RSet<sup class="footnote-reference"><a href="#ref-JDK-8180415">10</a></sup> 等，但这些都是实现细节，这里不展开。</p>
<h2><a class="header" href="#⑤-收尾工作-cleanup" id="⑤-收尾工作-cleanup">⑤ 收尾工作 (Cleanup)</a></h2>
<p>从 Oracle 的文档来看，收尾工作有这么几个<sup class="footnote-reference"><a href="#comment-cleanup">11</a></sup>：</p>
<ul>
<li>存活对象计数。统计每个区域的存活对象信息，供 evacuation 使用。STW</li>
<li>清理 Remembered Sets(RSet)，标记阶段能确定一些空区域，它们的 RSet 可以清理。STW</li>
<li>释放空区域。并发执行。</li>
</ul>
<p>下面我们主要介绍存活对象计数，以及上面没提的，为下一次标记做的准备。</p>
<h3><a class="header" href="#存活对象计数" id="存活对象计数">存活对象计数</a></h3>
<p>标记是为回收服务的，在 G1 的回收阶段，有一个重要决策是判断回收哪些区域的性价比更高。而这就依赖标记阶段提供关于区域有多少存活对象的信息。</p>
<p>这个步骤会扫描各区域的 <code>next</code> 标记位图，统计区域内存活对象的字节数，然后存入区域内的 <code>next_marked_bytes</code>，看名字也能想到，那肯定也有对应的
<code>prev_marked_bytes</code> 字段，它们和 <code>next</code>, <code>prev</code> 类似，一个代表进行中，一个代表已完成。</p>
<p>下图中存活的对象有 <code>A</code>, <code>C</code>, <code>E</code>, <code>G</code>, <code>H</code>, <code>I</code>，因此统计共得 <code>56</code> 字节。这里对象 <code>E</code> 虽然在标记位图里只有一个 bit 标记，但计算大小时要按对象大小 <code>16B</code> 计算。在 <code>[nextTAMS, top)</code> 间的对象隐式地被作为存活对象，不需要在这里单独计数。</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-live-object-counts.svg" alt="" /></p>
<h3><a class="header" href="#准备下一次标记" id="准备下一次标记">准备下一次标记</a></h3>
<p>前面提到标记位图，<code>TAMS</code> 指针、<code>marked_bytes</code> 都有两份，其中 prev 代表（上次）已完成的状态，next 代表标记中的状态，现在标记结束了，需要将 prev 的值置为
next，并重置 next，如下图：</p>
<p><img src="concurrent-marking/2023-01-jvm-g1-cleanup.svg" alt="" /></p>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<p>标记阶段最终有两个主要的产出</p>
<ol>
<li><code>prev</code> 标记位图 + <code>prevTAMS</code>，用于有哪些对象是存活的</li>
<li><code>prev_marked_bytes</code> 用于每个区域有多少存活对象，后续 evacuation 选择区域使用</li>
</ol>
<p>而理解并发标记，最重要的是理解标记遗漏问题以及 SATB 机制，这些都在文章里介绍了。</p>
<h2><a class="header" href="#推荐阅读" id="推荐阅读">推荐阅读</a></h2>
<ul>
<li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-marking">GC Algorithms: Implementations</a> plumbr.io 的 GC 教程，对 G1 算法有很详细的描述</li>
<li><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Getting Started with the G1 Garbage Collector</a> Oracle 的官方教程</li>
<li><a href="https://tschatzl.github.io/2022/08/04/concurrent-marking.html">Concurrent Marking in G1</a> JDK 开发 Thomas Schatzl 写的关于并发标记的文章</li>
</ul>
<hr />
<div class="footnote-definition" id="ref-gc-roots"><sup class="footnote-definition-label">1</sup>
<p><a href="https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html">Garbage Collection Roots</a> Eclipse Memory Analyzer 总结的</p>
</div>
<div class="footnote-definition" id="comment-pause"><sup class="footnote-definition-label">2</sup>
<p>在本书中，没有特别说明的情况下，“停顿”（Pause）都指的是 stop the world 停顿</p>
</div>
<div class="footnote-definition" id="comment-parallel-vs-concurrency"><sup class="footnote-definition-label">3</sup>
<p>注意并发与并行的区别，这里不多做讨论，请读者自行查阅相关概念</p>
</div>
<div class="footnote-definition" id="ref-incremental-update"><sup class="footnote-definition-label">4</sup>
<p>还有一些其它做法，如 CMS 中使用的是 incremental update</p>
</div>
<div class="footnote-definition" id="ref-JDK-6888336"><sup class="footnote-definition-label">7</sup>
<p><a href="https://bugs.openjdk.org/browse/JDK-6888336">JDK-6888336</a>
里的 comment 有更详细的描述</p>
</div>
<div class="footnote-definition" id="ref-single-bitmap"><sup class="footnote-definition-label">5</sup>
<p><a href="https://bugs.openjdk.org/browse/JDK-8210708">JDK-8210708</a> 这个优化后，next bitmap 不复存在，这个修改会进 JDK 20</p>
</div>
<div class="footnote-definition" id="comment-prevTAMS"><sup class="footnote-definition-label">6</sup>
<p>细节上回收时 <code>[prevTAMS, top)</code> 间的对象也是可能被回收的，这个后续会讨论，这里这个说法不影响算法的理解</p>
</div>
<div class="footnote-definition" id="ref-JDK-7112743"><sup class="footnote-definition-label">8</sup>
<p><a href="https://bugs.openjdk.org/browse/JDK-7112743">JDK-7112743</a>
提到 26G 内存，18 个 worker 下花了近 1.8s。</p>
</div>
<div class="footnote-definition" id="comment-satb-queue-skip-obj"><sup class="footnote-definition-label">9</sup>
<p>实际上 write barrier 可能会记录 TAMS 之后的对象，这些对象后续处理里可以丢弃</p>
</div>
<div class="footnote-definition" id="ref-JDK-8180415"><sup class="footnote-definition-label">10</sup>
<p><a href="https://bugs.openjdk.org/browse/JDK-8180415">JDK-8180415</a>
在并发标记阶段重建 RSet，进入 JDK 11</p>
</div>
<div class="footnote-definition" id="comment-disclaimer-source"><sup class="footnote-definition-label">12</sup>
<p>本人看 JDK 源码经验尚浅，如有错误，欢迎指出</p>
</div>
<div class="footnote-definition" id="comment-cleanup"><sup class="footnote-definition-label">11</sup>
<p>实际看 JDK 11 源码，发现实际实现跟文档里说的内容差异比较大，不确定是不是文档和版本不同步。例如这里说的几个步骤，其实都算在 Remark 阶段，而实际的 CleanUp 只包含 RSet 重建的内容。另外对 bitmap 的重置和 TAMS 的重置也不在一起执行。</p>
</div>


                        <hr />
                        <div id="disqus_thread"></div>
                        <div class="giscus"></div>
                    </main>


                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../algo/gcs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../algo/evacuation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>

                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../algo/gcs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../algo/evacuation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];
            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
                ga('create', 'UA-39956831-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script>
            window.playground_copyable = true;
        </script>
        

        

        

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        

        

        <!-- giscus -->
        <script src="https://giscus.app/client.js"
                data-repo="lotabout/lotabout.github.io"
                data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw=="
                data-category="Announcements"
                data-category-id="DIC_kwDOATmmt84ClmcD"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="0"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="zh-CN"
                crossorigin="anonymous"
                async>
        </script>

    </div>
    </body>
</html>
