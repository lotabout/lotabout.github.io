<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsafe - Java 并发知识</title>
        
        


        <!-- Custom HTML head -->
        


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../css/lotabout.css">
        

        
        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Java 并发知识</a></li><li class="chapter-item expanded affix "><li class="part-title">理解线程安全</li><li class="chapter-item expanded "><a href="../Ideal-World/index.html"><strong aria-hidden="true">1.</strong> 理想的并发世界</a></li><li class="chapter-item expanded "><a href="../Cruel-World/index.html"><strong aria-hidden="true">2.</strong> 残酷的现实</a></li><li class="chapter-item expanded "><a href="../Happens-Before/index.html"><strong aria-hidden="true">3.</strong> Happens Before</a></li><li class="chapter-item expanded "><a href="../Thread-Safety-Examples/index.html"><strong aria-hidden="true">4.</strong> 常见线程安全问题</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thread-Safety-Examples/TOCTOU.html"><strong aria-hidden="true">4.1.</strong> TOCTOU</a></li><li class="chapter-item expanded "><a href="../Thread-Safety-Examples/Double-Checked-Locking.html"><strong aria-hidden="true">4.2.</strong> Double Checked Locking</a></li><li class="chapter-item expanded "><a href="../Thread-Safety-Examples/Compound-Actions.html"><strong aria-hidden="true">4.3.</strong> 复合操作</a></li><li class="chapter-item expanded "><a href="../Thread-Safety-Examples/Summary.html"><strong aria-hidden="true">4.4.</strong> 小结</a></li></ol></li><li class="chapter-item expanded "><a href="../Best-Practice/index.html"><strong aria-hidden="true">5.</strong> 良好的并发编程习惯</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Best-Practice/Confinement.html"><strong aria-hidden="true">5.1.</strong> 封闭</a></li><li class="chapter-item expanded "><a href="../Best-Practice/Immutability.html"><strong aria-hidden="true">5.2.</strong> 不可变</a></li><li class="chapter-item expanded "><a href="../Best-Practice/Threadsafe-Data-Types.html"><strong aria-hidden="true">5.3.</strong> 利用线程安全类</a></li></ol></li><li class="chapter-item expanded "><a href="../Thread-Safety-Home-Work/index.html"><strong aria-hidden="true">6.</strong> 思考题</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thread-Safety-Home-Work/Spring-Bean-Initialization.html"><strong aria-hidden="true">6.1.</strong> Spring Bean 初始化如何线程安全</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">线程与线程池</li><li class="chapter-item expanded "><a href="../Amdahl-Law/index.html"><strong aria-hidden="true">7.</strong> Amdahl 定律</a></li><li class="chapter-item expanded "><a href="../Cost-of-Thread/index.html"><strong aria-hidden="true">8.</strong> 线程的代价</a></li><li class="chapter-item expanded "><a href="../Thread-Pool/index.html"><strong aria-hidden="true">9.</strong> 线程池</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thread-Pool/Concepts.html"><strong aria-hidden="true">9.1.</strong> 线程池相关概念</a></li><li class="chapter-item expanded "><a href="../Thread-Pool/Predefined.html"><strong aria-hidden="true">9.2.</strong> 预定义的线程池</a></li><li class="chapter-item expanded "><a href="../Thread-Pool/Usage.html"><strong aria-hidden="true">9.3.</strong> 线程池使用</a></li><li class="chapter-item expanded "><a href="../Thread-Pool/Interrupt.html"><strong aria-hidden="true">9.4.</strong> 线程的中断</a></li><li class="chapter-item expanded "><a href="../Thread-Pool/Shutdown.html"><strong aria-hidden="true">9.5.</strong> 如何优雅退出</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">10.</strong> 线程调度</li><li class="chapter-item expanded affix "><li class="part-title">源码分析</li><li class="chapter-item expanded "><a href="../Source-Code/index.html"><strong aria-hidden="true">11.</strong> 怎么看源码</a></li><li class="chapter-item expanded "><a href="../Source-Unsafe/index.html" class="active"><strong aria-hidden="true">12.</strong> Unsafe</a></li><li class="chapter-item expanded "><a href="../Source-Atomic/index.html"><strong aria-hidden="true">13.</strong> Atomic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Source-Atomic/AtomicInteger.html"><strong aria-hidden="true">13.1.</strong> AtomicInteger</a></li><li class="chapter-item expanded "><a href="../Source-Atomic/AtomicIntegerArray.html"><strong aria-hidden="true">13.2.</strong> AtomicIntegerArray</a></li><li class="chapter-item expanded "><a href="../Source-Atomic/Striped64.html"><strong aria-hidden="true">13.3.</strong> Striped64</a></li><li class="chapter-item expanded "><a href="../Source-Atomic/Adder.html"><strong aria-hidden="true">13.4.</strong> Adder</a></li><li class="chapter-item expanded "><a href="../Source-Atomic/FieldUpdater.html"><strong aria-hidden="true">13.5.</strong> FieldUpdater</a></li><li class="chapter-item expanded "><a href="../Source-Atomic/StampedReference.html"><strong aria-hidden="true">13.6.</strong> StampedReference</a></li></ol></li><li class="chapter-item expanded "><a href="../Source-AQS/AQS.html"><strong aria-hidden="true">14.</strong> AbstractQueuedSynchronizer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Source-AQS/blocking-exclusive.html"><strong aria-hidden="true">14.1.</strong> 互斥锁</a></li><li class="chapter-item expanded "><a href="../Source-AQS/blocking-shared.html"><strong aria-hidden="true">14.2.</strong> 共享锁</a></li><li class="chapter-item expanded "><a href="../Source-AQS/timeout.html"><strong aria-hidden="true">14.3.</strong> 超时</a></li><li class="chapter-item expanded "><a href="../Source-AQS/interrupt.html"><strong aria-hidden="true">14.4.</strong> 中断</a></li><li class="chapter-item expanded "><a href="../Source-AQS/cancellation.html"><strong aria-hidden="true">14.5.</strong> 取消</a></li><li class="chapter-item expanded "><a href="../Source-AQS/condition.html"><strong aria-hidden="true">14.6.</strong> 条件变量</a></li><li class="chapter-item expanded "><a href="../Source-AQS/Summary.html"><strong aria-hidden="true">14.7.</strong> 小结</a></li></ol></li><li class="chapter-item expanded "><a href="../Source-Lock/Lock.html"><strong aria-hidden="true">15.</strong> Lock</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Source-Lock/ReentrantLock.html"><strong aria-hidden="true">15.1.</strong> ReentrantLock</a></li><li class="chapter-item expanded "><a href="../Source-Lock/ReentrantReadWriteLock.html"><strong aria-hidden="true">15.2.</strong> ReentrantReadWriteLock</a></li><li class="chapter-item expanded "><a href="../Source-Lock/StampedLock.html"><strong aria-hidden="true">15.3.</strong> StampedLock</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <a id="home" class="icon-button" type="button" title="Go to Home" href="/">
                            <i class="fa fa-home"></i>
                        </a>

                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Java 并发知识</h1>

                    <div class="right-buttons">

                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#unsafe" id="unsafe">Unsafe</a></h1>
<blockquote>
<p>Just because you can break the rules, doesn’t mean you should break the
rules—unless you have a good reason. -- Ben Evans</p>
</blockquote>
<h2><a class="header" href="#上层需求" id="上层需求">上层需求</a></h2>
<p><code>sun.misc.Unsafe</code> 是一个底层包，它的方法几乎都是 native 方法，提供了利用底层特性的能力，如使用 CPU 及其它硬件的特性的能力，绕过 JVM 对内存做特殊操作的能力等。强大的能力通常意味着巨大的风险，使用 <code>Unsafe</code> 极其容易出错，一般应用程序中也不应该使用。</p>
<p>由于 <code>Unsafe</code> 大多是 native 方法，所以只能看 openjdk 的 <a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/unsafe.cpp">Unsafe.cpp</a>。</p>
<h2><a class="header" href="#获取实例" id="获取实例">获取实例</a></h2>
<p>在 JUC 的代码中，常常会这么获取 <code>Unsafe</code> 的实例：</p>
<pre><code class="language-java">private static final Unsafe unsafe = Unsafe.getUnsafe();
</code></pre>
<p>如果复制这份代码尝试运行，发现会报 <code>SecurityException</code>，根本无法运行。这是因为
<code>Unsafe</code> 实在是太危险了，因此不允许在应用程序代码中使用，如果要使用，只能通过反射的方式获得实例：</p>
<pre><code class="language-java">Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
f.setAccessible(true);
return (Unsafe) f.get(null);
</code></pre>
<p>（另：JDK 1.9 中 <code>Unsafe</code> 类被移到 <code>jdk.unsupported</code> 模块，显然是不希望开发者继续使用，一些重要的功能通过 <a href="http://openjdk.java.net/jeps/193">Variable
Handles</a> 提供。）</p>
<h2><a class="header" href="#field-offset" id="field-offset">Field Offset</a></h2>
<p>第一个重要的概念是 Field Offset，即一个类中某个字段的偏移量，可以看到 <code>Unsafe</code>
中的方法在操作类中某个字段时，几乎都是直接操作字段在内存中的偏移量。</p>
<h3><a class="header" href="#内存布局" id="内存布局">内存布局</a></h3>
<p>类在内存中的结构 JVM 规范中并没有定义，这里以 HotSpot JVM 为例，它使用了
<a href="https://github.com/openjdk/jdk/tree/jdk8-b120/hotspot/src/share/vm/oops">Ordinary Object
Pointers(OOPS)</a>
的数据结构<sup class="footnote-reference"><a href="#memory-layout">1</a></sup>，我们不关心细节，只是有个大概的印象。</p>
<p>对于下面这个类：</p>
<pre><code>public class SuperClass {
    private int id;
    private ZonedDateTime createTime;
}

public class SubClass extends SuperClass {
    private boolean deleted;
    private String content;
}
</code></pre>
<p>使用 <code>jol-core</code> 打印出类的内存布局（<code>jol</code> 只支持 HotSpot）：</p>
<pre><code>SubClass object internals:
 OFFSET  SIZE                      TYPE DESCRIPTION                               VALUE
      0    12                           (object header)                           N/A
     12     4                       int SuperClass.id                             N/A
     16     4   java.time.ZonedDateTime SuperClass.createTime                     N/A
     20     1                   boolean SubClass.deleted                          N/A
     21     1                   boolean SubClass.valid                            N/A
     22     2                           (alignment/padding gap)
     24     4          java.lang.String SubClass.content                          N/A
     28     4                           (loss due to the next object alignment)
Instance size: 32 bytes
Space losses: 2 bytes internal + 4 bytes external = 6 bytes total
</code></pre>
<p>我们大概需要知道：</p>
<ul>
<li>包括父类继承的字段，都存放在同一片内存区域中</li>
<li>Java object 有固定大小的 object header</li>
<li>字段为了对齐会加上 padding，这是 CPU 的限制，CPU 为了速度，取数时会对齐到
word 上。如上例 <code>valid</code> 只占 1 个字节，后面有 2B 的 padding</li>
<li>如果有多个小字段，为了减少对齐浪费的空间，会移动字段，如 <code>valid</code> 被移到了
<code>deleted</code> 之后。</li>
</ul>
<p>当然 JVM 还有其它一些机制，如压缩对象等会影响对象的内存结构，这里不细说。</p>
<h3><a class="header" href="#objectfieldoffset" id="objectfieldoffset">objectFieldOffset</a></h3>
<p><a href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/sun/misc/Unsafe.java#L670">Unsafe.objectFieldOffset</a>
可以用来获取字段的偏移量，不过文档里说明，获取的 offset 并不保证代表了字段的实际偏移量，而只是偏移量的代号。不过在 HotSpot 的<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/unsafe.cpp#L722">实现</a>中，我们看它实际上返回的就是偏移量的字节，我们可以验证一下：</p>
<pre><code class="language-java">Unsafe unsafe = getUnsafe();
System.out.println(unsafe.objectFieldOffset(SubClass.class.getDeclaredField(&quot;valid&quot;)));

// 21
</code></pre>
<p>看到 <code>21</code> 就是之前内存结构中 <code>SubClass.valid</code> 所在的偏移量。不过既然文档说了不保证 <code>objectFieldOffset</code> 返回的是偏移量，我们也不应该做这个假设。</p>
<h2><a class="header" href="#字段的访问操作" id="字段的访问操作">字段的访问操作</a></h2>
<p>大概有这么几类：</p>
<pre><code class="language-java">// 获取字段的值，类似的还有 getInt，getDouble，getLong，getChar 等
public native Object getObject(Object o, long offset);
// 设置字段的值，类似的还有 putInt，putDouble，putLong，putChar 等
public native void putObject(Object o, long offset, Object x);

// 获取字段的值，使用 volatile 语义，有 Int, Double, Long, Char 等变种
public native Object getObjectVolatile(Object o, long offset);
// 设置字段的值，使用 volatile 语义，有 Int, Double, Long, Char 等变种
public native void putObjectVolatile(Object o, long offset, Object x);

// putObjectVolatile 的变种，设置的值不保证被其他线程立即看到。
// 只有在 field 被 volatile 修饰符修饰时有效
public native void putOrderedObject(Object o, long offset, Object x);
</code></pre>
<p>其中 <code>getXXX/putXXX</code> 与 <code>getXXXVolatile/setXXXVolatile</code> 与 Java 中的赋值/取值的语义相同，唯一的不同是 <code>Unsafe</code> 中的方法直接操作内存，可以无视 Java 中的访问控制，即无视 <code>private</code>，<code>protected</code> 等修饰符。</p>
<h3><a class="header" href="#putordered" id="putordered">putOrdered</a></h3>
<p><code>putOrderedXXX</code> 需要特殊说明，它是 JUC 中常用的方法，通常用来实现惰性赋值。例如需要将某个变量设置成 <code>NULL</code> 允许 GC 释放对应的内存。</p>
<p><code>putOrderedXXX</code> 会保证同线程多次写入之间是有序的，但不保证写入的值<strong>立即</strong>对其它线程可见。这一区别使得它的性能比 <code>putXXXVolatile</code> 方法要高出不少。</p>
<p>更底层来看，<code>putOrderedXXX</code> 只需要使用 <code>StoreStore</code> 屏障来保证有序即可，这在多数的体系结构下不需要额外的操作或代价很低，而 <code>volatile</code> 写则需要 <code>StoreLoad</code>
屏障，而这个操作通常代价很高<sup class="footnote-reference"><a href="#jdk-lazy-set">2</a></sup>。</p>
<p>开始看代码找到
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/unsafe.cpp#L432">unsafe.cpp</a>
，却发现 <code>putOrderedObject</code> 的实现与 <code>putObjectVolatile</code> 一模一样。后来才发现内存屏障的区别是 JIT 期间优化的，在
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/opto/library_call.cpp#L3042">LibraryCallKit::inline_unsafe_ordered_store</a>
方法中实现，可以对比 volatile 变量写入的逻辑
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/opto/library_call.cpp#L2504">LibraryCallKit::inline_unsafe_access</a>
：</p>
<pre><code class="language-cpp">bool LibraryCallKit::inline_unsafe_ordered_store(BasicType type) {
  // ...
  insert_mem_bar(Op_MemBarRelease);
  insert_mem_bar(Op_MemBarCPUOrder);
  // Ensure that the store is atomic for longs:
  const bool require_atomic_access = true;
  Node* store;
  if (type == T_OBJECT) // reference stores need a store barrier.
    store = store_oop_to_unknown(control(), base, adr, adr_type, val, type);
  else {
    store = store_to_memory(control(), adr, val, type, adr_type, require_atomic_access);
  }
  insert_mem_bar(Op_MemBarCPUOrder);
  return true;
}
---------------------------------------------------------------------------------------------------------
bool LibraryCallKit::inline_unsafe_access(bool is_native_ptr, bool is_store, BasicType type, bool is_volatile) {
  // ....
  if (is_volatile) {
    if (!is_store)
      insert_mem_bar(Op_MemBarAcquire);
    else
      insert_mem_bar(Op_MemBarVolatile); // ①
  }
  if (need_mem_bar) insert_mem_bar(Op_MemBarCPUOrder);
  return true;
}
</code></pre>
<p>注意 ① 处多出的一个 <code>Volatile</code> 屏障，可以在
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/x86_64.ad#L6381">x86_64.ad</a>
文件中确认它是一个 <code>StoreLoad</code> 屏障。而 <code>putOrderedXXX</code> 则没有这个屏障。</p>
<h2><a class="header" href="#cas" id="cas">CAS</a></h2>
<p><code>Unsafe</code> 中主要提供了如下方法：</p>
<pre><code class="language-java">// native 方法实现，有 Int、Long 变种
public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);

// 在 compareAndSwapObject 基础上的封装，不断执行 CAS 直到成功
public final Object getAndSetObject(Object o, long offset, Object newValue) {
    Object v;
    do {
        v = getObjectVolatile(o, offset);
    } while (!compareAndSwapObject(o, offset, v, newValue));
    return v;
}
</code></pre>
<h3><a class="header" href="#cas-语义" id="cas-语义">CAS 语义</a></h3>
<p>Compare And Swap(CAS) 是 lock-free 算法中最基础的模块，通常由 CPU 指令直接支持。函数通常有两个参数：<code>oldValue</code> 与 <code>newValue</code>，内部逻辑的伪代码如下：</p>
<pre><code class="language-java">currentValue = readValue();
if (currentValue == oldValue) {
  setValue(newValue);
  return true;
} else {
  return false;
}
</code></pre>
<p>CAS 机制要能正确工作，需要保证原子性和可见性。原子性的要求显而易见，在 CAS 过程中不能执行其它指令改变现有的值。同时至少要保证 <code>readValue</code> 读取的是最新的值，但 <code>setValue</code> 的值是否对其它线程可见，似乎没有保证，不过一方面一般会对
<code>volatile</code> 变量执行 CAS 操作，另一方面 x86 架构下使用 <code>LOCK CMPXCHG</code> 指令时会保证写入结果对其它线程可见。</p>
<h3><a class="header" href="#cas-实现" id="cas-实现">CAS 实现</a></h3>
<p><code>compareAndSwapObject</code> 方法的实现可以在
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/unsafe.cpp#L1178">unsafe.cpp</a>
找到，一路追踪最终发现会调用
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/atomic.hpp#L86">atomic.hpp:cmpxchg</a>
。</p>
<pre><code class="language-cpp">// Performs atomic compare of *dest and compare_value, and exchanges *dest with exchange_value
// if the comparison succeeded.  Returns prior value of *dest.  Guarantees a two-way memory
// barrier across the cmpxchg.  I.e., it's really a 'fence_cmpxchg_acquire'.
       static jbyte    cmpxchg    (jbyte    exchange_value, volatile jbyte*    dest, jbyte    compare_value);
inline static jint     cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value);
// See comment above about using jlong atomics on 32-bit platforms
inline static jlong    cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value);

       static unsigned int cmpxchg(unsigned int exchange_value,
                                   volatile unsigned int* dest,
                                   unsigned int compare_value);

inline static intptr_t cmpxchg_ptr(intptr_t exchange_value, volatile intptr_t* dest, intptr_t compare_value);
inline static void*    cmpxchg_ptr(void*    exchange_value, volatile void*     dest, void*    compare_value);
</code></pre>
<p>这里的注释很重要，说明了至少会保证在 CAS 前加上 <code>fence</code>，在后面加上<code>acquire</code>屏障。这些内联方法在不同平台上有不同的实现，如 Linux(x86) 的实现在文件
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp#L144-L151">atomic_linux_x86.inline.hpp</a>
中：</p>
<pre><code class="language-cpp">inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {
  bool mp = os::is_MP();
  __asm__ __volatile__ (LOCK_IF_MP(%4) &quot;cmpxchgq %1,(%3)&quot;
                        : &quot;=a&quot; (exchange_value)
                        : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                        : &quot;cc&quot;, &quot;memory&quot;);
  return exchange_value;
}
</code></pre>
<p>不同的数据类型有不同的实现，这里列出的是 <code>long</code> 型数据的实现，可以看到用的是
<code>cmpxchgq</code> 指令，且在多核条件下会加 <code>LOCK</code> 前缀。<code>cmpxchg</code> 系列指令就是 x86 提供的 CAS 指令。不过我们看到代码里并没有手工加内存屏障，这是因为在 x86 架构中，
<code>LOCK</code> 前缀本身会实现类似 <code>StoreLoad</code> 屏障的功能，因此不需要额外插入屏障。</p>
<h2><a class="header" href="#parkunpark" id="parkunpark">park/unpark</a></h2>
<p>处理并发不可避免要处理线程的阻塞与唤醒，在 <code>Unsafe</code> 包中提供了下面两个函数：</p>
<pre><code class="language-java">public native void unpark(Object thread);

public native void park(boolean isAbsolute, long time);
</code></pre>
<p>这两个方法的语义在它们的<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/sun/misc/Unsafe.java#L995">注释</a>中有比较详细的说明，这里简要翻译如下：</p>
<p><code>park</code> 方法会阻塞当前线程，方法会在下列情况下返回（线程被唤醒）：</p>
<ul>
<li>有线程调用了 <code>unpark</code> 方法，或在 <code>park</code> 前已经有线程调用了 <code>unpark</code> 方法</li>
<li>线程被中断了（<code>Thread::interrupt</code>）</li>
<li><code>isAbsolute</code> 为 <code>false</code>，<code>time &gt; 0</code> 且已经过去了 <code>time</code> 纳秒</li>
<li><code>isAbsolute</code> 为 <code>true</code>，且自 epoch 以来已经过了 <code>time</code> 秒</li>
<li>其它未知原因出错，直接返回</li>
</ul>
<p>与 <code>park</code> 对应，<code>unpark</code> 方法用来唤醒 <code>park</code>。要注意 <code>unpark</code> 唤醒的机制是设置一个标志位：</p>
<ul>
<li>调用 <code>park</code> 时检测到标志位会清除标志并直接返回已经阻塞在 <code>park</code> 的线程在</li>
<li><code>unpark</code> 调用时会被唤醒，同样消除标志并返回</li>
</ul>
<p>因此，<code>unpark</code> 调用的时机并不重要，它能保证至少“唤醒”一次 <code>unpark</code>。</p>
<h3><a class="header" href="#实现" id="实现">实现</a></h3>
<p>首先我们</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/park.hpp#L56">Parker</a>
中使用了 <code>_counter</code> 作为标识，它虽然是个 <code>int</code>，实际上只会取值 <code>0</code> 和 <code>1</code>。</p>
<pre><code class="language-cpp">class Parker : public os::PlatformParker {
private:
  volatile int _counter ;
  Parker * FreeNext ;
  JavaThread * AssociatedWith ; // Current association
  // ...
}
</code></pre>
<p>然后注意 <code>park</code> 如果需要阻塞，是通过（Linux）系统的
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5932">pthread_cond_wait</a>
方法，等待条件变量进入阻塞：</p>
<pre><code class="language-cpp"> assert(_cur_index == -1, &quot;invariant&quot;);
  if (time == 0) {
    _cur_index = REL_INDEX; // arbitrary choice when not timed
    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;  // 阻塞
  } else {
    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;
    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;
    if (status != 0 &amp;&amp; WorkAroundNPTLTimedWaitHang) {
      pthread_cond_destroy (&amp;_cond[_cur_index]) ;
      pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());
    }
  }
  // ...

  _counter = 0 ;  // 清除标志
</code></pre>
<p>同时在被唤醒后继续执行，将 <code>_counter</code> 设置为 <code>0</code>。同理，<code>unpark</code> 方法通过
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5974">pthread_cond_signal</a>
方法唤醒等待条件变量的线程，当然，在唤醒前会将 <code>_counter</code> 置为 <code>1</code>：</p>
<pre><code class="language-cpp">void Parker::unpark() {
  int s, status ;
  status = pthread_mutex_lock(_mutex);
  assert (status == 0, &quot;invariant&quot;) ;
  s = _counter;
  _counter = 1; // 设置标志
  if (s &lt; 1) {
    // thread might be parked
    if (_cur_index != -1) {
      // thread is definitely parked
      if (WorkAroundNPTLTimedWaitHang) {
        status = pthread_cond_signal (&amp;_cond[_cur_index]); // 唤醒线程
        assert (status == 0, &quot;invariant&quot;);
        status = pthread_mutex_unlock(_mutex);
        assert (status == 0, &quot;invariant&quot;);
      }
   // ...
}
</code></pre>
<p>顺带一提，我们看到 <code>Thead::interrupt</code> 最终调用的 native 方法
<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L4220">os::interrupt</a>
最终也会调用 <code>Parker::unpark</code> 来唤醒线程。</p>
<h2><a class="header" href="#小结" id="小结">小结</a></h2>
<p>本章大致从源码层面讲解了 <code>Unsafe</code> 提供的部分能力，这些能力是 JUC 并发类的基石，这些 <code>unsafe</code> 方法都是 native 方法，用来绕开 java 封装的语义，提供更底层的操作能力，而增加这么多复杂性的目的，就是提高程序的性能。</p>
<p>我们先简单介绍了 Java 对象的内存布局，以及获取字段偏移量的方法，偏移量是其它方法的先决条件。</p>
<p>之后介绍了 <code>getXXX/putXXX</code> 和 <code>getXXXVolatile/putXXXVolatile</code>，它们分别代表了 Java 中普通变量和 volatile 变量的读写能力，不同的是它们可以绕开修饰符的限制。另外还单独讲解了 <code>putOrderedXXX</code>，它能高效的实现延迟设置的功能。</p>
<p>之后介绍了 CAS，它是 lock-free 算法的基石，在 JUC 的实现中无孔不入，CAS 底层直接对应了 CPU 的指令，并保证 <code>fence_cmpxchg_acquire</code> 的语义，可以简单理解成保证了原子性、有序性、可见性。</p>
<p>最后介绍了 <code>park</code>/<code>unpark</code> 语义，用来阻塞和唤醒线程。唤醒的机制是设置与清除“标志”，因此可以多次，甚至提前唤醒。阻塞与唤醒使用了操作系统的条件变量（condition
variable）。</p>
<p>如果不关心底层细节只需要了解相关的语义即可，如果关心实现细节，需要理解很多内存屏障以及背后的重排序、可见性相关的内容，感兴趣的读者可以阅读相关资料，一定会有更大的收获。</p>
<h2><a class="header" href="#参考" id="参考">参考</a></h2>
<ul>
<li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a> 详细解释了 Java 中的内存屏障</li>
<li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a> 分析了 <code>Unsafe</code> 包含的方方面面和使用示例</li>
<li><a href="https://www.ktanx.com/blog/p/3100">JUC中Atomic class之lazySet的一点疑惑</a> 源码角度分析了 lazySet 及 putOrderedXXX 的实现原理</li>
<li><a href="https://youtu.be/VBnLW9mKMh4">JAX London 2012: Locks? We Don't Need No Stinkin'
Locks!</a> distruptor 对一些高级特性的使用，其中包括 <code>lazySet</code> 的讲解</li>
</ul>
<hr />
<div class="footnote-definition" id="memory-layout"><sup class="footnote-definition-label">1</sup>
<p>参考 <a href="https://www.baeldung.com/java-memory-layout">Memory Layout of Objects in Java</a></p>
</div>
<div class="footnote-definition" id="jdk-lazy-set"><sup class="footnote-definition-label">2</sup>
<p>参考 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6275329">JDK-6275329 : Add lazySet methods to atomic classes</a> 中的描述。</p>
</div>


                        <hr />
                        <div id="disqus_thread"></div>
                        <div class="giscus"></div>
                    </main>


                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../Source-Code/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../Source-Atomic/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>

                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../Source-Code/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../Source-Atomic/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];
            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
                ga('create', 'UA-39956831-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script>
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>
        

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        

        

        <!-- giscus -->
        <script src="https://giscus.app/client.js"
                data-repo="lotabout/lotabout.github.io"
                data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw=="
                data-category="Announcements"
                data-category-id="DIC_kwDOATmmt84ClmcD"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="0"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="zh-CN"
                crossorigin="anonymous"
                async>
        </script>

    </div>
    </body>
</html>
