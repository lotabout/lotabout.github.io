<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文主要梳理 Rust 和 Python 的 async 实现中涉及的一些通用概念和实现机制。头脑中储备一些异步编程底层的实现原理，可以帮助我们更好地掌握异步编程。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>异步编程（async）底层实现机制 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/async/" rel="tag">async</a><a class="post-tag-noise-link" href="/tags/coroutine/" rel="tag">coroutine</a><a class="post-tag-noise-link" href="/tags/python/" rel="tag">python</a><a class="post-tag-noise-link" href="/tags/rust/" rel="tag">rust</a></div><div class="post-time">2022-03-27</div></div></div><div class="container post-header"><h1>异步编程（async）底层实现机制</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%9A%E5%8F%AF%E6%9A%82%E5%81%9C%E5%8F%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">1.</span> <span class="toc-text">协程：可暂停可恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7-stack-frame"><span class="toc-number">1.1.</span> <span class="toc-text">栈帧（Stack Frame）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-%E8%AE%B0%E5%BD%95%E6%A0%88%E5%B8%A7"><span class="toc-number">1.2.</span> <span class="toc-text">Python 记录栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rust-%E7%BC%96%E8%AF%91%E6%88%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">Rust 编译成状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E4%B8%8E%E4%B8%AD%E6%96%AD-%E5%9B%9E%E8%B0%83"><span class="toc-number">2.</span> <span class="toc-text">轮询与中断&#x2F;回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-number">2.1.</span> <span class="toc-text">轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E-waker"><span class="toc-number">2.2.</span> <span class="toc-text">中断与 waker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">Python 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>本文主要梳理 Rust 和 Python 的 async 实现中涉及的一些通用概念和实现机制。头脑中储备一些异步编程底层的实现原理，可以帮助我们更好地掌握异步编程。</p>
<h2 id="协程：可暂停可恢复"><a class="header-anchor" href="#协程：可暂停可恢复"></a>协程：可暂停可恢复</h2>
<p>正常函数调用的控制流是“单入单出”，从调用开始，正常或异常返回后结束，调用的栈帧也随之销毁。而异步编程要求在函数执行到一半时，“暂停”控制流，在未来的某个时刻再“恢复”。由于控制流尚未结束，因此调用链路上的栈帧还不能被销毁，这些信息需要以某种形式保存。可暂停可恢复的控制流，加上它所保存的信息，就可以称为“协程”。</p>
<h3 id="栈帧-stack-frame"><a class="header-anchor" href="#栈帧-stack-frame"></a>栈帧（Stack Frame）</h3>
<p>函数调用过程中使用的临时变量会记录到栈上，这些信息是与某个函数的某次调用绑定的，调用结束后就被废弃，这些数据就是栈帧。物理形态上，通常栈帧是“叠”在一起的，例如函数 A 中调用了函数 B，而 B 又调用了 C，则在 C 运行中，栈的状态类似下图：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|    ...     |</span><br><span class="line">| Frame of C |</span><br><span class="line">+------------+</span><br><span class="line">| Frame of B |</span><br><span class="line">+------------+</span><br><span class="line">| Frame of A |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure></div>
<h3 id="python-记录栈帧"><a class="header-anchor" href="#python-记录栈帧"></a>Python 记录栈帧</h3>
<p>Python coroutine<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 的处理方式是直接保存栈帧。调用的最内层通过 <code>yield</code>
暂停控制流，中间层通过 <code>yield from</code> 或 <code>await</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 将内层的
coroutine 一路往外传，需要恢复时，再使用 <code>send</code> 方法恢复执行<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pause inner&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;resumed inner&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">middle</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pause middle&#x27;</span>)</span><br><span class="line">    value = (<span class="keyword">yield</span> <span class="keyword">from</span> inner())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;resumed middle&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">coro = middle()   <span class="comment"># 因为 yield from 的机制，coro 指向 inner 的状态</span></span><br><span class="line">coro.send(<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># pause middle</span></span><br><span class="line"><span class="comment"># pause inner</span></span><br><span class="line"></span><br><span class="line">x.send(<span class="literal">None</span>)      <span class="comment"># 可以看到是从 inner 开始恢复的</span></span><br><span class="line"><span class="comment"># resumed inner</span></span><br><span class="line"><span class="comment"># resumed middle</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># StopIteration                             Traceback (most recent call last)</span></span><br><span class="line"><span class="comment"># &lt;ipython-input-19-9cc02a983a52&gt; in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># ----&gt; 1 coro.send(None)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># StopIteration: 20</span></span><br></pre></td></tr></table></figure></div>
<p>注意在 coroutine 中，最终的返回值是通过 <code>StopIteration</code> 带出来的。</p>
<p>此外，外层拿到的 <code>coro</code> 其实包含了最内层 <code>inner</code> 的栈帧（需要了解
<a href="https://peps.python.org/pep-0380/">yield from</a> 的机制），因此第二次调用
<code>coro.send(None)</code> 时，会从 <code>inner</code> 函数 <code>yield</code> 处恢复执行。</p>
<h3 id="rust-编译成状态机"><a class="header-anchor" href="#rust-编译成状态机"></a>Rust 编译成状态机</h3>
<p>对于缺少 GC 的语言来说，移动、复制栈帧是个原理可行，实际几乎不可行的操作。这些语言里手工创建的指针，可以指向栈上分配的内存，指针还可能被其它线程引用。栈帧移动时，这些指针都需要“修复”；栈帧复制时，数据多了份引用，内存释放又成问题。</p>
<p>Rust 使用了“状态机”的方式来实现控制流的暂停、恢复的能力<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。</p>
<p>首先是最内层的暂停逻辑，与 Python 不同，内层没有专门的暂停机制，只约定了接口，如果（因为资源未就绪）要暂停，则返回一个特殊值（<code>Poll::Pending</code>），由调用方来决定是否真的暂停和处理恢复。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>Python 的中间层会通过 <code>yield from</code> 向外传递栈帧<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，那 Rust
的中间层如何对外层提供暂停、恢复的能力呢？Rust 里提供了 <code>await</code> 关键词来表达等待内层的 future<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">inner1</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">u32</span>&gt; &#123;</span><br><span class="line">    future::<span class="title function_ invoke__">ready</span>(<span class="number">1</span>) <span class="comment">// 返回的是 Future 的一个具体实现，这里省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">inner2</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">u32</span>&gt; &#123;</span><br><span class="line">    future::<span class="title function_ invoke__">ready</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">middle</span>() <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">inner1</span>().<span class="keyword">await</span>; <span class="comment">// await 代表等待内层的 future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">inner2</span>().<span class="keyword">await</span>;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>那么 <code>async/await</code> 底层发生了什么？Rust 编译器会做这么几件事：</p>
<ol>
<li>遇到 <code>async fn</code> 定义时，会把 <code>middle</code> 方法的返回改为 <code>Future&lt;Output=...&gt;</code></li>
<li>将代码逻辑以 <code>await</code> 为拆分点，拆成状态机的 N 个状态，每个状态存储下个
await 可见的变量和 future</li>
<li>将两个 await 之间的代码，转换成状态机的转移逻辑</li>
</ol>
<p>上面的例子编译器会编译成类似下面的这些代码<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态存储</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StartState</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WaitingInner1State</span> &#123;</span><br><span class="line">    inner1_future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WaitingInner2State</span> &#123;</span><br><span class="line">    x: <span class="type">usize</span>,</span><br><span class="line">    inner2_future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EndState</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">StateMachine</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Start</span>(StartState),</span><br><span class="line">    <span class="title function_ invoke__">WaitingInner1</span>(WaitingInner1State),</span><br><span class="line">    <span class="title function_ invoke__">WaitingInner2</span>(WaitingInner2State),</span><br><span class="line">    <span class="title function_ invoke__">End</span>(EndState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移逻辑</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">StateMachine</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">usize</span>; <span class="comment">// return type of `middle`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span> &#123; <span class="comment">// <span class="doctag">TODO:</span> handle pinning</span></span><br><span class="line">                StateMachine::<span class="title function_ invoke__">Start</span>(state) =&gt; &#123;         <span class="comment">// 开始到第一个 await</span></span><br><span class="line">                    inner1_future = <span class="title function_ invoke__">inner1</span>();</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">state</span> = WaitingInner1State &#123;inner1_future&#125;;</span><br><span class="line">                    *<span class="keyword">self</span> = StateMachine::<span class="title function_ invoke__">WaitingInner1</span>(state);</span><br><span class="line">                &#125;</span><br><span class="line">                StateMachine::<span class="title function_ invoke__">WaitingInner1</span>(state) =&gt; &#123; <span class="comment">// 第一个 await 到第二个 await</span></span><br><span class="line">                    <span class="keyword">match</span> state.inner1_future.<span class="title function_ invoke__">poll</span>(cx) =&gt; &#123;</span><br><span class="line">                        Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                        Poll::<span class="title function_ invoke__">Ready</span>(x) =&gt; &#123;</span><br><span class="line">                            inner2_future = <span class="title function_ invoke__">inner1</span>();</span><br><span class="line">                            <span class="keyword">let</span> <span class="variable">state</span> = WaitingInner2State &#123;x, inner2_future&#125;;</span><br><span class="line">                            *<span class="keyword">self</span> = StateMachine::<span class="title function_ invoke__">WaitingInner2</span>(state);</span><br><span class="line">                &#125;&#125;&#125;</span><br><span class="line">                StateMachine::<span class="title function_ invoke__">WaitingInner2</span>(state) =&gt; &#123; <span class="comment">// 第二个 await 到结束</span></span><br><span class="line">                    <span class="keyword">match</span> state.inner2_future.<span class="title function_ invoke__">poll</span>(cx) =&gt; &#123;</span><br><span class="line">                        Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                        Poll::<span class="title function_ invoke__">Ready</span>(y) =&gt; &#123;</span><br><span class="line">                            <span class="keyword">let</span> <span class="variable">ret</span> = state.x + y;</span><br><span class="line">                            *<span class="keyword">self</span> = StateMachine::<span class="title function_ invoke__">End</span>(EndState);</span><br><span class="line">                            <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(ret)</span><br><span class="line">                &#125;&#125;&#125;</span><br><span class="line">                StateMachine::<span class="title function_ invoke__">End</span>(state) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;poll called after Poll::Ready was returned&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async def 编译成了返回 Future</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">middle</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    StateMachine::<span class="title function_ invoke__">Start</span>(StartState&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到中间层返回的 StateMachine 本身记录了内部调用的 Future 所处的状态。最外层的调用方如果需要恢复执行，只需再调用 <code>middle</code> 返回 future 的 <code>poll</code> 方法即可，
<code>middle</code> 会根据当前状态决定去 <code>poll</code> 哪个内层 future。</p>
<h2 id="轮询与中断-回调"><a class="header-anchor" href="#轮询与中断-回调"></a>轮询与中断/回调</h2>
<p>异步编程的特征之一，是当资源未就绪时，先暂停当前控制流，先执行其它可推进的逻辑，等资源就绪时，再恢复之前暂停的控制流。那什么时候才知道资源就绪呢？一般有两种方法：轮询与中断。</p>
<h3 id="轮询"><a class="header-anchor" href="#轮询"></a>轮询</h3>
<p>轮询很好理解，就是外围调用方不断调用 <code>poll</code> 方法去查看当前资源的状态是否就绪：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">future = <span class="title function_ invoke__">middle</span>();</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> future.<span class="title function_ invoke__">poll</span>() &#123;</span><br><span class="line">        Poll::Pending =&gt; &#123;&#125;</span><br><span class="line">        Poll::<span class="title function_ invoke__">Ready</span>(ret_val) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行逻辑</span></span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>但如果是这么做，资源未就绪前会不断执行 <code>future.poll</code>，浪费 CPU。此时空闲的 CPU
可以用来处理其它就绪的 future，于是可以把所有需要轮询的协程添加到一个队列里，这样一个线程就可以处理 N 个协程。伪代码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    future = waiting_queue.<span class="title function_ invoke__">pop_front</span>() <span class="comment">// 队列存放所有 future</span></span><br><span class="line">    <span class="keyword">match</span> future.<span class="title function_ invoke__">poll</span>() &#123;</span><br><span class="line">        Poll::Pending =&gt; &#123;</span><br><span class="line">            waiting_queue.<span class="title function_ invoke__">push_back</span>(future)</span><br><span class="line">        &#125;</span><br><span class="line">        Poll::<span class="title function_ invoke__">Ready</span>(ret_val) =&gt; &#123;</span><br><span class="line">            <span class="comment">// ① 执行正常逻辑</span></span><br><span class="line">        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>这会引申出一个问题：在 ① 中，如果 middle future 的结果就绪了，接下来需要执行哪部分代码呢？显然需要从 future 暂停的地方接着执行（即 outer 的后续逻辑），但我们怎么找到外层的逻辑？</p>
<p>一种想法是把外层逻辑也封装成一个 future<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>，队列里直接存放outer
future 而不是 middle future，恢复时只要执行 outer future 的 <code>poll</code>方法即可。这就是<strong>异步编程的传染性</strong>，只要内部有一处异步，它的每个调用方都需要是异步的，一直到顶层的 main 函数<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>。</p>
<p>于是就像有多个线程一样，我们的队列里可以存放 N 个顶层的 future，可以类比成轮询
N 个 main 函数。这个不断从队列中获取新的协程并调用 <code>poll</code> 的角色在 Rust 里叫
executor<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    main_future = waiting_queue.<span class="title function_ invoke__">pop_front</span>()</span><br><span class="line">    <span class="keyword">match</span> main_future.<span class="title function_ invoke__">poll</span>() &#123;</span><br><span class="line">        Poll::Pending =&gt; &#123;</span><br><span class="line">            <span class="comment">// ② 处理队列中的下一个</span></span><br><span class="line">            waiting_queue.<span class="title function_ invoke__">push_back</span>(future)</span><br><span class="line">        &#125;</span><br><span class="line">        Poll::<span class="title function_ invoke__">Ready</span>() =&gt; &#123;</span><br><span class="line">            <span class="comment">// future 完成退出</span></span><br><span class="line">        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure></div>
<p>② 中的逻辑会不断把未就绪的 future 放入队列，这样每轮轮询时都会 poll 所有future，这样依旧会浪费很多资源（CPU &amp; IO），最理想的方式是每次 poll 时只poll 那些“很有希望 ready”的 future。这就是我们下面要说的“中断”的模式，当资源就绪时，再把
future 加入队列。</p>
<h3 id="中断与-waker"><a class="header-anchor" href="#中断与-waker"></a>中断与 waker</h3>
<p>我们希望 future 只在资源就绪时才被重新放回队列<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>，于是
executor 需要提供如下方法（伪代码）：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ready_queue</span> = Queue::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">futures</span>: HashMap&lt;<span class="type">usize</span>, RefCell&lt;Future&lt;Output=()&gt;&gt;&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span>: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ① 监听 ready_queue 并对其中的元素进行 poll</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_</span> = ready_queue.<span class="title function_ invoke__">pop_front</span>().<span class="title function_ invoke__">poll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 提供方法监听新的 future，需要将其加入 ready_queue 进行首次 poll</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_future</span>(future: RefCell&lt;Future&lt;Output=()&gt;&gt;) &#123;</span><br><span class="line">    ready_queue.<span class="title function_ invoke__">push_back</span>(future.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">    num += <span class="number">1</span>;</span><br><span class="line">    futures.<span class="title function_ invoke__">insert</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③ 提供机制在 future 就绪时将其加入 ready_queue 中，等待下次 poll</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">wake_up</span>(n: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">future</span> = futures.<span class="title function_ invoke__">remove</span>(&amp;n).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    ready_queue.<span class="title function_ invoke__">push_back</span>(future);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>现在的问题是：“谁”负责在“什么时候”调用 <code>wake_up</code> 方法？</p>
<p>先来看“谁”的问题，唤醒的条件是资源就绪，那必然是资源的拥有者来唤醒，而只有“最内层”的协程才知道它等待的是什么资源，因此需要最内层的协程（通过注册回调函数）来触发。但是 <code>wake_up</code> 唤醒的时候得唤醒最外层的协程，即上面伪代码的参数 <code>n</code>，于是每次调用 poll 都需要把 <code>n</code> 一路下传到最内层：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (future, index) = ready_queue.<span class="title function_ invoke__">pop_front</span>();</span><br><span class="line">        future.<span class="title function_ invoke__">poll</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当然，伪代码里用 future 的序号 <code>n</code> 来唤醒外层 future 是一个实现细节。回过头来看 rust <code>Future</code> 接口，它包含了一个 <code>Context</code> 的引用，<code>cx.waker()</code> 可以获得“唤醒器”，再调用<code>wake</code> 方法即可唤醒对应的最外层的协程。与 <code>n</code> 一样，每次对
<code>poll</code> 的调用，都需要把 <code>cx</code> 一路下传到最内层。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另一个问题是“什么时候”调用，显然是“资源就绪”时。那怎么知道资源什么时候就绪？这就需要资源的提供方来通知了。通常异步编程多是在处理 IO，对于 IO 一般是操作系统通过 <code>select</code> 或者 <code>epoll</code> 等等机制提供了异步通知的能力。代码里需要在等待资源时加上回调函数。整体逻辑如下图：</p>
<img src="/2022/async-implementation-domain-concepts/rust-async-process.svg" class="" title="Rust Async Process">
<p>其中的 reactor 会监听所有在等待的资源，如果某个资源就绪了，同步的 <code>poll</code> 会返回就绪的资源，reactor 会调用它们的回调函数（即 <code>wake</code> 方法来唤醒）。Rust 里一般把 executor 和 reactor 合起来称为 Runtime。</p>
<h3 id="python-实现"><a class="header-anchor" href="#python-实现"></a>Python 实现</h3>
<p>前文的描述都是以 Rust 为样例，这是因为 Rust 里的角色分得相对更清楚一些。像 executor 和 reactor 的能力，在 Python 里都囊括在
<a href="https://github.com/python/cpython/blob/788154919c2d843a0a995994bf2aed2d074761ec/Lib/asyncio/events.py#L203">event loop</a>
里了，能监听什么资源，也被安排得明明白白了。</p>
<p>Python 里也经常用到
<a href="https://github.com/python/cpython/blob/788154919c2d843a0a995994bf2aed2d074761ec/Lib/asyncio/futures.py#L31">Future</a>
，但它的概念和 Rust 里的不太一样，Python 中的 <code>Future</code> 本身是一个协程（实现了
<a href="https://github.com/python/cpython/blob/788154919c2d843a0a995994bf2aed2d074761ec/Lib/asyncio/futures.py#L289"><strong>await</strong></a>
方法），另外有一个 <code>set_result</code> 方法能设置最终结果，结果设置后，协程就能正常返回了（类似Rust里返回 <code>Poll::Ready</code>）。</p>
<p>Python 里的一个典型协程工作流如下所示：</p>
<img src="/2022/async-implementation-domain-concepts/python-async-process.svg" class="" title="Python Async Process">
<p>图里包含了比较多的细节，整体逻辑和 Rust 类似，注意几点：</p>
<ol>
<li><code>inner</code> 注册监听事件时，Python 的做法是创建一个 future、注册事件，<code>await future</code></li>
<li>事件的注册最终都是调用 loop 的 API 来完成，也说明 Python 的 loop 包含了多个角色</li>
<li>几乎所有的操作都是异步的，包括注册，也是通过 <code>loop.call_soon</code> 延迟执行的</li>
<li><code>future.set_result</code> 之后，也是通过 <code>call_soon</code> 延迟唤醒协程</li>
<li>唤醒后的协程，是直接从断点处恢复的（通过栈帧机制），与 Rust 不同</li>
<li>Event Loop 直接操作的是 <code>task</code> 而不是 <code>coroutine</code>，它是一个包装类，提供了取消、唤醒等功能</li>
</ol>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>异步编程的优势主要是节省线程数量（从而节省线程占用的栈等资源），也有说减少线程切换来节省 CPU 消耗。但总的来说，异步的最大作用和目标是提高吞吐而非降低延时。</p>
<p>但是，异步编程的缺点也很明显，最关键的是它的“传染性”，只要有一处要异步，所有地方都需要异步。另一个是“隔离性”，它的生态和同步的方法天然不通，一般为了支持异步，几乎所有同步的标准库都需要重写一个异步版本的。我甚至认为如果“高吞吐”不是产品的核心特性（如网关），就不应该使用异步框架。</p>
<p>本文尝试挖掘 Rust 和 Python 实现异步框架的模式，让我们对异步的底层实现建立一个概念，希望借助这些概念，去理解、解决编程中遇到的异步相关问题。文章主要讲解了三方面的内容：</p>
<ol>
<li>协程的核心是控制流的中断和恢复，Python 为代表的 GC 语言用的是存储栈帧的方式，而以 Rust 为代表的非 GC 语言使用了编译成状态机的方式。</li>
<li>异步的优势想要体现，需要满足一个线程可以处理多个协程的能力。轮询的想法引导我们创建了 executor 处理协程队列的思路；中断的想法引导我们理清 reactor 的作用以及上下层需要传递的信息。</li>
<li>最后是过程中列举了 Rust 和 Python 典型的协程工作流，可以从实现上相互印证两种具体的实现思路。但在编程的使用方来看二者的 API 又没有太大的差异。</li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Python 的 coroutine 和 generator 基本是同一套实现机制，本文里有时会混用两个术语 <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>如果用 await 则要求内层调用实现了 <code>__await__</code> 方法 <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p>ref: <a href="https://peps.python.org/pep-0342/#new-generator-method-send-value">https://peps.python.org/pep-0342/#new-generator-method-send-value</a> <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4" class="footnote-item"><p>推荐看这篇文章：<a href="https://os.phil-opp.com/async-await/#the-async-await-pattern">https://os.phil-opp.com/async-await/#the-async-await-pattern</a> <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5" class="footnote-item"><p>这里说法不太准确，但不影响理解。<code>yield from</code> 只是把各个
coroutine 连接在一起，不会真的返回栈帧 <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
<li id="fn6" class="footnote-item"><p>在有 await 及编译器支持之前，基本是需要人肉做状态的保存和恢复的 <a href="#fnref6" class="footnote-backref">↩</a></p>
</li>
<li id="fn7" class="footnote-item"><p>代码改编自 <a href="https://os.phil-opp.com/async-await/#the-async-await-pattern">https://os.phil-opp.com/async-await/#the-async-await-pattern</a> <a href="#fnref7" class="footnote-backref">↩</a></p>
</li>
<li id="fn8" class="footnote-item"><p>这里的含义是 outer 方法也使用 <code>await</code> 来获取结果。 <a href="#fnref8" class="footnote-backref">↩</a></p>
</li>
<li id="fn9" class="footnote-item"><p>如果调用方自己不做成异步，则需要在代码里“同步”等待 future.poll
返回 ready，或者等待统一轮询队列的就绪通知，无论如何，它所在的线程在内部的异步任务完成前是不会释放的，就达不到异步编程“节省线程”的目的了。 <a href="#fnref9" class="footnote-backref">↩</a></p>
</li>
<li id="fn10" class="footnote-item"><p>文中只展示了简单的模型，executor 的实现可以相当复杂，参考 <a href="https://tokio.rs/blog/2019-10-scheduler">Making the Tokio scheduler 10x faster</a> <a href="#fnref10" class="footnote-backref">↩</a></p>
</li>
<li id="fn11" class="footnote-item"><p>当 future 刚被创建时我们并不知道它是否就绪，此时也需要放入队列触发第一次 poll，在 poll 里如果资源未就绪，由 future 来注册后续的回调，因此当 future 第二次通过回调再被加入队列时，就“有信心”它依赖的资源就绪了。 <a href="#fnref11" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>