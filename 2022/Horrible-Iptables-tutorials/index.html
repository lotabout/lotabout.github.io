<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="最近在搞科学上网，抄了一些 iptables 的规则不管用，干脆好好学习一番，写一写我的理解。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>iptables 实用教程 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/iptables/" rel="tag">iptables</a><a class="post-tag-noise-link" href="/tags/network/" rel="tag">network</a></div><div class="post-time">2022-06-23</div></div></div><div class="container post-header"><h1>iptables 实用教程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#iptables-%E6%98%AF%E4%B8%80%E9%97%A8%E9%85%8D%E7%BD%AE%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">Iptables 是一门配置语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table-and-chain"><span class="toc-number">2.</span> <span class="toc-text">Table and Chain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rule-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">Rule 执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">4.</span> <span class="toc-text">常用的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fwmark"><span class="toc-number">4.1.</span> <span class="toc-text">fwmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nat-snat-dnat-masquerade"><span class="toc-number">4.2.</span> <span class="toc-text">NAT: SNAT, DNAT, MASQUERADE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>最近在搞科学上网，抄了一些 iptables 的规则不管用，干脆好好学习一番，写一写我的理解。</p>
<h2 id="iptables-是一门配置语言"><a class="header-anchor" href="#iptables-是一门配置语言"></a>Iptables 是一门配置语言</h2>
<p>它是一门配置语言。用来在网络处理的各个环节里加 Hook。常见的用途是做防火墙，做流量的转发等等。</p>
<p>像学习其它语言一样，语言本身有语法，语法之外还需要学习库函数。iptables 的语法大概如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iptables [-t table] &#123;-I | -A | -D | -R&#125; chain rule_specification</span><br></pre></td></tr></table></figure></div>
<p>iptables 里有 <code>table</code> 和 <code>chain</code> 的概念，代表机器处理网络包的各个阶段，因此在指定配置时需要先指定配置在哪个阶段生效。之后是配置处理的规则，规则语法如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rule-specification = [matches...] [target]</span><br><span class="line"></span><br><span class="line">match = -m matchname [per-match-options]</span><br><span class="line"></span><br><span class="line">target = -j targetname [per-target-options]</span><br></pre></td></tr></table></figure></div>
<p>一个规则可以有多个 <code>match</code> 匹配条件，以及一个 <code>target</code> 作为目标。它表明当一个网络包命中这些规则时，执行 <code>target</code> 目标。另外，iptables 是可（由其它模块）扩展的，扩展会提供新的 match 和新的 target。我们先看一个典型示例：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -j REDIRECT --to-ports 7892</span><br></pre></td></tr></table></figure></div>
<p>这个规则的作用是将所有的 <code>tcp</code> 流量，全部转发到 <code>7892</code> 端口。这里的 <code>-p tcp</code>
条件选中 tcp 流量是 iptables 默认支持的，但 <code>REDIRECT</code> 转发操作是扩展提供的。</p>
<h2 id="table-and-chain"><a class="header-anchor" href="#table-and-chain"></a>Table and Chain</h2>
<p>要学习语言，要先了解语言背后的执行模型（类比栈、指针等），iptables 的作用是在各个环节里增加 hook，那有哪些 hook 可以用呢？先看下图<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---&gt;PRE------&gt;[ROUTE]---&gt;FWD----------&gt;POST------&gt;</span><br><span class="line">                 |                ^</span><br><span class="line">                 |                |</span><br><span class="line">                 |             [ROUTE]</span><br><span class="line">                 v                |</span><br><span class="line">                 IN              OUT</span><br><span class="line">                 |                ^</span><br><span class="line">                 v                |</span><br></pre></td></tr></table></figure></div>
<p>一个包从左侧进入系统，先到 <code>PRE</code> 环节。接着进入 <code>[ROUTE]</code> 阶段做路由，来决定包的去向。如果本机是目标地址则接收，否则尝试转发，亦或者丢弃。</p>
<p>对于本机接收的包，触发 <code>IN</code> 环节后交给对应的应用程序；转发的包在触发 <code>FWD</code>环节后尝试向外发包。外出的包最后还会经过 <code>POST</code> 环节，做最后的处理后发往网卡。</p>
<p>本机应用程序发出的包，会先经过 <code>OUT</code> 环节处理，之后经过 <code>[ROUTE]</code> 决定去向
<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，最终再经过 <code>POST</code> 环节后发出。</p>
<p>在这些 hook 的基础上，iptables 用 “table” 的概念来组织常见的包修改需求。例如：</p>
<ul>
<li>Filter: 来做包过度</li>
<li>Nat: 做地址转换</li>
<li>Mangle: 其它的通用的包修改</li>
<li>Raw: 处理一些 connection track 生效之前的修改</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># modified from https://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.txt</span><br><span class="line"></span><br><span class="line">---&gt;PRE------&gt;[ROUTE]---&gt;FWD----------&gt;POST------&gt;</span><br><span class="line">    Raw          |       Mangle   ^    Mangle</span><br><span class="line">    ConnTrack    |       Filter   |    NAT (Src)</span><br><span class="line">    Mangle       |                |</span><br><span class="line">    NAT (Dst)    |             [ROUTE]</span><br><span class="line">                 v                |</span><br><span class="line">                 IN Mangle       OUT Filter</span><br><span class="line">                 |  NAT           ^  NAT (Dst)</span><br><span class="line">                 |  Filter        |  Mangle</span><br><span class="line">                 |                |  ConnTrack</span><br><span class="line">                 v                |  Raw</span><br></pre></td></tr></table></figure></div>
<p>具体使用时，先决定要做的修改是什么内容，决定 table 名，然后找到 hook 的时机，决定 chain 的名字。当然 iptables 允许用户增加自己的 chain，但用户增加的 chain
并不能决定 hook 的时机。</p>
<p>例如下面的例子里，我们要把所有流量转发到 <code>7892</code> 端口，我们通过 <code>man iptables-extensions</code> 查到，它只能加到 <code>nat</code> 表的 <code>PREROUTING</code> 或 <code>OUTPUT</code>
链，由于我们要转发入口流量，所以修改的是 <code>PREROUTING</code> chain。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -j REDIRECT --to-ports 7892</span><br></pre></td></tr></table></figure></div>
<p><code>REDIRECT</code> 的限制也很容易理解，转发需要支持源、目标地址的改写，因此属于 <code>nat</code>
表的范畴，而它需要在路由之前做修改（否则改了也发不出去），所以只能在
<code>PREROUTING</code> 和 <code>OUTPUT</code> hook 里处理。</p>
<h2 id="rule-执行顺序"><a class="header-anchor" href="#rule-执行顺序"></a>Rule 执行顺序</h2>
<p>上面我们提到 iptables 是通过 table, chain 来组织切入点的，一个 chain 上可以配置多条规则，用户还可以自己创建 chain 来管理规则。那么 iptables 在是如何使用这些规则的呢？</p>
<p>正常情况下规则会一条条向下匹配，iptables 有一些特殊的 target 也提供了一些特殊的操作来在规则中跳转的能力（可以类比编程语言中的 <code>continue</code>, <code>break</code>），如下图：</p>
<img src="/2022/Horrible-Iptables-tutorials/iptables-order.svg" class="" title="execution order">
<ul>
<li>JUMP(<code>-j &lt;chain&gt;</code>)：跳转到自定义的 chain 里</li>
<li>ACCEPT：流量通过当前 table + chain，不再匹配任何规则</li>
<li>RETURN：从当前 chain 跳出，回到上一个 chain 跳转的位置</li>
<li>DROP：丢弃流量，不再匹配任何 table 任何 chain</li>
</ul>
<p>此外也得注意一些扩展 target 的语义，如 <code>REDIRECT</code> 相当于 <code>ACCEPT</code>；如 <code>REJECT</code>
相当于 <code>DROP</code>，会在发送终止包后丢弃数据包。实操如果发现有问题，要注意是不是规则顺序引起的。</p>
<h2 id="常用的扩展"><a class="header-anchor" href="#常用的扩展"></a>常用的扩展</h2>
<p>上面我们了解了 iptables 的语法和执行顺序，接下来要学习“库函数”，表面上学习库函数就是学习“扩展”提供了哪些 match 和 target，但真正的难点是学习它们背后的网络处理机制。这里我们简单提几个。</p>
<h3 id="fwmark"><a class="header-anchor" href="#fwmark"></a>fwmark</h3>
<p>Firewall Mark(fwmark) 可以理解成一个 iptables 的扩展，它提供了 <code>MARK</code> 和
<code>CONNMARK</code> 的 target，允许我们把一个数据包或一个连接打上标记。之后在其它地方可以使用这个标记。</p>
<p>典型的使用方式是让有某个标记的流量走某个特殊的路由表<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，例如：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip rule add fwmark 1 table 100</span><br><span class="line">ip route add <span class="built_in">local</span> default dev lo table 100</span><br><span class="line"></span><br><span class="line">iptables -t mangle -A OUTPUT -p udp -d 198.18.0.0/16 -j MARK --set-mark 1</span><br></pre></td></tr></table></figure></div>
<p>其中的 <code>ip rule add fwmark 1 table 100</code> 是创建了一张名为 <code>100</code> 的路由表，并指定当 <code>fwmark</code> 为 1 时才查这张表。而下面的规则指定了 <code>-p udp</code> 匹配 UDP 流量，且目标地址为 <code>-d 198.18.0.0/16</code> 时执行 <code>-j MARK</code> 操作，把数据包打上 <code>--set-mark 1</code> 这个标记。</p>
<p>成果是目标地址为 <code>198.18.0.0/16</code> 的 UDP 流量会查 100 路由表。</p>
<h3 id="nat-snat-dnat-masquerade"><a class="header-anchor" href="#nat-snat-dnat-masquerade"></a>NAT: SNAT, DNAT, MASQUERADE</h3>
<p>Network Address Translation 的变种比较多，但思路还是容易理解的。在网络隔离的情况下，如果想两个网段里交换网络包，则需要在路由器（能同时访问两个网段）里对包做地址转换，如下所示：</p>
<img src="/2022/Horrible-Iptables-tutorials/iptables-NAT.svg" class="" title="NAT">
<p>SNAT 是换了源 IP 字段，所以一般用于出口流量；DNAT 换了目标 IP 字段，所以一般用于做“端口映射”来穿透内网。可以看到不论是 SNAT 还是 DNAT 都需要提供目标的 IP 地址。而 <code>MASQUERADE</code> 可以理解成 SNAT 的变种，它可以自动填写对应网卡的 IP，不需要手工指定了，一般用于路由器流量内外网转发。</p>
<p>另外从图里看到，无论是 SNAT 还是 DNAT，都需要维护一张 NAT 映射表，可以通过
<code>conntrack -L</code> 看到。如果在路由器的 SNAT 里，<code>--to-source</code> IP 不是本机会怎么样呢？连接会建立失败，路由还是正常记录了 NAT 映射表，但 ACK 包会直接发到
<code>--to-source</code> IP 上，被丢弃。</p>
<p>额外的，TCP 流量只有在连接建立时会查 iptables NAT 表，同个连接后续的包会沿用建立连接时的规则。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">A Deep Dive into Iptables and Netfilter Architecture</a> 介绍了 hook 和 table 的作用</li>
<li><a href="https://lucid.app/lucidchart/eb1b46d7-653f-4c5a-b421-ba8c075fb278/view?page=0_0#">Iptables Flow</a> 一个简化但容易理解的 iptables 流程图</li>
<li><a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg">Packet flow in Netfilter and General Networking</a> 一张复杂但全面的流程图</li>
<li><code>man iptables-extensions</code> 各种扩展支持的 match, target 都有说明</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.txt">https://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.txt</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>按文档所说，实际上路由的代码在 <code>OUT</code> 之前就被调用，用来获取源 IP 和一些其它的 IP 选项 <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://lancellc.gitbook.io/clash/start-clash/clash-udp-tproxy-support">https://lancellc.gitbook.io/clash/start-clash/clash-udp-tproxy-support</a> <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>