title: Raft 一致性算法
tags:
---

## 复制状态机/Replicated state machines

复制状态机将服务器看成一个状态机，而一致性算法的目的是让多台服务器/状态机能够
计算得到相同的状态，同时，如果有部分机器宕机，集群作为一个整体依然能继续工作。
复制状态机一般通过复制日志（replicated log）来实现，如下图：

{% asset_img raft-replicated-state-machine.svg Replicated State Machine %}

服务器会将客户端发来的命令存成日志，日志是有序的。而服务器状态机执行命令的结果
是确定的，这样如果每台服务器的状态机执行的命令是相同的，状态机最终的状态也会是
相同的，输出的结果也会是相同的。而如何保证不同服务器间的日志是一样的呢？这就是
其中的“一致性模块”的工作了。

一致性模块（consensus module）在收到客户端的命令时（②），一方面要将命令添加到
自己的日志队列中，同时需要与其它服务器的一致性模块沟通，确保所有的服务器将最终
拥有相同的日志，即使有些服务器可能挂了。实践中至少需要“大多数(大于一半)”服务器
同步了命令才认为同步成功了。

## Raft 算法

接下去会从 3 个方面讲解 Raft 算法：

1. 选主（Leader Election）。Raft 在同一时刻只有一个主节点能接收写命令。
2. 日志复制（Log Replication）。Raft 如何将接收到的命令复制到其它服务器上，使
   其保持一致？
3. 安全性，为什么 Raft 在各种情况下依旧能保证各服务器的日志一致性？

### 基础概念

首先是节点的 3 种状态/角色：
- Follower/从节点不发起请求，单纯响应 Candidate 和 Leader 的请求
- Leader/主节点负责响应客户端发起的请求，如果客户端的请求发送到 Follower，
    请求会被转发到主节点
- Candidate/候选节点是一种中间状态，只在选主期间存在。

它们的转换关系如下：

{% asset_img raft-server-states.svg Server States %}

其次是任期（term）的概念。Raft 将时间切分成多个 term，每个 term 以选主开始，选
主期间各节点尝试当上主节点，选举结束后开始正常处理客户端的请求。如图：

{% asset_img raft-term-definition.svg Term Definition %}

Raft 会保证每一个 term 中至多只有一个 leader，如果选主时选票被分散导致没有节点
获得多数票（如 t3），则会开始新一轮选举。

term 就像逻辑上的“时间”，用来记录和比较各节点的“进度”。如果某个节点收到信息时
发现自己的 term 是落后的，它会立即将自己的 term 更新为更大的 term；同时节点不
会理睬 term 比自己小的消息；另外如果主节点收到 term 比自己大的消息，则会立马进
入 follower 的状态。

例如由于网络情况不佳，一个主节点 A 与其它节点失联，其它节点选了一个新的主节点
B，当网络恢复正常时，旧主节点 A 收到主节点 B 的消息时，它会判断新主节点 B 的
term 大于自己，说明自己错过了一些事件，因此选择放弃自己的主节点身份。


### 选主/Leader Election

节点启动时，默认处于 Follower 的状态，所以开始时所有节点均是 Follower，那么什
么时候触发选主呢？Raft 用“心跳”的方式来保持主从节点的联系，因此会有两个时间需
要配置：

- 心跳间隔，主节点隔多长时间发送心跳信息
- 等待时间(election timeout)，如果超过这个时间仍然没有收到心跳，则认为主节点宕
    机。一般每个节点各自在 150～300ms 间随机取值。。

当一个节点在等待时间内没有收到主节点的心跳信息，它首先将自己保存的 term 增加
`1` 并进入 Candidate 状态。此时它会先投票给自己，然后并行发送 `RequestVote`消
息给其它所有节点，请求这些节点投票给自己。然后等待直到以下 3 种情形之一发生：

1. 收到大于一半的票，当选为主节点
2. 有其它节点当选了主节点，此时会收到新的主节点的心跳
3. 过了一段时间后依旧没有当选，此时该节点会尝试开始新一轮选举

对于第一种情形，Candidate 节点需要收到集群中与自己 term 相同的所有节点中大于一
半的票数（当然如果节点 term 比自己大，是不会理睬自己的选举消息的）。节点投票时
会采取先到先得的原则，对于某个 term，最多投出一票（后面还会再对投票加一些限制
）。这样能保证某个 term 中，最多只会产生一个 leader。当一个 Candidate 变成主节
点后，它会向其它所有节点发送心跳信息，这样其它的 Candidate 也会变成 Follower。

第二种情形是在等待投票的过程中，Candidate 收到其它主节点的心跳信息（只有主节点
才会向其它节点发心跳），且信息中包含的 term 大于等于自己的 term，则当前节点放
弃竞选，进入 Follower 状态。当然，如前所说，如果心跳中的 term 小于自己，则不予
理会。

第三种情形一般发生在多个 Follower 同时触发选举，而各节点的投票被分散了，导致没
有 Candidate 能得到多数票。超过投票的等待时间后，节点触发新一轮选举。理论上，
选举有可能永远平票，Raft 中由于各个节点的超时时间是随机的，实际上平票不太会永
远持续下去。

### 日志复制/Log Replication

Log Replication 分为两个主要步骤：复制/Replication 和 提交/Commit。当一个节点
被选为主节点后，它开始对外提供服务，收到客户端的命令后，主节点会首先将命令添加
到自己的日志队列中，然后并行地将消息发送给其它所有的节点，在确保消息被安全地复
制（下文解释）后，主节点会将该消息提交到状态机中，并返回状态机执行的结果。如果
follower 挂了或因为网络原因消息丢失了，主节点会不断重试直到所有从节点最终成功
复制该消息。

日志结构示例如下：

{% asset_img raft-log-entries.svg Log Entries %}

日志由许多条目（log entry）组成，条目顺序编号。条目包含它生成时节点所在的 term
（小方格中上方的数字），以及日志的内容。当一个条目被认为安全地被复制，且提交到
状态机时，我们认为它处于“已提交（committed）”状态。


### 安全性

## 节点变更
