<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="由于 CPU 缓存的存在及编译器/CPU 的指令重排，多线程程序的运行结果实际上很难预期，volatile 关键词是 JVM 提供的保证变量“可见性”的武器。JVM 会做许多底层的工作来保证这种可见性。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>理解 Java volatile 关键字 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/java/" rel="tag">java</a><a class="post-tag-noise-link" href="/tags/thread-safe/" rel="tag">thread-safe</a><a class="post-tag-noise-link" href="/tags/volatile/" rel="tag">volatile</a></div><div class="post-time">2019-08-31</div></div></div><div class="container post-header"><h1>理解 Java volatile 关键字</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%A9%E8%AF%BB%E5%86%99%E4%B8%8D%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.</span> <span class="toc-text">缓存让读写不确定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">强制读写内存保证可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">3.</span> <span class="toc-text">指令重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">4.</span> <span class="toc-text">限制指令重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E8%AF%81-%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">为什么要保证“完全可见性”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>由于 CPU 缓存的存在及编译器/CPU 的指令重排，多线程程序的运行结果实际上很难预期，volatile 关键词是 JVM 提供的保证变量“可见性”的武器。JVM 会做许多底层的工作来保证这种可见性。</p>
<h2 id="缓存让读写不确定"><a class="header-anchor" href="#缓存让读写不确定"></a>缓存让读写不确定</h2>
<p>现代 CPU 有多级缓存，写指令的结果可能“很久”之后才会真正写入内存；同样的，读指令也可能读取的不是最新的值，而是“很久”之前缓存的值。例如对于下面代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shared</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(count); <span class="comment">// ①</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>一个线程先调用 <code>write</code>，在另一个线程调用 <code>read</code> 时，① 处的输出可能是 <code>1</code>也可能是 <code>0</code>。由于缓存的存在，在线程 2 读取 <code>count</code> 时，线程 1 的数据可能还没有真正写入内存，导致读取的是“旧值” 0：</p>
<img src="/2019/Java-volatile-keyword/cpu-cache.svg" class="" title="CPU Cache">
<p>多线程的程序中，一个线程写入的数据不能及时反映到另一个线程中，这就是可见性问题。此时会说一个线程对变量的修改对另一个线程不可见。</p>
<h2 id="强制读写内存保证可见性"><a class="header-anchor" href="#强制读写内存保证可见性"></a>强制读写内存保证可见性</h2>
<p>一个变量如果加了 volatile 关键词，JVM 变会保证它的“可见性”。简单地说，JVM 会：</p>
<ol>
<li>在写入一个 volatile 变量时，强制它写入到内存中</li>
<li>在读取一个 volatile 变量时，强制它从内存中读取</li>
</ol>
<p>因此上面的例子中，如果我们改成下面代码，就可以保证如果一个线程先写入 <code>counter = 1</code>，另一个线程之后读取时，读到的 <code>counter</code> 值一定是 <code>1</code>。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shared</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>事实上，当变量加了 volatile 后，JVM 做的不仅仅是上面说的，它还会保证<strong>完全可见性</strong>：</p>
<ol>
<li>如果线程 A <strong>写入</strong>一个 <code>volatile</code> 变量，之后线程 B 读取该变量，则线程 A 写入该变量之前线程就可见（定义的、修改的）的所有变量都将对线程 B 可见。JVM 会强制将缓存中的这些变量写入内存中。</li>
<li>如果线程 A <strong>读取</strong>一个 <code>volatile</code> 变量，则读取该变量之前线程 A 可见的所有变量都会从内存中重新读取。</li>
</ol>
<p>举个例子，下面的代码中，只有 <code>count</code> 变量加了 <code>volatile</code>，但在写入 <code>count</code> 时，线程可见的其它变量(<code>price</code>)会随着 <code>count</code> 一起，被强制写入到内存中。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而下面的代码中，在读取 <code>count</code> 时，线程可见的所有变量都将从内存中重新读取，因此②中 <code>price</code> 的值是从刚从内存读取的“最新”的值。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">howMuch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lCount</span> <span class="operator">=</span> count ; <span class="comment">// ① 此处会重新从内存中读取 price</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">lPrice</span> <span class="operator">=</span> price; <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">return</span> lCount * lPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>听着好像很复杂，其实总结下来，就是 JVM 会需要强制从内存中读写数据：</p>
<ol>
<li>在写入 volatile 变量时，之前写的（在缓存里的）变量都会被强制写入内存中</li>
<li>在读取 volatile 变量时，之前读的（在缓存里的）变量都会重新从内在中读取</li>
</ol>
<h2 id="指令重排"><a class="header-anchor" href="#指令重排"></a>指令重排</h2>
<p>另一个难题是指令重排。为了提高执行效率，编译器在编译过程中会对指令进行重排，例如下面代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a++;</span><br><span class="line">b++</span><br></pre></td></tr></table></figure></div>
<p>为了节省访问内存的开销，编译器可能会对某个变量的操作集中处理，变成：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure></div>
<p>另一种可能的重排是 CPU 层面的，目的都是提升程序的执行速度。CPU 会保证在“没有竞争”的情况下，重排后的执行结果和顺序执行的结果是一样的。但在多线程有竞争情况下事情就复杂了起来。</p>
<h2 id="限制指令重排"><a class="header-anchor" href="#限制指令重排"></a>限制指令重排</h2>
<p>如果 JVM 只是强制将变量写回内存，由于指令重排的存在，实际上是达不到可见性保证的。假设：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// this.price = price; // 由于指令重排，该语句的执行移到 count 之后</span></span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="built_in">this</span>.price = price; <span class="comment">// 由于指令重排，语句的实际执行位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>那么在写入 <code>count</code> 变量时，一同写入内存的 <code>price</code> 实际上是“旧值”。因此另一个线程读取 <code>price</code> 时读取的也是“旧值”，<code>count</code> 值是最新的，但 <code>price</code> 可能不是，这和我们的预期（完全可见性）不符。</p>
<p>因此除了上节中提到的强制在内存中读写数据，JVM 还需要限制指令重排，在编译/执行过程中：</p>
<ol>
<li>在 volatile 变量的<strong>写入</strong>指令<strong>之前</strong>，对其它变量的读写指令不能重排到该指令<strong>之后</strong>。</li>
<li>在 volatile 变量的<strong>读取</strong>指令<strong>之后</strong>，对其它变量的读写指令不能重排到该指令<strong>之前</strong>。</li>
</ol>
<p>如下面的代码，JVM 会为 volatile 变量的读/写创建一个屏障，阻止指令的重排。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> barrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">barrierTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">localA</span> <span class="operator">=</span> a;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">this</span>.barrier = <span class="number">100</span>;              <span class="comment">// ▼ 上方的指令不能重排到下方，下方的指令允许重排到上方</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">localBarrier</span> <span class="operator">=</span> <span class="built_in">this</span>.barrier; <span class="comment">// ▲ 下方的指令不能重排到上方，上方的指令允许重排到下方</span></span><br><span class="line">        <span class="built_in">this</span>.b = <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">localB</span> <span class="operator">=</span> <span class="built_in">this</span>.b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> localA + localBarrier + localB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>有了这个限制，和上节说的强制内存读写一起，JVM 就可以为 volatile 变量提供“完全可见性”的保证。</p>
<h2 id="为什么要保证-完全可见性"><a class="header-anchor" href="#为什么要保证-完全可见性"></a>为什么要保证“完全可见性”</h2>
<p>为什么 JVM 要保证“完全可见性”？由于缓存和指令重排等机制，我们对程序执行顺序和执行结果的预期，可能跟真实的执行顺序和结果并不相同。此时究竟是预期有问题？还是执行结果出错？</p>
<p>因此我们需要和 JVM 之间有一个约定。JVM 约定了一个叫
happens-before<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 的规则，如果两个操作 <code>x</code>, <code>y</code>，<code>x</code> 发生在 <code>y</code>
之前，记作 <code>hb(x, y)</code>，同时还规定了一系列推导的规则。VM 的实现需要保证，程序能推导出的 happens-before 关系在执行结果上要能得到体现。</p>
<p>例如考虑以下 4 个操作<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<ol>
<li>线程 A 写入变量 X = 1</li>
<li>线程 A 写入 volatile 变量 Y = 2</li>
<li>线程 B 读取 volatile 变量 Y</li>
<li>线程 B 读取变量 X</li>
</ol>
<p>我们会预期步骤 #4 中变量的值 <code>X</code> 为 <code>1</code>。如果没有任何约定，JVM 给我们的结果可能是 <code>0</code>，那么是谁的错呢？而在 happens-before 规则的约定之下，如果实际执行时步骤 #3 发生在步骤 #2 之后，则我们预期步骤 #4 中 <code>X</code> 为 <code>1</code> 就是一个正确的预期，如果 JVM 给出的结果不为 1，就是 JVM 的错误。</p>
<p>我们来看看 happens-before 其中的两条推导规则：</p>
<ul>
<li>规则1：如果操作 x, y 在同一线程中执行，且在程序中 x 出现在 y 之前，则认为 hb(x, y)</li>
<li>规则2：写入一个 volatile 变量的操作，发生在(happens before) 后续对该变量的读取之前。</li>
</ul>
<p>根据规则1，我们有步骤 <code>#1 &gt; #2</code>、<code>#3 &gt; #4</code>，而如果实际执行时 #3 的确发生在 #2
之后，则根据规则2，我们有 <code>#2 &gt; #3</code>，因此我们能确定在步骤 #4 时，JVM 需要保证我们能看到步骤 #1 的修改。</p>
<p>可以看到 JVM 对 volatile “完全可见性”的保证，根源上是对 happens-before 规则的遵守要付出的代价。</p>
<p>那么为什么要约定 happens-before 呢？（不要十万个为什么啊……）猜测是在预期上尽量接近程序员的理解（即顺序一致性），在实现上为优化保留足够的空间。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>volatile 的作用，简单理解是强制在内存读写数据，但由于 happens-before 规则的限制，JVM 的实现需要做一些额外的工作，主要是对所有可见变量的强制读写（到内存）及限制指令重排。</p>
<p>另外提一下，<code>volatile</code> 不能保证原子性，而 <code>synchronized</code> 可以。不过
<code>synchronized</code> 保证是的 synchronized 块之间的原子性、可见性、有序性，但是并不保证和那些<strong>非 synchronized 块</strong>的关系<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，这也是不加 volatile 的
double-checked locking 失效<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的原因之一。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="http://tutorials.jenkov.com/java-concurrency/volatile.html">Java Volatile Keyword</a> Google 搜索 volatile 的第一篇，有很详细的解释</li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html">Chapter 17. Threads and Locks</a> Java 语言规范，有 happens-before 的详细规则</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>例子取自 <a href="https://stackoverflow.com/a/17108892">https://stackoverflow.com/a/17108892</a> <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html">Synchronization and the Java Memory
Model</a>  by Doug Lea <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4" class="footnote-item"><p>参考博主之前的文章 <a href="https://lotabout.me/2019/QQA-What-is-double-checked-locking-idiom/">QQA: 什么是 double checked
locking</a> <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>