<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="大家都听过 &lt;code&gt;程序 = 数据结构+算法&lt;/code&gt;，从另一种意义上说 &lt;code&gt;程序 = 数据+操作&lt;/code&gt;。
Expression Problem 指的是如何在不修改已有的源代码，添加新的数据或操作。它提供了一种新的视角，来看待编程语言和程序设计。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Expression Problem 随想 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Expression-Problem/" rel="tag">Expression Problem</a><a class="post-tag-noise-link" href="/tags/FP/" rel="tag">FP</a><a class="post-tag-noise-link" href="/tags/OOP/" rel="tag">OOP</a></div><div class="post-time">2018-12-12</div></div></div><div class="container post-header"><h1>Expression Problem 随想</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-expression-problem"><span class="toc-number">1.</span> <span class="toc-text">什么是 Expression Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%98%E5%85%88"><span class="toc-number">1.1.</span> <span class="toc-text">数据优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E4%BC%98%E5%85%88"><span class="toc-number">1.2.</span> <span class="toc-text">操作优先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90"><span class="toc-number">2.</span> <span class="toc-text">问题根源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">一些思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#expression-problem-%E7%9C%9F%E7%9A%84%E6%98%AF%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">Expression Problem 真的是需要解决的问题吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%95%B0%E6%8D%AE-vs-%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">扩展数据 vs 扩展方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="toc-number">4.3.</span> <span class="toc-text">模块的边界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>大家都听过 <code>程序 = 数据结构+算法</code>，从另一种意义上说 <code>程序 = 数据+操作</code>。
Expression Problem 指的是如何在不修改已有的源代码，添加新的数据或操作。它提供了一种新的视角，来看待编程语言和程序设计。</p>
<h2 id="什么是-expression-problem"><a class="header-anchor" href="#什么是-expression-problem"></a>什么是 Expression Problem</h2>
<p>假设我们有两种“形状”：正方形和圆形，并且想计算它们的面积。Expression Problem的问题是：在不修改现有代码的情况下，能不能方便地新增一个数据“三角形”，同时新增一个操作“求周长”？我们将看到，用“数据优先”的思路，则新增操作比较困难；相反如果以“操作优先”的思路，则新增数据会比较困难。</p>
<h3 id="数据优先"><a class="header-anchor" href="#数据优先"></a>数据优先</h3>
<p>面向对象就是典型的数据优先的思路，如果用面向对象的方式来实现如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> side;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果想新增一个数据：“三角形(Triangle)”，那么只需要新建一个类，实现 <code>Shape</code> 接口即可，不需要修改现有的任何代码。所以我们说面向对象的方式<strong>易于</strong>新增数据。</p>
<p>那么如果想新增一个操作 <code>perimeter</code> 来求周长呢？上面的实现方式就需要我们为
<code>Shape</code> 接口新增 <code>perimeter</code> 方法，同时修改 <code>Square</code> 和 <code>Circle</code> 类来增加新的实现。这要求我们修改现有的代码，因此说面向对象的方式<strong>不易于</strong>新增操作。</p>
<p>当然，我们会说改就改呗，没什么大不了嘛。问题在于，你可能没有权限修改现有的代码
(如用的是别人的库)，而又希望能扩展它们的功能。</p>
<h3 id="操作优先"><a class="header-anchor" href="#操作优先"></a>操作优先</h3>
<p>操作优先的典型是函数式编程，这里我们依旧使用 Java 来实现，但方式是函数式编程：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AreaService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Square) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">side</span> <span class="operator">=</span> ((Square) shape).side;</span><br><span class="line">            <span class="keyword">return</span> side * side;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Circle) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> ((Circle) shape).radius;</span><br><span class="line">            <span class="keyword">return</span> radius * radius;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;shape not recognized&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到 <code>area</code> 函数中对 <code>shape</code> 的类型进行了判断(或称模式匹配)。如果想新增数据“三角形(Triangle)”，则需要修改 <code>area</code> 方法，新增一个 <code>if</code> 判断才行。因此说函数式编程<strong>不易于</strong>新增数据。</p>
<p>相反，如果想新增求周长的操作 <code>perimeter</code>，可以新增一个 <code>PerimeterService</code> 而不需要修改现有的任何代码。所以说函数式编程<strong>易于</strong>新增操作。</p>
<h2 id="问题根源"><a class="header-anchor" href="#问题根源"></a>问题根源</h2>
<p>要解决问题，要先弄清问题的根源，这里引用 <a href="https://stackoverflow.com/a/22180495/826907">StackOverflow 的这个回答
</a> 来尝试说明：</p>
<p>“数据”和“操作”是程序的两个维度，它们之间存在映射关系（数据可以应用在多个操作上，操作可以接受多个数据）。但源代码的表示是一维的，从上到下，从左到右。于是这种映射关系要么以数据为主来组织（面向对象编程中，类的方法需要写在类中），要么以操作为主来组织（函数式编程中，对不同数据的处理需要写在同一个代码块中）。</p>
<img src="/2018/Thoughts-on-Expression-Problem/data-operation.svg" class="" title="Data vs Operation">
<p>如上图，以数据为主看到两类数据：<code>Square</code> 和 <code>Circle</code>，它们有各自的方法；以操作为主看到两个方法：<code>area</code> 和 <code>perimeter</code>，它们分别能接受各自的数据作为参数。</p>
<p>如果以数据为主，写成代码类似下面的结构：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Data-Centric</span><br><span class="line">((square area)</span><br><span class="line"> (circle area))</span><br></pre></td></tr></table></figure></div>
<p>于是增加新的数据只需要增加对应的行，如增加三角形：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((square area)</span><br><span class="line"> (circle area)</span><br><span class="line"> (triangle area)) # 新增</span><br></pre></td></tr></table></figure></div>
<p>而如果要新增一个方法，则需要为每一行增加新的列，即需要修改现有的代码：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((square area perimeter)</span><br><span class="line"> (circle area perimeter))</span><br><span class="line">              # 新增列</span><br></pre></td></tr></table></figure></div>
<p>以操作为优先也类似。因此归根结底，Expression Problem 的矛盾在于二维的程序（数据与操作的关联）无法在一维的源代码上有效地组织。</p>
<h2 id="解决方案？"><a class="header-anchor" href="#解决方案？"></a>解决方案？</h2>
<p><a href="https://en.wikipedia.org/wiki/Expression_problem">维基百科</a> 上给了很多相应的解决方案。我觉得具体的方案对“开眼界”不是特别重要，这里简要说说：</p>
<ol>
<li>OOP 理论上是以数据为中心，但用 Visitor Pattern 可以让我们切换成以操作为中心。它解决不了 Expression Problem，但让我们有了选择的机会</li>
<li>Python 和 Ruby 等语言可以对已有的类添加新的方法，算是 “Open Class” 的方案，也称 “Monkey Patching”</li>
<li>Common Lisp、Clojure 等语言采用了 Multi-Method 的方案，让数据与操作的关联不需要一次性指定，因此不限制必须从某个维度去组织</li>
<li>还有一些基于 Visitor Pattern 和泛型的方案，太复杂没看懂</li>
</ol>
<h2 id="一些思考"><a class="header-anchor" href="#一些思考"></a>一些思考</h2>
<p>下面是博主自己的一些思考，欢迎讨论。</p>
<h3 id="expression-problem-真的是需要解决的问题吗？"><a class="header-anchor" href="#expression-problem-真的是需要解决的问题吗？"></a>Expression Problem 真的是需要解决的问题吗？</h3>
<p>换句话说，强制以某个维度组织程序真的不好吗？。自由与强大通常会带来无序与混乱。不同人会有不同的选择。例如 Monkey Patching 允许我们使用一个库，并在基础上加自己的功能而不需要修改原来的库，功能强大；但现在你在引用两个库的时候就需要担心，会不会其中一个库 patch 了另一个库的方法，而与你的预期不符呢？</p>
<p>从代码的管理上，如果用 OOP 的思路，一个类的方法都在这个类中，是很容易找到它的边界的；反观 Monkey Patching 甚至没法知道一个对象都有哪些方法。牺牲扩展性带来的确定性值得吗？</p>
<h3 id="扩展数据-vs-扩展方法"><a class="header-anchor" href="#扩展数据-vs-扩展方法"></a>扩展数据 vs 扩展方法</h3>
<p>现在看到许多许多 Java 代码，在写类的时候加上 getter/setter，然后把处理类的方法写在一个 Service 类中。这种写法其实并不 OOP，它其实是函数式编程，设计模式上也称为“贫血模型”，因为类中没有业务逻辑。</p>
<p>Expression Problem 也许能从某种角度上解释为什么越来越多这样的代码。虽然 OOP 的特点是“继承”、“封装”、“多态”，但起码从“继承”的角度来说，除了 GUI 编程，现实中的业务逻辑没有多少能用到的，甚至现在越来越多“用组合不用继承”的声音。这种趋势隐含的意义是：现实中没有太多的“扩展数据”的需求。</p>
<p>也因此 OOP 从扩展性而言似乎并没有多少实用性，而业务上经常需要添加修改方法，也许正是如此更习惯从“操作”的角度组织程序吧。</p>
<h3 id="模块的边界"><a class="header-anchor" href="#模块的边界"></a>模块的边界</h3>
<p>我们经常说写程序要“高内聚、低耦合”，那么内外的边界在哪呢？那么在 Expression
Problem 上，允许在不修改现有模块的基础上进行扩展，算不算是破坏了这个原则呢？换个角度说，模块的扩展是否应该由模块的维护者在模块的内部完成呢？</p>
<p>我们说 OOP 能提供“封装”，因为隐藏了具体的实现，我的理解是它维护了一个类内部的“约定”，而 FP 由于暴露了数据结构，则较难控制模块外部构建出非法的结构。</p>
<p>从这种角度来说，OOP 是用类来维护了数据的边界。也算是从一个极细粒度上的“高内聚”吧。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>Expression Problem 是指如何在不修改现有代码的前提下新增数据和操作。我们指出它的矛盾在于程序是二维的，而源代码是一维的，在表达程序时分主次维度就会造成次维度难以修改。</p>
<p>此外我们简单提了几个解决方案，然后表达了对 Monkey Patching 的纠结态度，以及对在 Java 里不写 OOP 的吐嘈。最后推荐大家看看《领域驱动设计》。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/">https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/</a>
一篇关于 Expression 的博文，讨论了如何扩展 visitor pattern 来解决，以及在
Clojure、Python/Ruby 语言中的解决方案</li>
<li><a href="http://ropas.snu.ac.kr/~bruno/papers/ecoop2012.pdf">http://ropas.snu.ac.kr/~bruno/papers/ecoop2012.pdf</a> 用 Algebra Types 来解决
Expression Problem</li>
<li><a href="http://www.kframework.org/images/3/3f/ExpProblem.pdf">http://www.kframework.org/images/3/3f/ExpProblem.pdf</a> 用泛型解决 Expression
Problem</li>
<li><a href="https://stackoverflow.com/a/22180495/826907">https://stackoverflow.com/a/22180495/826907</a> 文中提到的 StackOverflow 回答，角度新奇</li>
<li><a href="http://www.winestockwebdesign.com/Essays/Lisp_Curse.html">http://www.winestockwebdesign.com/Essays/Lisp_Curse.html</a> 对 Lisp 强大能力带来负面影响的吐嘈</li>
<li><a href="https://en.wikipedia.org/wiki/Expression_problem">https://en.wikipedia.org/wiki/Expression_problem</a> 维基百科，有许多解决方案的论文链接</li>
</ul>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>