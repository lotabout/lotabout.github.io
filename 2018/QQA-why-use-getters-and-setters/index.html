<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="java 有一个不成文的规定，如果要访问一个类的 private 字段，就需要写
getter/setter 方法。但我们在其它语言却很少见到类似的约定，为什么？"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>QQA: 为什么 java 中要写 getter/setter？ | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/QQA/" rel="tag">QQA</a><a class="post-tag-noise-link" href="/tags/java/" rel="tag">java</a></div><div class="post-time">2018-04-02</div></div></div><div class="container post-header"><h1>QQA: 为什么 java 中要写 getter/setter？</h1></div><div class="container post-content"><p>java 有一个不成文的规定，如果要访问一个类的 private 字段，就需要写
getter/setter 方法。但我们在其它语言却很少见到类似的约定，为什么？</p>
<ul>
<li>它是“封装”的体现，对外隐藏了具体实现，允许之后对属性的访问注入新的逻辑（如验证逻辑）。</li>
<li>一些语言，如 python，提供了机制允许我们更改访问属性的逻辑，因此不需要手工写
getter/setter。</li>
</ul>
<h2 id="getter-setter-是对-属性访问-的封装"><a class="header-anchor" href="#getter-setter-是对-属性访问-的封装"></a>getter/setter 是对“属性访问”的封装</h2>
<p>假设我们写了下面这段代码，直接访问类的 public 字段：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// caller</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> person.name;</span><br><span class="line">person.name = <span class="string">&quot;Java&quot;</span>;</span><br></pre></td></tr></table></figure></div>
<p>之后我们认为 <code>name</code> 属性只能是字母，不能包含其它的字符，上面这种实现中，我们就需要更改所有 caller 调用 <code>person.name = ...</code> 的代码。换句话说，类 <code>Person</code> 暴露了实现的细节（即字段 person）。</p>
<p>那么如果一开始就使用了 getter/setter，则我们不需要改变任何 caller，只需要在
<code>setName</code> 函数里增加相应的逻辑即可。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        validate_name(name);  <span class="comment">// the newly added validation logic</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// caller</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> person.getName();</span><br><span class="line">person.setName(<span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>所以，通过这层封装，之后如果有需要，我们甚至可以更改字段的名字，类型等等。这就是封装的好处，而 getter/setter 这种写法能让我们为将来可能的修改做好准备。</p>
<h2 id="其它语言里的-getter-setter"><a class="header-anchor" href="#其它语言里的-getter-setter"></a>其它语言里的 getter/setter</h2>
<p>getter/setter 的作用是为“属性的访问”（即 <code>x.field</code> 与 <code>x.field = ...</code>）提供日后修改的可能。一些“比较新”的语言就默认提供了这种能力。</p>
<p>Python 中提供了 <a href="https://docs.python.org/3/howto/descriptor.html">Descriptor</a>
的机制。在 Python 中，可以认为当访问对象的属性时，等价于调用对象的 <code>__get__()</code>
和 <code>__set__()</code> 方法，因此我们可以覆盖这两个方法来修改访问的逻辑。</p>
<p>同样的，Kotlin 在定义
<a href="https://kotlinlang.org/docs/reference/properties.html">properties</a> 也可以自定义的 getter/setter 方法来修改属性访问的逻辑。</p>
<p>这里想说明的是，getter/setter 其实应该是默认实现，然后有需要时再覆盖，而不是每次都手工实现。</p>
<h2 id="社区与约定"><a class="header-anchor" href="#社区与约定"></a>社区与约定</h2>
<p>也许你会问，封装其实叫什么名字都行，为什么非要叫 <code>getXXX</code> 及 <code>setXXX</code> 呢？这其实是
<a href="http://download.oracle.com/otn-pub/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/beans.101.pdf?AuthParam=1522674989_0d7c790344741da888ed8c0e890ea7d5">JavaBeans</a>
里约定的（7.1 节）。甚至从某种角度来说 getter/setter 的目的也不是为了封装，而只是一个约定，使框架能识别 JavaBeans 中的 property。</p>
<p>在实际工作中你会发现，90% 以上的 getter/setter 在未来并不会被用来增加逻辑什么的。所以“封装”的作用理论上是好的，但实际被使用到的频率特别低，反而增加了许多无用的代码。</p>
<p>另一方面，随着使用 getter/setter 使用的增加，且由于绝大多数 getter/setter 并不会增加额外的逻辑，使得人们开始习惯于假设 getter/setter 不会有额外逻辑。所以如果你想在 setter 里加一些额外的逻辑时，反而要注意会不会让使用的人感到吃惊。</p>
<h2 id="写在最后"><a class="header-anchor" href="#写在最后"></a>写在最后</h2>
<p>Getter/Setter 这个话题看上去似乎很简单，它的背后却有很多可以深究和思考的内容的。有人说 Getter 没关系，可怕的是 Setter；也有说现在lombok 这么方便，用
Getter/Setter 有利无害；也有人说尽量避免使用 Getter/Setter。这些观点背后都藏着一些软件的设计思维。例如怎样设计类的接口，如何实现封装，这些都是后续需要学习思考的内容。</p>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>