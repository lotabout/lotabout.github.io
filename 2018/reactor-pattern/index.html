<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="如果你熟悉 Java 的 23 种设计模式，看到“Reactor 模式”可能就会一脸懵逼，这是什么鬼。Reactor 是一种应用在服务器端的开发模式（也有说法称 Reactor 是一种 IO 模式），目的是提高服务端程序的并发能力。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Reactor 模式简介 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/async/" rel="tag">async</a><a class="post-tag-noise-link" href="/tags/reactor/" rel="tag">reactor</a></div><div class="post-time">2018-06-28</div></div></div><div class="container post-header"><h1>Reactor 模式简介</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#reactor-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">Reactor 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A4%90%E5%8E%85%E9%87%8C%E7%9A%84-reactor-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">餐厅里的 Reactor 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>如果你熟悉 Java 的 23 种设计模式，看到“Reactor 模式”可能就会一脸懵逼，这是什么鬼。Reactor 是一种应用在服务器端的开发模式（也有说法称 Reactor 是一种 IO 模式），目的是提高服务端程序的并发能力。</p>
<h2 id="reactor-模式"><a class="header-anchor" href="#reactor-模式"></a>Reactor 模式</h2>
<p>它要解决什么问题呢？传统的 thread per connection 用法中，线程在真正处理请求之前首先需要从 socket 中读取网络请求，而在读取完成之前，线程本身被阻塞，不能做任何事，这就导致线程资源被占用，而线程资源本身是很珍贵的，尤其是在处理高并发请求时。</p>
<p>而 Reactor 模式指出，在等待 IO 时，线程可以先退出，这样就不会因为有线程在等待
IO 而占用资源。但是这样原先的执行流程就没法还原了，因此，我们可以利用事件驱动的方式，要求线程在退出之前向 event loop 注册回调函数，这样 IO 完成时 event
loop 就可以调用回调函数完成剩余的操作。</p>
<p>所以说，Reactor 模式通过减少服务器的资源消耗，提高了并发的能力。当然，从实现角度上，事件驱动编程会更难写，难 debug 一些。</p>
<h2 id="餐厅里的-reactor-模式"><a class="header-anchor" href="#餐厅里的-reactor-模式"></a>餐厅里的 Reactor 模式</h2>
<p>我们用“餐厅”类比的话，就像下图：</p>
<img src="/2018/reactor-pattern/reactor-old-servers.svg" class="" title="Connection Per Thread">
<p>对于每个新来的顾客，前台都需要找到一个服务员和厨师来服务这个顾客。</p>
<ol>
<li>服务员给出菜单，并等待点菜</li>
<li>顾客查看菜单，并点菜</li>
<li>服务员把菜单交给厨师，厨师照着做菜</li>
<li>厨师做好菜后端到餐桌上</li>
</ol>
<p>这就是传统的多线程服务器。每个顾客都有自己的服务团队（线程），在人少的情况下是可以良好的运作的。现在餐厅的口碑好，顾客人数不断增加，这时服务员就有点处理不过来了。</p>
<p>这时老板发现，每个服务员在服务完客人后，都要去休息一下，因此老板就说，“你们都别休息了，在旁边待命”。这样可能 10 个服务员也来得及服务 20 个顾客了。这也是“线程池”的方式，通过重用线程来减少线程的创建和销毁时间，从而提高性能。</p>
<p>但是客人又进一步增加了，仅仅靠剥削服务员的休息时间也没有办法服务这么多客人。老板仔细观察，发现其实服务员并不是一直在干活的，大部分时间他们只是站在餐桌旁边等客人点菜。</p>
<p>于是老板就对服务员说，客人点菜的时候你们就别傻站着了，先去服务其它客人，有客人点好的时候喊你们再过去。对应于下图：</p>
<img src="/2018/reactor-pattern/reactor-new-servers.svg" class="" title="Server with Reactor">
<p>最后，老板发现根本不需要那么多的服务员，于是裁了一波员，最终甚至可以只有一个服务员。</p>
<p>这就是 Reactor 模式的核心思想：减少等待。当遇到需要等待 IO 时，先释放资源，而在 IO 完成时，再通过事件驱动 (event driven) 的方式，继续接下来的处理。从整体上减少了资源的消耗。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="https://www.cse.wustl.edu/~schmidt/PDF/reactor-siemens.pdf">https://www.cse.wustl.edu/~schmidt/PDF/reactor-siemens.pdf</a> 原版论文，图文并茂</li>
<li><a href="https://blog.csdn.net/xxqi1229/article/details/39292661">https://blog.csdn.net/xxqi1229/article/details/39292661</a> Reactor 模式的类比</li>
<li><a href="http://www.cnblogs.com/luxiaoxun/p/4331110.html">Scalable IO in Java</a> 几种
Reactor 模式的扩展</li>
</ul>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>