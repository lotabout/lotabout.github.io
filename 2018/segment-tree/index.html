<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;不查不知道，一查吓一跳，“线段树”这个名字的定义真是混乱到一定程度了。&lt;/p&gt;
&lt;p&gt;维基百科 &lt;a href=&quot;https://en.wikipedia.org/wiki/Segment_tree&quot;&gt;Segment Tree&lt;/a&gt; 说它是一种数据结构，用来存储区间或线段，用来在 &lt;code&gt;O(log n)&lt;/code&gt; 的时间内查找包含某个点的所有区间。一般线段树是静态的结构，不需要修改的，但一些教程又很强调线段树的修改，比如说“lazy 节点是线段树的精髓“。与此同时，另一种结构区间树(&lt;a href=&quot;https://en.wikipedia.org/wiki/Interval_tree&quot;&gt;Interval
Tree&lt;/a&gt;) 在结构和功能上和线段树又十分接近。看来看去，线段树，区间树在维基百科、教材、博客里的介绍经常大不相同。&lt;/p&gt;
&lt;p&gt;本文里，我们以解决区间最小值(RMQ)问题中使用的数据结构为基准，讲讲“线段树”的基本思想。&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>线段树 (区间树) | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></div><div class="post-time">2018-02-08</div></div></div><div class="container post-header"><h1>线段树 (区间树)</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%AD%90"><span class="toc-number">1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.1.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-number">2.2.</span> <span class="toc-text">更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA"><span class="toc-number">2.3.</span> <span class="toc-text">构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">3.</span> <span class="toc-text">结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></details></div><div class="container post-content"><p>不查不知道，一查吓一跳，“线段树”这个名字的定义真是混乱到一定程度了。</p>
<p>维基百科 <a href="https://en.wikipedia.org/wiki/Segment_tree">Segment Tree</a> 说它是一种数据结构，用来存储区间或线段，用来在 <code>O(log n)</code> 的时间内查找包含某个点的所有区间。一般线段树是静态的结构，不需要修改的，但一些教程又很强调线段树的修改，比如说“lazy 节点是线段树的精髓“。与此同时，另一种结构区间树(<a href="https://en.wikipedia.org/wiki/Interval_tree">Interval
Tree</a>) 在结构和功能上和线段树又十分接近。看来看去，线段树，区间树在维基百科、教材、博客里的介绍经常大不相同。</p>
<p>本文里，我们以解决区间最小值(RMQ)问题中使用的数据结构为基准，讲讲“线段树”的基本思想。</p>
<span id="more"></span>
<p>开始前先申明博主是不搞 ACM 的，因此平时也接触不到这些高级的数据结构。但在学习时看网上的教程也是一头雾水，也因此才想记录自己的学习所得。如有不当之处，请批评指正。</p>
<h2 id="引子"><a class="header-anchor" href="#引子"></a>引子</h2>
<p>首先我们考虑一个数组 A，我们要求 $Q(i, j) = min(A_i, A_{i+1}, …, A_j)$。即
<code>A[i], ... A[j]</code> 中的最小值。如果只求一次，那自然是遍历一次，花费 $O(n)$ 时间。如果这个查询很频繁，那很自然地想到先做个索引。</p>
<p>最简单直观的方式是建一个表 <code>index</code>，有 <code>index[i][j] = Q(i,j)</code>，例如</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = [1, 3, 2, 3]</span><br><span class="line"></span><br><span class="line"> j0  1  2  3</span><br><span class="line">i┌──────────</span><br><span class="line">0│1  1  1  1</span><br><span class="line">1│   3  2  2</span><br><span class="line">2│      2  2</span><br><span class="line">3│         3</span><br></pre></td></tr></table></figure></div>
<p>很 Naive 的建表需要 $O(n^3)$ 时间。如果注意到 <code>dp[i][j] = min(dp[i+1][j], A[i])</code> 则只需要 $O(n^2)$ 的时间。现在考虑 <code>A[i]</code> 元素发生变化，则需要 $O(n^2)$
时间更新。</p>
<p>现在考虑更新和查询操作各占 50%，这种建立索引的方式就变得不太合适，于是我们想到了树结构。</p>
<h2 id="线段树"><a class="header-anchor" href="#线段树"></a>线段树</h2>
<p>RMQ 问题代表的是一类“区间查询”的问题，即我们需要对 <code>A[i], ... A[j]</code> 作一些统计，上面的例子里我们想求最小值，常见的还有求最大值，求和，求积，等等。而线段树给我们提供了一种比较通用的索引方式，来加快查询的速度。</p>
<p>我们说“线段树”是索引，也就是说它的作用是对某些数据进行预处理。这一点很重要，我认为理解线段树的重点就在于理解它是如何对原数据进行索引的。</p>
<p>有数组： <code>A = [0,5,2,5,4,3,1,6,3]</code>，也就是说原数据是 9 个离散的点（实际可以扩展成连续的类型）。现在我们为这个数组构建“线段树”。树的每个节点包含两种数据，一是区间 <code>[i, j]</code>，另一个是该区间里问题的解，这里存放的是 <code>Q(i, j)</code> 值。于是创建线段树如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)</span><br><span class="line">                             [0,15]</span><br><span class="line">                               0</span><br><span class="line">               ┌───────────────┴───────────────┐</span><br><span class="line">             [0,7]                           [8,15]</span><br><span class="line">               0                               3</span><br><span class="line">       ┌───────┴───────┐               ┌───────┴───────┐</span><br><span class="line">     [0,3]           [4,7]           [8,11]</span><br><span class="line">       0               1               3</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐       ┌───┴───┐       ┌───┴───┐</span><br><span class="line"> [0,1]   [2,3]   [4,5]   [6,7]   [8,9]</span><br><span class="line">   0       2       3       1       3</span><br><span class="line"> ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐</span><br><span class="line"> 0   5   2   5   4   3   1   6   3</span><br><span class="line"> ┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───</span><br><span class="line"> 0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5</span><br></pre></td></tr></table></figure></div>
<p>上面的树是自底向上创建的，我们添加了许多空节点来让树达到满二叉树，这种树的好处是节点不需要真正存放 <code>[i,j]</code>，如果我们对所有节点编号，那么每个节点对应的区间其实可以直接由它的编号得到，当然具体的对应关系和编号的方法有关。同时这种树存放在数组里特别方便。另一种自上而下的方法是：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2)</span><br><span class="line">                                [0,8]</span><br><span class="line">                                  0</span><br><span class="line">                  ┌───────────────┴───────────────┐</span><br><span class="line">                [0,4]                           [5,8]</span><br><span class="line">                  0                               1</span><br><span class="line">          ┌───────┴───────┐               ┌───────┴───────┐</span><br><span class="line">        [0,2]           [3,4]           [5,6]           [7,8]</span><br><span class="line">          0               4               1               3</span><br><span class="line">      ┌───┴───┐       ┌───┴───┐       ┌───┴───┐       ┌───┴───┐</span><br><span class="line">    [0,1]   [2,2]   [3,3]   [4,4]   [5,5]   [6,6]   [7,7]   [8,8]</span><br><span class="line">      0       2       5       4       3       1       6       3</span><br><span class="line">    ┌─┴─┐</span><br><span class="line"> [0,0] [1,1]</span><br><span class="line">   0     5</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="查询"><a class="header-anchor" href="#查询"></a>查询</h3>
<p>有了上面的树，我们要回答 $Q(i,j)$ 是多少。例如我们问 <code>Q(3,5)</code>，纵观全局，我们发现其实 <code>[3,5]</code> 在树中没有对应的节点，但我们可以一步步查询求得：</p>
<ol>
<li><code>[0,8]</code>: 输入 <code>[3,5]</code>。发现 <code>[3,5]</code> 被包含在 <code>[0,8]</code> 之中，通过计算我们发现
<code>[3,5]</code> 横跨 <code>[0,4]</code> 与 <code>[5,8]</code>，因此我们递归求 <code>min(Q(3,4), Q(5,5))</code></li>
<li><code>[0,4]</code>：输入 <code>[3,4]</code>，发现它完全在 <code>[0,4]</code> 的右子树，于是向右子树查询 <code>[3,4]</code></li>
<li><code>[3,4]</code>：输入 <code>[3,4]</code> 与自己完全重合，于是返回保存的值 <code>4</code></li>
<li><code>[5,8]</code>：输入 <code>[5,5]</code>，向左子树查询</li>
<li><code>[5,6]</code>：输入 <code>[5,5]</code>，向左子树查询</li>
<li><code>[5,5]</code>：输入 <code>[5,5]</code>，与自己完全重合，返回保存的值 <code>3</code></li>
<li><code>[0,8]</code>：返回 <code>min(4, 3) = 3</code></li>
</ol>
<p>上面的描述比较啰唆，主要是因为算法本身就是递归的过程。写成代码如下：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">root, i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> root.left == i <span class="keyword">and</span> root.rigth == j:</span><br><span class="line">        <span class="keyword">return</span> root.value</span><br><span class="line"></span><br><span class="line">    mid = (root.left + root.right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> j &lt;= mid:</span><br><span class="line">        <span class="keyword">return</span> search(root.left, i, j)</span><br><span class="line">    <span class="keyword">elif</span> i &gt;= mid + <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> search(root.right, i, j)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(search(root.left_child, i, mid), search(root.right_child, mid+<span class="number">1</span>, j))</span><br></pre></td></tr></table></figure></div>
<p>这个算法的时间复杂度是 $O(\log n)$。虽然代码看上去需要访问整棵树的所有节点，但实际上，在线段树的每一层，至多只有两个节点需要继续向下求值。这里不严格证明，直观上，如果在某一层有三个节点 A, B, C 需要继续向下求值，设 <code>B = [b, b']</code> 是这三个节点的中间节点，而 B 的输入是 <code>[x, x']</code>，我们可以推出 <code>b == x and b' == x'</code>。否则最开始的输入不可能是一个区间。</p>
<p>例如我们求 <code>Q(2,5)</code>，当访问节点 <code>[0,2]</code> 输入为 <code>(2,2)</code> 我们记为 <code>[0,2]: (2,2)</code>。在第 2 层时需要访问 <code>[0,2]: (2,2)</code>, <code>[3,4]: (3,4)</code>, <code>[5,6]: (5,5)</code>。可以看见中间节点 <code>[3,4]: (3,4)</code> 是可以直接返回的，不需要再继续向下求值，而
<code>[0,2]: (2,2)</code> 和 <code>[5,6]: (5,5)</code> 是需要继续向下求值的。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0│                               [0,8]</span><br><span class="line"> │                                 0</span><br><span class="line"> │                 ┌───────────────┴───────────────┐</span><br><span class="line">1│               [0,4]                           [5,8]</span><br><span class="line"> │                 0                               1</span><br><span class="line"> │         ┌───────┴───────┐               ┌───────┴───────┐</span><br><span class="line">2│       [0,2]           [3,4]           [5,6]           [7,8]</span><br><span class="line"> │         0               4               1               3</span><br><span class="line"> │     ┌───┴───┐       ┌───┴───┐       ┌───┴───┐       ┌───┴───┐</span><br><span class="line">3│   [0,1]   [2,2]   [3,3]   [4,4]   [5,5]   [6,6]   [7,7]   [8,8]</span><br><span class="line"> │     0       2       5       4       3       1       6       3</span><br><span class="line"> │   ┌─┴─┐</span><br><span class="line">4│[0,0] [1,1]</span><br><span class="line"> │  0     5</span><br></pre></td></tr></table></figure></div>
<h3 id="更新"><a class="header-anchor" href="#更新"></a>更新</h3>
<p>这里更新不讲那些有的没的，复杂的操作。只说“显而易见”，一个底部节点的修改只影响该节点及所有父/祖父节点，因此是 $O(\log n)$。</p>
<h3 id="构建"><a class="header-anchor" href="#构建"></a>构建</h3>
<p>构建的算法其实也没啥说的，例如自底向上一个个创建父节点，每个都需要 <code>O(1)</code>，而共有 <code>O(n)</code> 个父节点，所以也是 <code>O(n)</code> 的时间。</p>
<h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2>
<p>我认为线段树的本质，就是用这种“二进制”（二分）的方式去组织（统计）信息。我们可以看到：</p>
<ol>
<li>线段树的每个节点保存了部分信息，即某个子区间的解</li>
<li>对任意输入，我们通过 $O(\log n)$ 个结点就可以组合得到最终的结果</li>
<li>而理论上组合 $O(\log n)$ 个节点的过程需要是 $O(n)$ 的时间，比如上面提到的
<code>min, max, sum, ...</code> 操作，都是 $O(n)$ 复杂度的。</li>
</ol>
<p>这又让我想起了以前见过的一道面试题，1000 个瓶子里只有一瓶是毒药，毒要一星期才发作，要在一星期内找出哪瓶有毒，需要多少只老鼠。其本质也是利用二进制的方式去统计信息。（当然并不是二叉树）</p>
<p>知道了这一点之后，相信即使之后看见更复杂的树结构，也能更好地去理解了吧。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2>
<ul>
<li><a href="https://www.hackerearth.com/zh/practice/data-structures/advanced-data-structures/segment-trees/tutorial/">https://www.hackerearth.com/zh/practice/data-structures/advanced-data-structures/segment-trees/tutorial/</a> 线段树入门</li>
<li><a href="http://codeforces.com/blog/entry/18051">http://codeforces.com/blog/entry/18051</a> “线段树”的各种低级高级用法</li>
<li><a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/intervaltrees.pdf">https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/intervaltrees.pdf</a> “标准” 区间树的教程</li>
</ul>
</div></div><script type="text/x-mathjax-config">
   MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>