<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="可能是 Ruby 带的头，大家喜欢把“元编程”称作魔法，其实哪有什么魔法，一切都是科学。而 meta classes 就是 Python 里最魔法的科学，也是 99% 的人用不到的科学。只是谁还不想学点魔法呢？"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Python 元类 (MetaClass) 小教程 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/meta-programming/" rel="tag">meta-programming</a><a class="post-tag-noise-link" href="/tags/python/" rel="tag">python</a></div><div class="post-time">2018-04-06</div></div></div><div class="container post-header"><h1>Python 元类 (MetaClass) 小教程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B7%E7%88%B7-%E5%85%83%E7%88%B8%E7%88%B8"><span class="toc-number">1.</span> <span class="toc-text">爷爷 &#x3D; 元爸爸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%98%AF%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">类是动态创建的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">类的创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">元类的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%AD%90%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">强制子类实现特定方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%89%80%E6%9C%89%E5%AD%90%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">注册所有子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-vs-init"><span class="toc-number">4.3.</span> <span class="toc-text">new vs init</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>可能是 Ruby 带的头，大家喜欢把“元编程”称作魔法，其实哪有什么魔法，一切都是科学。而 meta classes 就是 Python 里最魔法的科学，也是 99% 的人用不到的科学。只是谁还不想学点魔法呢？</p>
<p>（本文使用的语法仅在 Python 3 下有效）</p>
<h2 id="爷爷-元爸爸"><a class="header-anchor" href="#爷爷-元爸爸"></a>爷爷 = 元爸爸</h2>
<blockquote>
<p>Meta is a prefix used in English to indicate a concept which is an
abstraction behind another concept, used to complete or add to the latter.</p>
</blockquote>
<p>根据<a href="https://en.wikipedia.org/wiki/Meta">维基百科</a>，英语前缀 <code>meta-</code> 指对一种抽象概念的抽象，得到另一种概念。比如说编程 programming 一般指编写代码来读取、生成或转换<strong>数据</strong>。那么元编程 <code>meta-programming</code> 一般就指人编写代码来读取、生成或转换<strong>代码</strong>。</p>
<p>听着很玄幻，但 meta 让我想到了一首儿歌，有句歌词：“爸爸的爸爸叫什么？爸爸的爸爸叫爷爷”，现在有了 <code>meta-</code>，我们可以把爷爷叫作 <code>meta-爸爸</code>（元爸爸）了。</p>
<p>我们知道 Python 里一切都是对象，那么是对象就有对应的“类(Class)”，或称“类型(type)”。
Python 中可以用 <code>type(obj)</code> 来得到对象的“类”：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">#&gt; int</span></span><br><span class="line"><span class="built_in">type</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">#&gt; list</span></span><br><span class="line"><span class="built_in">type</span>(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">#&gt; dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoNothing</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">x = DoNothing()</span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"><span class="comment">#&gt; __main__.DoNothing</span></span><br></pre></td></tr></table></figure></div>
<p>既然一切都是对象，一个“类(class)”也可以认为是一个对象，那么类的“类型(type)”是什么呢？</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="built_in">int</span>), <span class="built_in">type</span>(<span class="built_in">list</span>), <span class="built_in">type</span>(<span class="built_in">dict</span>)</span><br><span class="line"><span class="comment">#&gt; (type, type, type)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(DoNothing)</span><br><span class="line"><span class="comment">#&gt; type</span></span><br></pre></td></tr></table></figure></div>
<p>可以看到，“类(class)”的类型(type) 都是 <code>type</code>。那 <code>type</code> 的类型又是什么呢？</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="built_in">type</span>)</span><br><span class="line"><span class="comment">#&gt; type</span></span><br></pre></td></tr></table></figure></div>
<p>抱歉，<code>type</code> 的类型还是 <code>type</code>，是一个递归的类型。</p>
<p>对象的类型叫作类(class)，<strong>类的类型就称作元类 <code>meta-class</code></strong>。是不是很像“爸爸的爸爸叫爷爷”？换句话说，“普通类(class)”可以用来生成实例(instance)，同样的，元类
(meta-class)也可以生成实例，生成的实例就是“普通类”了。</p>
<h2 id="类是动态创建的"><a class="header-anchor" href="#类是动态创建的"></a>类是动态创建的</h2>
<p>我们知道，类(class)可以有多个实例(instance)。而创建实例的方法就是调用类的构造函数(constructor)：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">spam = Spam(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>上例我们定义了一个类，并调用类的构造函数创建了该类的一个实例。我们知道类也可以看作类 <code>type</code> 的一个实例，那么如何用 <code>type</code> 的构造函数来动态创建一个类呢？我们先看看 <a href="https://docs.python.org/3.6/library/functions.html#type">type 的构造函数</a>：</p>
<p>type(name, bases, dict):</p>
<ul>
<li><code>name</code>: 字符串类型，存放新类的名字</li>
<li><code>bases</code>: 元组(tuple)类型，指定类的基类/父类</li>
<li><code>dict</code>: 字典类型，存放该类的所有属性(attributes)和方法(method)</li>
</ul>
<p>例如下面的类：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    counter = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_counter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.counter</span><br><span class="line"></span><br><span class="line">x = Derived()</span><br><span class="line">x.get_counter()</span><br><span class="line"><span class="comment">#&gt; 10</span></span><br></pre></td></tr></table></figure></div>
<p>我们可以调用 <code>type(...)</code> 来动态创建这两个类：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Base = <span class="built_in">type</span>(<span class="string">&#x27;Base&#x27;</span>, (), &#123;<span class="string">&#x27;counter&#x27;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">Derived = <span class="built_in">type</span>(<span class="string">&#x27;Derived&#x27;</span>, (Base,), <span class="built_in">dict</span>(get_counter=<span class="keyword">lambda</span> <span class="variable language_">self</span>: <span class="variable language_">self</span>.counter))</span><br><span class="line"></span><br><span class="line">x = Derived()</span><br><span class="line">x.get_counter()</span><br><span class="line"><span class="comment">#&gt; 10</span></span><br></pre></td></tr></table></figure></div>
<p>是的，你没有猜错，Python 在遇到 <code>class ...</code> 关键字时会一步步解析类的内容，最终调用 <code>type(...)</code> （准确说是指定的元类）的构造函数来创建类，换句话说上面两种定义类的方式是等价的。在下节我们会具体讲解。</p>
<h2 id="类的创建过程"><a class="header-anchor" href="#类的创建过程"></a>类的创建过程</h2>
<p>要了解元类(meta-class)的作用，我们就需要了解 Python 里<a href="https://docs.python.org/3/reference/datamodel.html#metaclasses">类的创建过程
</a>，如下：</p>
<img src="/2018/Understanding-Python-MetaClass/class-creation.svg" class="" title="Class Creation Step in Python">
<ol>
<li>当 Python 见到 <code>class</code> 关键字时，会首先解析 <code>class ...</code> 中的内容。例如解析基类信息，最重要的是找到对应的元类信息（默认是 <code>type</code>)。</li>
<li>元类找到后，Python 需要准备 namespace （也可以认为是上节中 <code>type</code> 的 <code>dict</code>
参数）。如果元类实现了 <code>__prepare__</code> 函数，则会调用它来得到默认的 namespace
。</li>
<li>之后是调用 <code>exec</code> 来执行类的 body，包括属性和方法的定义，最后这些定义会被保存进 namespace。</li>
<li>上述步骤结束后，就得到了创建类需要的所有信息，这时 Python 会调用元类的构造函数来真正创建类。</li>
</ol>
<p>如果你想在类的创建过程中做一些定制(customization)的话，创建过程中任何用到了元类的地方，我们都能通过覆盖元类的默认方法来实现定制。这也是元类“无所不能”的所在，它深深地嵌入了类的创建过程。</p>
<h2 id="元类的应用"><a class="header-anchor" href="#元类的应用"></a>元类的应用</h2>
<blockquote><p>元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。</p>
<footer><strong>Python界的领袖 Tim Peters</strong></footer></blockquote>
<p>为了文章的完整性，以及日后查阅方便，这里还是要举两个例子的。顺带一提，下面这两个例子在 Python 3.6 之后都可以通过覆盖基类的
<a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__">__init_subclass__</a>
来实现，而不需要通过元类实现。</p>
<h3 id="强制子类实现特定方法"><a class="header-anchor" href="#强制子类实现特定方法"></a>强制子类实现特定方法</h3>
<p>假设你是一个库的作者，例如下面的代码，其中的方法 <code>foo</code> 要求子类实现方法 <code>bar</code>
：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># library code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># user code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>
<p>但作为库的作者，我们根本无法预测用户会写出什么样的代码，有什么方法能强制用户在子类中实现方法 <code>bar</code> 呢？用 meta-class 可以做到。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> name != <span class="string">&#x27;Base&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;bar&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> namespace:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad user class&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, namespace, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="built_in">object</span>, metaclass=Meta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.bar()</span><br></pre></td></tr></table></figure></div>
<p>现在，我们尝试定义一个不包含 <code>bar</code> 方法的子类，在类的定义（或者说生成）阶段就会报错：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Derived(Base):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in __new__</span><br><span class="line">TypeError: bad user class</span><br></pre></td></tr></table></figure></div>
<h3 id="注册所有子类"><a class="header-anchor" href="#注册所有子类"></a>注册所有子类</h3>
<p>有时我们会希望获取继承了某个类的子类，例如，实现了基类 <code>Fruit</code>，想知道都有哪些子类继承了它，用元类就能实现这个功能：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, bases, namespace, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;registory&#x27;</span>):</span><br><span class="line">            <span class="comment"># this is the base class</span></span><br><span class="line">            cls.registory = &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># this is the subclass</span></span><br><span class="line">            cls.registory[name.lower()] = cls</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>(<span class="built_in">object</span>, metaclass=Meta):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>(<span class="title class_ inherited__">Fruit</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span>(<span class="title class_ inherited__">Fruit</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>
<p>之后，我们可以查看所有 <code>Fruit</code> 的子类：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Fruit.registory</span><br><span class="line">&#123;&#x27;apple&#x27;: &lt;class &#x27;__main__.Apple&#x27;&gt;, &#x27;orange&#x27;: &lt;class &#x27;__main__.Orange&#x27;&gt;&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="new-vs-init"><a class="header-anchor" href="#new-vs-init"></a>new vs init</h3>
<p>上面的例子中我们分别用了 <code>__new__</code> 和 <code>__init__</code>，但其实这两个例子里用哪种方法都是可行的。</p>
<p><code>__new__</code> 用来创建一个（未初始化）实例；<code>__init__</code> 则是用来初始化一个实例。在元类的 <code>__new__</code> 方法中，因为类实例还没有创建，所以可以更改最后生成类的各项属性：诸如名称，基类或属性，方法等。而在 <code>__init__</code> 中由于类已经创建完成，所以无法改变。正常情况下不需要关心它们的区别。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<ul>
<li>对象的类型称为类，类的类就称为元类。</li>
<li>Python 中对元类实例化的结果就是“普通类”，这个过程是动态的。</li>
<li>在定义类时可以指定元类来改变类的创建过程。</li>
</ul>
<p>请你相信，作为平民百姓，咱们是没有机会用到魔法的。但学习本身对于了解语言的设计是很有帮助的，何况万一有个万一呢◔_◔？</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="https://jakevdp.github.io/blog/2012/12/01/a-primer-on-python-metaclasses/">A Primer on Python Metaclasses</a> 一步步教你理解 meta class</li>
<li><a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">Understanding Python metaclasses</a> 对 Python 中的 attribute lookup 有清晰的讲解</li>
<li><a href="https://www.youtube.com/watch?v=sPiWg5jSoZI">Python 3 Metaprogramming</a> 3 小时的视频，风趣幽默地对讲解了 Python 元编程的各个方面。</li>
</ul>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js" data-repo="lotabout/lotabout.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1NTQ0Nw==" data-category="Announcements" data-category-id="DIC_kwDOATmmt84ClmcD" data-mapping="" data-strict="" data-reactions-enabled="0" data-emit-metadata="" data-input-position="" data-theme="" data-lang="zh-CN" data-loading="" crossorigin="" async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-39956831-2');</script></body></html>